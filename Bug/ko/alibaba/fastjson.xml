<?xml version="1.0" encoding="ISO-8859-1"?>

<bugs>
	<bug>
		<id>3334</id>
		<title>某一个field的类型不匹配导致整个对象反序列化不出来的问题</title>
		<body>客户端和服务端在某一个协议字段定义类型不匹配或服务端赋值错误，导致客户端整个对象都反序列化不出来，比如客户端把某个字段定义为Int，服务端字段定义为String，如果这个字段被赋值了一个非数字的字符串，比如被赋值为“false”，客户端通过JSON.parseObject的时候，会抛cast error，这样整个对象都解析不出来，最佳解决方案是客户端和服务端定义的类型一致规避问题，但是fastjson能不能提供自动忽略某一个字段解析异常但是不影响这个对象其他字段正常解析的功能？  如果我问题没有描述清楚，请联系我钉钉：搏达   ，谢谢！</body>
		<created>2020-07-07 06:59:02</created>
		<closed>2020-07-12 07:53:26</closed>
	</bug>
	<bug>
		<id>3284</id>
		<title>FieldDeserializer.setValue(Object object, Object value)时没有考虑java11中的List.of()</title>
		<body>- 版本1.2.70； - FieldDeserializer类的setValue(Object object, Object value)方法，第106行： ``` Collection collection = (Collection) method.invoke(object); if (collection != null &amp;&amp; value != null) {     String collectionClassName = collection.getClass().getName();     if (collection == Collections.emptySet()             || collection == Collections.emptyList()             || collectionClassName.startsWith("java.util.Collections$Unmodifiable")) {         // skip         return;     }      if (!collection.isEmpty()) {         collection.clear();     }      if (collectionClassName.equals("kotlin.collections.EmptyList")         || collectionClassName.equals("kotlin.collections.EmptySet")) {         if (fieldInfo.field != null                 &amp;&amp; !Modifier.isFinal(fieldInfo.field.getModifiers())) {             fieldInfo.field.set(object, (Collection) value);         }         return;     }     collection.addAll((Collection) value); } ``` - setValue时考虑了 Collections.emptyList()和className=java.util.Collections$Unmodifiable的情况，然而java11的List.of()同样是不可编辑的，但其className为java.util.ImmutableCollections$ListN，导致走到该分支时异常`throw new JSONException("set property error, " + clazz.getName() + "#" + fieldInfo.name, e);` - 测试伪代码： ``` @AllArgsConstructor @Data @NoArgsConstructor static class TestA {     String name;     String ext;      public List&lt;String&gt; getTags() {         if (Objects.nonNull(ext)) {             // 只做测试，随便返回             return List.of("test1");         }         // 否则返回空列表         return List.of();     } }  @Test public void name() {     String jsonText = "{\"name\":\"测试数据\", \"tags\":[{\"tagNme\":\"abc\",\"id\":\"1\"}]}";     TestA testA = JSONObject.parseObject(jsonText, TestA.class);     System.out.printf("" + testA); } ``` </body>
		<created>2020-06-21 10:15:05</created>
		<closed>2020-06-21 11:53:31</closed>
	</bug>
	<bug>
		<id>3280</id>
		<title>1.2.71版本,在JDK1.7下运行JSON.parseObject时，报错java.lang.ClassNotFoundException: java.time.LocalDateTime</title>
		<body>你好： 在1.2.71版本下，使用如下方法测试可以复现。JDK版本1.7. public class DbInfoTest { public static void main(String[] args) throws Exception { String json = "{\"test\":\"test\"}"; Test t = JSON.parseObject(json,Test.class); System.out.println(t.test); } } public class Test { public String test; } 报错信息： Exception in thread "main" java.lang.NoClassDefFoundError: java/time/LocalDateTime at java.lang.Class.getDeclaredConstructors0(Native Method) at java.lang.Class.privateGetDeclaredConstructors(Class.java:2595) at java.lang.Class.getConstructor0(Class.java:2895) at java.lang.Class.getConstructor(Class.java:1731) at com.alibaba.fastjson.parser.deserializer.ASMDeserializerFactory.createJavaBeanDeserializer(ASMDeserializerFactory.java:90) at com.alibaba.fastjson.parser.ParserConfig.createJavaBeanDeserializer(ParserConfig.java:1075) at com.alibaba.fastjson.parser.ParserConfig.getDeserializer(ParserConfig.java:882) at com.alibaba.fastjson.parser.ParserConfig.getDeserializer(ParserConfig.java:592) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:679) at com.alibaba.fastjson.JSON.parseObject(JSON.java:396) at com.alibaba.fastjson.JSON.parseObject(JSON.java:300) at com.alibaba.fastjson.JSON.parseObject(JSON.java:573) at com.rkhd.ienterprise.dbinfo.DbInfoTest.main(DbInfoTest.java:11) Caused by: java.lang.ClassNotFoundException: java.time.LocalDateTime at java.net.URLClassLoader$1.run(URLClassLoader.java:366) at java.net.URLClassLoader$1.run(URLClassLoader.java:355) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:354) at java.lang.ClassLoader.loadClass(ClassLoader.java:425) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308) at java.lang.ClassLoader.loadClass(ClassLoader.java:358) ... 13 more </body>
		<created>2020-06-18 04:50:52</created>
		<closed>2020-06-18 15:51:32</closed>
	</bug>
	<bug>
		<id>3267</id>
		<title>JSONValidator解析规则有遗漏</title>
		<body>代码: JSONValidator jv = JSONValidator.from("113{}[]"); System.out.println(jv.validate()); //输出为true System.out.println(jv.getType()); //输出为Array  版本: &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.70&lt;/version&gt; &lt;/dependency&gt;</body>
		<created>2020-06-13 03:18:08</created>
		<closed>2020-06-13 13:29:33</closed>
	</bug>
	<bug>
		<id>3264</id>
		<title>Kotlin fastjson 序列化有问题</title>
		<body> class MyData(         @JSONField(name = "is_test")         var isTest: Boolean = false     )  val also = MyData().also {             it.isTest = true         }          val toJSONString = JSON.toJSONString(also)  toJSONString  序列化出来的是 {"test":true} ，不是is_test 了。你这bug也坑人了吧，没有测试吗？</body>
		<created>2020-06-12 07:03:34</created>
		<closed>2020-06-27 10:29:14</closed>
	</bug>
	<bug>
		<id>3230</id>
		<title>1.2.69和1.2.70不兼容jdk5的问题</title>
		<body>Java.lang.UnsupportedClassVersionError:Bad version number in .class file 就简单的使用JSON.parseObject或者JSON.toJSONString </body>
		<created>2020-06-03 07:47:17</created>
		<closed>2020-06-14 15:38:32</closed>
	</bug>
	<bug>
		<id>3223</id>
		<title>kotlin 1.2.70属性会为null</title>
		<body>kotlin在1.2.68的时候，反序列化成java对象正常。1.2.70版本，转为list和set类型的属性的时候会是null 有没有自测过？？有点责任好不好</body>
		<created>2020-06-02 07:38:54</created>
		<closed>2020-06-14 15:41:32</closed>
	</bug>
	<bug>
		<id>3121</id>
		<title>can not cast to Timestamp, value : 1970-01-01 00:00:00</title>
		<body>`public class TimeDemo {     public static void main(String[] args) {         try {             String time = "1970-01-01 00:00:00";             JSONObject jsonObject = new JSONObject();             jsonObject.put("time", time);              Timestamp timestamp = jsonObject.getTimestamp("time");             System.out.println("time:" + timestamp);         } catch (Exception e) {             e.printStackTrace();         }     } }`  执行如上代码，报错： `com.alibaba.fastjson.JSONException: can not cast to Timestamp, value : 1970-01-01 00:00:00 at com.alibaba.fastjson.util.TypeUtils.castToTimestamp(TypeUtils.java:665) at com.alibaba.fastjson.JSONObject.getTimestamp(JSONObject.java:339) at org.learn.time.TimeDemo.main(TimeDemo.java:21)`  根据 TypeUtils 源码发现，当时间为“1970-01-01 00:00:00”，则longValue =0，此时判定语句会抛出异常，当时的等于0是出于什么原因考虑的，是否可以改为小于0. `        if(longValue &lt;= 0){             throw new JSONException("can not cast to Timestamp, value : " + value);         } `  </body>
		<created>2020-04-14 11:51:46</created>
		<closed>2020-05-04 10:22:59</closed>
	</bug>
	<bug>
		<id>3119</id>
		<title>Easymock 运行代码 NPE</title>
		<body>com.alibaba.fastjson.JSONException: create asm serializer error, verson 1.2.68, class class com.lk.crm.common.model.receiveaddr.ReceiveAddr  at com.alibaba.fastjson.serializer.SerializeConfig.createJavaBeanSerializer(SerializeConfig.java:264) at com.alibaba.fastjson.serializer.SerializeConfig.createJavaBeanSerializer(SerializeConfig.java:120) at com.alibaba.fastjson.serializer.SerializeConfig.getObjectWriter(SerializeConfig.java:792) at com.alibaba.fastjson.serializer.SerializeConfig.getObjectWriter(SerializeConfig.java:436) at com.alibaba.fastjson.serializer.JSONSerializer.getObjectWriter(JSONSerializer.java:416) at com.alibaba.fastjson.serializer.ListSerializer.write(ListSerializer.java:128) at com.alibaba.fastjson.serializer.JSONSerializer.write(JSONSerializer.java:285) at com.alibaba.fastjson.JSON.toJSONString(JSON.java:758) at com.alibaba.fastjson.JSON.toJSONString(JSON.java:696) at com.alibaba.fastjson.JSON.toJSONString(JSON.java:661) at com.lk.crm.addr.AddrServiceTest.testList(AddrServiceTest.java:96) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.internal.runners.TestMethod.invoke(TestMethod.java:68) at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl$PowerMockJUnit44MethodRunner.runTestMethod(PowerMockJUnit44RunnerDelegateImpl.java:326) at org.junit.internal.runners.MethodRoadie$2.run(MethodRoadie.java:89) at org.junit.internal.runners.MethodRoadie.runBeforesThenTestThenAfters(MethodRoadie.java:97) at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl$PowerMockJUnit44MethodRunner.executeTest(PowerMockJUnit44RunnerDelegateImpl.java:310) at org.powermock.modules.junit4.internal.impl.PowerMockJUnit47RunnerDelegateImpl$PowerMockJUnit47MethodRunner.executeTestInSuper(PowerMockJUnit47RunnerDelegateImpl.java:131) at org.powermock.modules.junit4.internal.impl.PowerMockJUnit47RunnerDelegateImpl$PowerMockJUnit47MethodRunner.access$100(PowerMockJUnit47RunnerDelegateImpl.java:59) at org.powermock.modules.junit4.internal.impl.PowerMockJUnit47RunnerDelegateImpl$PowerMockJUnit47MethodRunner$TestExecutorStatement.evaluate(PowerMockJUnit47RunnerDelegateImpl.java:147) at org.powermock.modules.junit4.internal.impl.PowerMockJUnit47RunnerDelegateImpl$PowerMockJUnit47MethodRunner.evaluateStatement(PowerMockJUnit47RunnerDelegateImpl.java:107) at org.powermock.modules.junit4.internal.impl.PowerMockJUnit47RunnerDelegateImpl$PowerMockJUnit47MethodRunner.executeTest(PowerMockJUnit47RunnerDelegateImpl.java:82) at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl$PowerMockJUnit44MethodRunner.runBeforesThenTestThenAfters(PowerMockJUnit44RunnerDelegateImpl.java:298) at org.junit.internal.runners.MethodRoadie.runTest(MethodRoadie.java:87) at org.junit.internal.runners.MethodRoadie.run(MethodRoadie.java:50) at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl.invokeTestMethod(PowerMockJUnit44RunnerDelegateImpl.java:218) at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl.runMethods(PowerMockJUnit44RunnerDelegateImpl.java:160) at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl$1.run(PowerMockJUnit44RunnerDelegateImpl.java:134) at org.junit.internal.runners.ClassRoadie.runUnprotected(ClassRoadie.java:34) at org.junit.internal.runners.ClassRoadie.runProtected(ClassRoadie.java:44) at org.powermock.modules.junit4.internal.impl.PowerMockJUnit44RunnerDelegateImpl.run(PowerMockJUnit44RunnerDelegateImpl.java:136) at org.powermock.modules.junit4.common.internal.impl.JUnit4TestSuiteChunkerImpl.run(JUnit4TestSuiteChunkerImpl.java:117) at org.powermock.modules.junit4.common.internal.impl.AbstractCommonPowerMockRunner.run(AbstractCommonPowerMockRunner.java:57) at org.powermock.modules.junit4.PowerMockRunner.run(PowerMockRunner.java:59) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.intellij.rt.execution.CommandLineWrapper.main(CommandLineWrapper.java:66) Caused by: java.lang.NullPointerException at com.alibaba.fastjson.serializer.ASMSerializerFactory.createJavaBeanSerializer(ASMSerializerFactory.java:151) at com.alibaba.fastjson.serializer.SerializeConfig.createASMSerializer(SerializeConfig.java:92) at com.alibaba.fastjson.serializer.SerializeConfig.createJavaBeanSerializer(SerializeConfig.java:248) ... 46 more  之前的版本  https://github.com/alibaba/fastjson/issues/1652 这个说修复了  这个修复方式 https://github.com/alibaba/fastjson/commit/677aa67ee9c9bab76446b15e7309264ee0dce15e#diff-322b80afb97f66a8b42f64a007ac148a  看着不对呀   最后的151行的 这个 packageName  局部变量没用啊  是不是漏删除了？？  </body>
		<created>2020-04-13 08:41:05</created>
		<closed>2020-05-04 08:57:36</closed>
	</bug>
	<bug>
		<id>3109</id>
		<title>当 @type 的前缀为一个autotype白名单时会发生 null point</title>
		<body>#### 复现方式 ![image](https://user-images.githubusercontent.com/3929477/78140589-d3f3b980-745c-11ea-8401-87b9628baca9.png) ```java public class TestFastJson {     public static void main(String[] args) {         ParserConfig.getGlobalInstance().addAccept("test");         JSON.parseObject("{\"@type\":\"testxx\",\"dogName\":\"dog1001\"}", Dog.class);     }     public static class Dog  {         public String dogName;     } } ```  #### 原因 ![image](https://user-images.githubusercontent.com/3929477/78140518-bcb4cc00-745c-11ea-900b-72a8b5ce39ba.png) 此处没有判断 clazz 是否为 null</body>
		<created>2020-04-01 13:11:45</created>
		<closed>2020-05-04 14:15:15</closed>
	</bug>
	<bug>
		<id>3105</id>
		<title>移除了黑名单 0xD9C9DBF6BBD27BB1L ？ com.ibatis.sqlmap.engine.datasource</title>
		<body>移除了黑名单 0xD9C9DBF6BBD27BB1L ？ com.ibatis.sqlmap.engine.datasource  对比发现1.2.67  denyHashCodes 移除了 0xD9C9DBF6BBD27BB1L? 发生了什么</body>
		<created>2020-03-31 03:19:35</created>
		<closed>2020-05-04 13:00:31</closed>
	</bug>
	<bug>
		<id>3088</id>
		<title>序列化timestamp字段时，指定SerializerFeature.UseISO8601DateFormat, 当nanos为9位数值时，报ArrayIndexOutOfBoundsException</title>
		<body>fastjson version：1.2.67  stack trace: Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 29 at com.alibaba.fastjson.util.IOUtils.getChars(IOUtils.java:279) at com.alibaba.fastjson.serializer.DateCodec.write(DateCodec.java:159) at com.alibaba.fastjson.serializer.JSONSerializer.write(JSONSerializer.java:285) at com.alibaba.fastjson.JSON.toJSONString(JSON.java:745) at com.alibaba.fastjson.JSON.toJSONString(JSON.java:679) at com.ctrip.gs.dest.common.util.JsonUtility.toJsonString(JsonUtility.java:83) at com.ctrip.gs.dest.common.util.JsonUtility.toString(JsonUtility.java:24) at com.ctrip.gs.dest.common.app.App.main(App.java:36)  test code: ```java public class JsonTest {     public static void main(String[] args){         Timestamp ts = new Timestamp(Calendar.getInstance().getTimeInMillis());         String json = toJsonString(ts);          System.out.println(json);     }      private static &lt;T&gt; String toJsonString(T obj) {         ArrayList&lt;SerializerFeature&gt; allFeatures = new ArrayList&lt;&gt;();         allFeatures.add(SerializerFeature.UseISO8601DateFormat);          return JSON.toJSONString(obj, allFeatures.toArray(new SerializerFeature[0]));     } } ```  cause: DateCodec.java ```if (nanos &gt; 0) {                 buf = "0000-00-00 00:00:00.000000000".toCharArray();                 int nanoSize = IOUtils.stringSize(nanos);                 IOUtils.getChars(nanos, 30 - (9 - nanoSize), buf);                 IOUtils.getChars(second, 19, buf);                 IOUtils.getChars(minute, 16, buf);                 IOUtils.getChars(hour, 13, buf);                 IOUtils.getChars(day, 10, buf);                 IOUtils.getChars(month, 7, buf);                 IOUtils.getChars(year, 4, buf);             } ```  buf的长度是29, IOUtils.getChars(nanos, 30 - (9 - nanoSize), buf)，当nanoSize=9的时候， IOUtils.getChars里的buf[--p] = DigitOnes[r]这行回报数组越界，因为--p=29。 </body>
		<created>2020-03-25 08:45:59</created>
		<closed>2020-03-28 08:39:34</closed>
	</bug>
	<bug>
		<id>3083</id>
		<title>无法解析key为is开头的Bean</title>
		<body>` kotlin      class TestBean {         var is_subscribe = 0         var subscribe = 0         var isHave = 0     }      val s = "{'is_subscribe':1,'subscribe':1,'isHave':1}"     val b = JSON.parseObject(s, TestBean::class.java)     println("${b.is_subscribe}--${b.subscribe}--${b.isHave}") ` &gt; 运行结果 System.out: 0--1--0 &gt; 预期结果 System.out: 1--1--1</body>
		<created>2020-03-24 10:26:30</created>
		<closed>2020-05-10 14:31:35</closed>
	</bug>
	<bug>
		<id>3082</id>
		<title>嵌套 Map.Entry 反序列化异常</title>
		<body>如题，在序列化后，嵌套 Mep.Entry 反序列化异常，信息如下：  &gt; Exception in thread "main" java.lang.ClassCastException: com.alibaba.fastjson.JSONObject cannot be cast to java.util.Map$Entry &gt;         at com.test.main(main.java:27)  源代码如下：  ``` HashSet&lt;Entry&lt;String, Entry&lt;String, String&gt;&gt;&gt; nestedSet = new HashSet&lt;Entry&lt;String, Entry&lt;String, String&gt;&gt;&gt;(); nestedSet.add(new SimpleEntry&lt;String, Entry&lt;String, String&gt;&gt;("a", new SimpleEntry&lt;String, String&gt;("b", "c"))); nestedSet.add(new SimpleEntry&lt;String, Entry&lt;String, String&gt;&gt;("d", new SimpleEntry&lt;String, String&gt;("e", "f")));  String content = JSON.toJSONString(nestedSet);  HashSet&lt;Entry&lt;String, Entry&lt;String, String&gt;&gt;&gt; deserializedNestedSet;  deserializedNestedSet = JSON.parseObject(content, new TypeReference&lt;HashSet&lt;Entry&lt;String, Entry&lt;String, String&gt;&gt;&gt;&gt;(){}.getType()); System.out.println(deserializedNestedSet.iterator().next().getValue().getKey()); ```  使用环境：fastjson-1.2.62</body>
		<created>2020-03-24 09:50:41</created>
		<closed>2020-03-28 08:40:07</closed>
	</bug>
	<bug>
		<id>3079</id>
		<title>JSONValidator 验证json时 是否能够不抛excetion,而是直接返回false.</title>
		<body>JSONValidator validator = JSONValidator.from(value); boolean valid = validator.validate();  如果待验证的json 字符串缺少":" 或 其他符号时不是返回false,而是直接抛excetion.如果返回false是否更为直观?  version:1.2.67</body>
		<created>2020-03-23 11:02:07</created>
		<closed>2020-04-10 18:34:06</closed>
	</bug>
	<bug>
		<id>3066</id>
		<title>Sth. wrong with MaxSegment and MinSegment in JSONPath</title>
		<body>The inner class MaxSegment and MinSegment in JSONPath has a bug. e.g. 1 there is a JSONString like this: `{     'id' : 0,     'items' : [     {'name': 'apple', 'price' : 30 },     {'name': 'pear', 'price' : 40 }     ] }` the Path String as this:  `$.items[*].price.max()` exactly it should be "40" but throw a UnsupportedOperationException.  e.g. 2 when the path string change to `$.items[*].price.size()` , I got a correct result as "2".  so, I read the source codes like this: ` static class SizeSegment implements Segment {          public final static SizeSegment instance = new SizeSegment();          public Integer eval(JSONPath path, Object rootObject, Object currentObject) {             return path.evalSize(currentObject);         }          public void extract(JSONPath path, DefaultJSONParser parser, Context context) {             throw new UnsupportedOperationException();         }     }`  `static class MaxSegment implements Segment {          public final static MaxSegment instance = new MaxSegment();          public Object eval(JSONPath path, Object rootObject, Object currentObject) {             Object max = null;             if (rootObject instanceof Collection) {                 Iterator iterator = ((Collection) rootObject).iterator();                 while (iterator.hasNext()) {                     Object next = iterator.next();                     if (next == null) {                         continue;                     }                      if (max == null) {                         max = next;                     } else if (compare(max, next) &lt; 0) {                         max = next;                     }                 }             } else {                 throw new UnsupportedOperationException();             }              return max;         }          public void extract(JSONPath path, DefaultJSONParser parser, Context context) {             throw new UnsupportedOperationException();         }     }` In class SizeSegment,the eval function use "currentObject" , it was `$.items[*].price` . In class MaxSegment and MinSegment , they use "rootObject" , it was `$`.   so, Is it a bug? </body>
		<created>2020-03-18 03:07:49</created>
		<closed>2020-03-30 01:45:46</closed>
	</bug>
	<bug>
		<id>3061</id>
		<title>像ParserConfig.getDeserializer一样不为null及时返回，否则会影响自定义Module</title>
		<body>https://github.com/alibaba/fastjson/blob/f164d8519ff061baac6f8d58a5a1b88c2afab00e/src/main/java/com/alibaba/fastjson/serializer/SerializeConfig.java#L440</body>
		<created>2020-03-12 14:23:04</created>
		<closed>2020-05-05 06:04:49</closed>
	</bug>
	<bug>
		<id>3060</id>
		<title>JSON.toJavaObject没有考虑@JSONField里的deserializeUsing的class</title>
		<body>JSON.toJavaObject对于enum的field进行反序列化时，如果是int值，则不会考虑@JSONField里的信息，直接使用ordinal的值来反序列化了。</body>
		<created>2020-03-12 02:44:40</created>
		<closed>2020-06-14 15:49:28</closed>
	</bug>
	<bug>
		<id>3057</id>
		<title>Deque is not supported</title>
		<body>不支持Deque的反序列化  com.alibaba.fastjson.JSONException: create instance error, class java.util.Deque  at com.alibaba.fastjson.util.TypeUtils.createCollection(TypeUtils.java:2349)</body>
		<created>2020-03-11 03:48:07</created>
		<closed>2020-06-14 15:49:37</closed>
	</bug>
	<bug>
		<id>3032</id>
		<title>关于最新远程代码执行漏洞，厂商给出的修复建议是什么？Fastjson&lt;=1.2.62</title>
		<body>绿盟： 在jackson-databind 中最新发现的反序列化 gadget 也同样影响了fastjson，经绿盟科技研究人员验证复现，该漏洞影响最新的fastjson 1.2.62 版本，利用该漏洞可导致受害机器上的远程代码执行。开启了autoType功能的用户会受此漏洞影响（autoType功能默认关闭）。   https://cloud.tencent.com/announce/detail/962 http://blog.nsfocus.net/fastjson0221/</body>
		<created>2020-02-24 02:04:13</created>
		<closed>2020-03-01 06:19:15</closed>
	</bug>
	<bug>
		<id>2894</id>
		<title>纳秒级 Timestamp 解析异常</title>
		<body>``` package com.seliote.demo;  import com.alibaba.fastjson.JSONObject; import com.alibaba.fastjson.annotation.JSONField; import lombok.Data;  import java.sql.Timestamp; import java.time.LocalDateTime;  public class FastJsonTest {     public static void main(String... args) {         String json = "{\"timestamp\": \"2019-09-19 08:49:52.350000000\", " +                 "\"local_date_time\": \"2019-09-19 08:49:52.350000000\"}";         Pojo pojo = JSONObject.parseObject(json, Pojo.class);     } }  @Data class Pojo {     // 不正确，解析出是 2019-09-23 10:03:12.0     @JSONField(name = "timestamp", format = "yyyy-MM-dd HH:mm:ss.SSSSSSSSS")     private Timestamp timestamp;     // 正确，解析出是 2019-09-19T08:49:52.350     @JSONField(name = "local_date_time", format = "yyyy-MM-dd HH:mm:ss.SSSSSSSSS")     private LocalDateTime localDateTime; } ```</body>
		<created>2019-11-20 11:15:14</created>
		<closed>2019-11-26 06:29:59</closed>
	</bug>
	<bug>
		<id>2580</id>
		<title>fastjson1.2.58:java.sql.Date序列化问题</title>
		<body></body>
		<created>2019-07-24 04:18:56</created>
		<closed>2019-07-31 14:48:55</closed>
	</bug>
	<bug>
		<id>2388</id>
		<title>com.alibaba.fastjson.JSONException</title>
		<body>fastjson：1.2.57 spring：5.1.6.RELEASE  2 case： ### **case 1：** ```   public class MaintenanceInterceptor extends HandlerInterceptorAdapter {      private static final Logger LOGGER = LoggerFactory.getLogger(MaintenanceInterceptor.class);                                        @Override     public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {         if(handler instanceof HandlerMethod){             HandlerMethod hm=(HandlerMethod)handler;             LOGGER.info("JSON##1=="+JSON.toJSONString(hm)); ``` throw： ``` com.alibaba.fastjson.JSONException: write javaBean error, fastjson version 1.2.57, class org.springframework.web.method.HandlerMethod$HandlerMethodParameter, fieldName : returnType at com.alibaba.fastjson.serializer.JavaBeanSerializer.write(JavaBeanSerializer.java:523) at com.alibaba.fastjson.serializer.JavaBeanSerializer.write(JavaBeanSerializer.java:160) at com.alibaba.fastjson.serializer.JSONSerializer.writeWithFieldName(JSONSerializer.java:333) at com.alibaba.fastjson.serializer.ASMSerializer_1_HandlerMethod.write(Unknown Source) at com.alibaba.fastjson.serializer.ASMSerializer_1_HandlerMethod.write(Unknown Source) at com.alibaba.fastjson.serializer.JSONSerializer.write(JSONSerializer.java:285) at com.alibaba.fastjson.JSON.toJSONString(JSON.java:731) at com.alibaba.fastjson.JSON.toJSONString(JSON.java:669) at com.alibaba.fastjson.JSON.toJSONString(JSON.java:634) ```  **### case 2：** ``` @ControllerAdvice public class ResponseBodyAdviceChain implements ResponseBodyAdvice&lt;MappingJackson2HttpMessageConverter&gt; {               private static final Logger LOGGER = LoggerFactory.getLogger(ResponseBodyAdviceChain.class);      @Override     public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) {         LOGGER.info("ResponseBodyAdviceChain="+JSON.toJSONString(returnType) );         return false;     } ``` **throw** ``` com.alibaba.fastjson.JSONException: write javaBean error, fastjson version 1.2.57, class org.springframework.web.method.HandlerMethod$ReturnValueMethodParameter, method : getParameter at com.alibaba.fastjson.serializer.JavaBeanSerializer.write(JavaBeanSerializer.java:523) at com.alibaba.fastjson.serializer.JavaBeanSerializer.write(JavaBeanSerializer.java:160) at com.alibaba.fastjson.serializer.JSONSerializer.write(JSONSerializer.java:285) at com.alibaba.fastjson.JSON.toJSONString(JSON.java:731) at com.alibaba.fastjson.JSON.toJSONString(JSON.java:669) at com.alibaba.fastjson.JSON.toJSONString(JSON.java:634) ```</body>
		<created>2019-04-19 16:00:11</created>
		<closed>2019-07-19 14:09:22</closed>
	</bug>
	<bug>
		<id>2387</id>
		<title>Feature.InitStringFieldAsEmpty  参数问题</title>
		<body>把json字符串转换为实体对象时：用了Feature.InitStringFieldAsEmpty参数，在1.2.29版本之前可以给对象正确赋值，之后的版本就无法赋值了。 对象实体： ``` java public class TestEntity {     private String id;     private String ddd;     private String name;     //get set } ``` 测试main方法 ``` java public static void main(String[] args) {     String jsonStr = "{id:\"ss\",ddd:\"sdfsd\",name:\"hh\"}";     TestEntity news = JSON.parseObject(jsonStr, TestEntity.class, Feature.InitStringFieldAsEmpty);     System.out.println(news.toString()); } ```  </body>
		<created>2019-04-19 10:34:18</created>
		<closed>2019-07-31 13:15:25</closed>
	</bug>
	<bug>
		<id>2375</id>
		<title>pom.xml中是不是错误的依赖了trove4j？</title>
		<body>代码中没搜到对trove4j的调用</body>
		<created>2019-04-15 08:16:36</created>
		<closed>2019-07-31 13:05:14</closed>
	</bug>
	<bug>
		<id>2358</id>
		<title>用JSONObject.parseArray反序列化非静态内部类时，异常信息有误</title>
		<body>以下代码可复现  &gt; public class TestJson {     @NoArgsConstructor     @Data     public class TestJson2 {         private String test1;         private String test2;     }         public static void main(String args[]) {         String str = "[{\n" +                 "  \"test1\":\"1\",\n" +                 "  \"test2\":\"2\"\n" +                 "},\n" +                 " {\n" +                 "   \"test1\":\"1\",\n" +                 "   \"test2\":\"2\"\n" +                 " }]";         List&lt;TestJson2&gt; testJson2 = JSONObject.parseArray(str, TestJson2.class);     } }  此时报错信息为 `com.alibaba.fastjson.JSONException: create instance error, class com.meituan.evaluation.config.TestJson$TestJson2` 实际上应该报 can't create non-static inner class instance. </body>
		<created>2019-04-08 09:38:28</created>
		<closed>2019-04-11 14:58:20</closed>
	</bug>
	<bug>
		<id>2351</id>
		<title>SupportArrayToBean反序列化报错</title>
		<body>JDK版本：1.8.0_191 fastjson版本：1.2.56  复现代码如下：  ``` java import java.util.List;  import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.parser.Feature; import com.alibaba.fastjson.serializer.SerializerFeature;  public class TestJsonArray {     public static void main(String[] argv) {         // 创建空白对象         Bean1 c = new Bean1();          // 序列化         // 输出[null,null]         String s = JSON.toJSONString(c, SerializerFeature.BeanToArray);         System.out.println(s);          // 反序列化报错         // Exception in thread "main" com.alibaba.fastjson.JSONException: syntax error, expect [, actual [         JSON.parseObject(s, Bean1.class, Feature.SupportArrayToBean);     }      public static class Bean1 {          private String a;          private List&lt;Bean2&gt; b;          public String getA() {             return a;         }          public void setA(String a) {             this.a = a;         }          public List&lt;Bean2&gt; getB() {             return b;         }          public void setB(List&lt;Bean2&gt; b) {             this.b = b;         }     }      public static class Bean2  {         private String c;          public String getC() {             return c;         }          public void setC(String c) {             this.c = c;         }     } } ```  完整报错信息：  ``` Exception in thread "main" com.alibaba.fastjson.JSONException: syntax error, expect [, actual [ at com.alibaba.fastjson.parser.DefaultJSONParser.throwException(DefaultJSONParser.java:1431) at com.alibaba.fastjson.parser.deserializer.FastjsonASMDeserializer_1_Bean1.deserialzeArrayMapping(Unknown Source) at com.alibaba.fastjson.parser.deserializer.FastjsonASMDeserializer_1_Bean1.deserialze(Unknown Source) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:208) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:642) at com.alibaba.fastjson.JSON.parseObject(JSON.java:350) at com.alibaba.fastjson.JSON.parseObject(JSON.java:254) ```</body>
		<created>2019-04-02 12:07:24</created>
		<closed>2019-04-11 14:58:44</closed>
	</bug>
	<bug>
		<id>2348</id>
		<title>部分字段解析不出来</title>
		<body>现在用的是1.2.7，在升级到1.2.56后，有部分字段解析不出来 ``` RoomPersonnel .java: public class RoomPersonnel {    private String code;    private List&lt;PersonnelModel&gt; data;    private int count;    static RoomPersonnel roompersonnel;   public static RoomPersonnel getRoomPersonnel(){  if(roompersonnel==null){  roompersonnel=new  RoomPersonnel();  }  return roompersonnel;    }      public void setCode(String code) {         this.code = code;     }     public String getCode() {         return code;     }           public void setData(List&lt;PersonnelModel&gt; data) {         this.data = data;     }     public List&lt;PersonnelModel&gt; getData() {         return data;     }           public void setCount(int count) {         this.count = count;     }     public int getCount() {         return count;     } } PersonnelModel,java: public class PersonnelModel implements Serializable{  private String xm; private String xb; private String xb_; private String zjh; private String jsh; private String gj; private String gj_; private String mz; private String mz_; private String whcd; private String whcd_; private String zy; private String zy_; private String csrq; private String cbz; private String lffh; private String nl; private String rsrq; private String ay; private String ay_; private String zz; private String bahj; private String bahj_; private String jyqx; private String zszt; private String zszt_; private String pwh; private String wxdj; private String wxdj_; private String jkzk; private String fzjj; private String zdry; private String zdry_; private String photo; private String tzz; private String tzz2; private String gyqx; private String zzd; private String rsaq; private String sg; private String tz; private String hyzk; private String hyzk_; private String bhlx; private String rfid; private String jkzk_; private String gzdw; private String zjlx; private String zbzt; private String jdxj; private String wcnr; private String byzde; private String byzde_; private String badw; private String type; private String rsxz; public String getType() { return type; }  public void setType(String type) { this.type = type; }  public String getBadw() { return badw; }  public void setBadw(String badw) { this.badw = badw; }  public String getByzde() { return byzde; }  public void setByzde(String byzde) { this.byzde = byzde; }  public String getByzde_() { return byzde_; }  public void setByzde_(String byzde_) { this.byzde_ = byzde_; }  public String getJdxj() { return jdxj; }  public void setJdxj(String jdxj) { this.jdxj = jdxj; }  public String getWcnr() { return wcnr; }  public void setWcnr(String wcnr) { this.wcnr = wcnr; }  public String getGzdw() { return gzdw; }  public String getZbzt() { return zbzt; }  public void setZbzt(String zbzt) { this.zbzt = zbzt; }  public void setGzdw(String gzdw) { this.gzdw = gzdw; }  public String getZjlx() { return zjlx; }  public void setZjlx(String zjlx) { this.zjlx = zjlx; }  public String getJkzk_() { return jkzk_; }  public void setJkzk_(String jkzk_) { this.jkzk_ = jkzk_; }  public String getHyzk() { return hyzk; }  public void setHyzk(String hyzk) { this.hyzk = hyzk; }  public String getHyzk_() { return hyzk_; }  public void setHyzk_(String hyzk_) { this.hyzk_ = hyzk_; }  public String getBhlx() { return bhlx; }  public void setBhlx(String bhlx) { this.bhlx = bhlx; }  public String getRfid() { return rfid; }  public void setRfid(String rfid) { this.rfid = rfid; }  public void setXm(String xm) { this.xm = xm; }  public String getGyqx() { return gyqx; }  public void setGyqx(String gyqx) { this.gyqx = gyqx; }  public String getZzd() { return zzd; }  public void setZzd(String zzd) { this.zzd = zzd; }  public String getRsaq() { return rsaq; }  public void setRsaq(String rsaq) { this.rsaq = rsaq; }  public String getSg() { return sg; }  public void setSg(String sg) { this.sg = sg; }  public String getTz() { return tz; }  public void setTz(String tz) { this.tz = tz; }  public String getXm() { return xm; }  public void setXb(String xb) { this.xb = xb; }  public String getXb() { return xb; }  public void setXb_(String xb_) { this.xb_ = xb_; }  public String getXb_() { return xb_; }  public void setZjh(String zjh) { this.zjh = zjh; }  public String getZjh() { return zjh; }  public void setJsh(String jsh) { this.jsh = jsh; }  public String getJsh() { return jsh; }  public void setGj(String gj) { this.gj = gj; }  public String getGj() { return gj; }  public void setGj_(String gj_) { this.gj_ = gj_; }  public String getGj_() { return gj_; }  public void setMz(String mz) { this.mz = mz; }  public String getMz() { return mz; }  public void setMz_(String mz_) { this.mz_ = mz_; }  public String getMz_() { return mz_; }  public void setWhcd(String whcd) { this.whcd = whcd; }  public String getWhcd() { return whcd; }  public void setWhcd_(String whcd_) { this.whcd_ = whcd_; }  public String getWhcd_() { return whcd_; }  public void setZy(String zy) { this.zy = zy; }  public String getZy() { return zy; }  public void setZy_(String zy_) { this.zy_ = zy_; }  public String getZy_() { return zy_; }  public void setCsrq(String csrq) { this.csrq = csrq; }  public String getCsrq() { return csrq; }  public void setCbz(String cbz) { this.cbz = cbz; }  public String getCbz() { return cbz; }  public void setLffh(String lffh) { this.lffh = lffh; }  public String getLffh() { return lffh; }  public void setNl(String nl) { this.nl = nl; }  public String getNl() { return nl; }  public void setRsrq(String rsrq) { this.rsrq = rsrq; }  public String getRsrq() { return rsrq; }  public void setAy(String ay) { this.ay = ay; }  public String getAy() { return ay; }  public void setAy_(String ay_) { this.ay_ = ay_; }  public String getAy_() { return ay_; }  public void setZz(String zz) { this.zz = zz; }  public String getZz() { return zz; }  public void setBahj(String bahj) { this.bahj = bahj; }  public String getBahj() { return bahj; }  public void setBahj_(String bahj_) { this.bahj_ = bahj_; }  public String getBahj_() { return bahj_; }  public void setJyqx(String jyqx) { this.jyqx = jyqx; }  public String getJyqx() { return jyqx; }  public void setZszt(String zszt) { this.zszt = zszt; }  public String getZszt() { return zszt; }  public void setZszt_(String zszt_) { this.zszt_ = zszt_; }  public String getZszt_() { return zszt_; }  public void setPwh(String pwh) { this.pwh = pwh; }  public String getPwh() { return pwh; }  public void setWxdj(String wxdj) { this.wxdj = wxdj; }  public String getWxdj() { return wxdj; }  public void setWxdj_(String wxdj_) { this.wxdj_ = wxdj_; }  public String getWxdj_() { return wxdj_; }  public void setJkzk(String jkzk) { this.jkzk = jkzk; }  public String getJkzk() { return jkzk; }  public void setFzjj(String fzjj) { this.fzjj = fzjj; }  public String getFzjj() { return fzjj; }  public void setZdry(String zdry) { this.zdry = zdry; }  public String getZdry() { return zdry; }  public void setZdry_(String zdry_) { this.zdry_ = zdry_; }  public String getZdry_() { return zdry_; }  public void setPhoto(String photo) { this.photo = photo; }  public String getPhoto() { return photo; }  public void setTzz(String tzz) { this.tzz = tzz; }  public String getTzz() { return tzz; }  public void setTzz2(String tzz2) { this.tzz2 = tzz2; }  public String getTzz2() { return tzz2; }   public void setRsxz(String rsxz) { this.rsxz = rsxz; }  public String getRsxz() { return rsxz; }  } 其中，PersonnelModel的json是这样的： { "ID": null, "XM": "陈XX", "XB": "1", "XB_": "男", "ZJH": "522401198310176625", "JSH": "0101", "GJ": "156", "GJ_": "中国", "MZ": "01", "MZ_": "汉族", "WHCD": "48", "WHCD_": "相当中专或中技毕业", "ZY": null, "ZY_": null, "CSRQ": "1532448000000", "CBZ": null, "LFFH": "370100111201807250001", "NL": "0", "RSRQ": "1537167900000", "AY": "010180", "AY_": "资助活动案", "ZZ": "AAAA", "BAHJ": "11", "BAHJ_": "事留", "JYQX": null, "ZSZT": "11", "ZSZT_": null, "PWH": "16", "WXDJ": "3", "WXDJ_": "二级", "JKZK": null, "JKZK_": null, "FZJJ": "阿德", "ZDRY": "0", "ZDRY_": "非重点", "Photo": , "TZZ": , "TZZ2": , "GYQX": "2018/8/30 0:00:00", "ZZD": "QQQQ", "RSAQ": "阿德", "SG": 22, "TZ": 22, "HYZK": null, "HYZK_": null, "BHLX": "1", "BHLX_": null, "RFID": "23", "RFID_": "理发", "ZBZT": null, "JDXJ": null, "WCNR": null, "BYZDE": "3", "BYZDE_": null, "GL": null, "GZDW": "无单位", "ZJLX": "居民身份证", "CARDID": "D0CB8F1B", "JBR": null, "SKSJ": null, "SKYY": null, "YE": 7427.87, "BADW": "市看", "RSXZ": "事留", "ZB": null, "TYPE": "1", "CSSJ": null, "CSYY": null, "YXGW": "1" } ``` 解析不出来的字段名：RFID,BHLX,JDXJ。请问是什么原因，怎么解决？</body>
		<created>2019-04-01 07:33:55</created>
		<closed>2019-04-11 14:58:06</closed>
	</bug>
	<bug>
		<id>2344</id>
		<title>BrowserCompatible在long类型时无效</title>
		<body>当一个javabean中有long类型时使用BrowserCompatible并没有以字符串输出导致js精度丢失,而如果是包装类型Long时是正确的 版本1.2.41 ,1.2.49,1.2.55 都试过</body>
		<created>2019-03-29 03:47:05</created>
		<closed>2019-04-11 14:58:48</closed>
	</bug>
	<bug>
		<id>2343</id>
		<title>使用@JSONField注解的ordinal导致反序列化丢失数据</title>
		<body>使用方法toJavaObject时，去掉ordinal就正常。 断点调试 JSONObject 属性都正常，转换出来的对象，该字段为null。。 使用的版本1.2.56。</body>
		<created>2019-03-28 03:46:14</created>
		<closed>2019-07-31 13:07:55</closed>
	</bug>
	<bug>
		<id>2341</id>
		<title>"{\"@type\":\"1234\"}"  解析报错异常</title>
		<body>String ss = "{\"@type\":\"1234\"}"; JSON.parseObject(ss)   Method threw 'java.lang.NullPointerException' exception. Attempt to invoke virtual method 'boolean java.lang.Class.isAnnotationPresent(java.lang.Class)' on a null object reference  请问怎么关闭自省,将@type key解析为"@type"普通字符串   sdk版本: 1.1.70  android</body>
		<created>2019-03-27 10:32:24</created>
		<closed>2019-04-12 06:07:35</closed>
	</bug>
	<bug>
		<id>2306</id>
		<title>JsonPath 解析带 . 的key</title>
		<body>我有一个json, 其中一段的key是 help_score_avg.cbm 用JSONPath.extract 提取, 这样写法也不行['help_score_avg.cbm']   把 . 去掉后可以正常解析  </body>
		<created>2019-02-28 04:56:07</created>
		<closed>2019-04-11 14:58:39</closed>
	</bug>
	<bug>
		<id>2260</id>
		<title>把时间类型的转换不要设置限制1970年以上(Timestamp,Time,Date   java.sql包下的)</title>
		<body>现在自动转换会报错,之前的版本只支持了 java.util 下面的 Date</body>
		<created>2019-01-23 12:06:16</created>
		<closed>2019-04-11 14:57:44</closed>
	</bug>
	<bug>
		<id>2257</id>
		<title>Error injecting constructor, java.lang.NoClassDefFoundError: java/sql/Clob</title>
		<body>我使用1.2.55及使用的java11,报java.lang.NoClassDefFoundError: java/sql/Clob。如何解决，是java11把java/sql/Clob给删了吗。求指教。</body>
		<created>2019-01-22 03:09:17</created>
		<closed>2019-01-26 17:20:38</closed>
	</bug>
	<bug>
		<id>2254</id>
		<title>反序列化死循环</title>
		<body>JSONLexerBase这个类里 scanFieldFloatArray2这个方法有问题  ![default](https://user-images.githubusercontent.com/33475287/51392495-2c001200-1b70-11e9-835b-ba3c50b0ca83.png)  for (;;) {             if (chLocal == '[') {              //do sth             } }  如果chLocal不等于'['应该直接返回或者抛个异常出去,现在就在这无限循环了</body>
		<created>2019-01-18 14:29:30</created>
		<closed>2019-01-20 13:50:10</closed>
	</bug>
	<bug>
		<id>2253</id>
		<title>反序列化 List&lt;Map&lt;String, Object&gt;&gt;&gt; 类型加上 Feature.OrderedField 不保序</title>
		<body>``` List&lt;Map&lt;String, Object&gt;&gt; result = new ArrayList&lt;&gt;(); result.add(new LinkedHashMap&lt;&gt;()); result.get(0).put("3", 3); result.get(0).put("2", 2); result.get(0).put("7", 7);  System.out.println(JSON.toJSONString(result, SerializerFeature.WriteMapNullValue));  result = JSON.parseObject(JSON.toJSONString(result, SerializerFeature.WriteMapNullValue), new TypeReference&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt;() {}, Feature.OrderedField);  System.out.println(JSON.toJSONString(result, SerializerFeature.WriteMapNullValue)); ```  反序列化后输出 key 顺序发生了变化  ``` [{"3":3,"2":2,"7":7}] [{"2":2,"3":3,"7":7}] ```</body>
		<created>2019-01-18 07:57:31</created>
		<closed>2019-01-20 12:27:06</closed>
	</bug>
	<bug>
		<id>2251</id>
		<title>反序列化java.util.Queue失败</title>
		<body>最近用fastJson的时候发现一个问题： class A {         Queue&lt;String&gt; queue;         //其他属性 } A a = new A(); ...//其他操作对A进行Queue的初始化等 先用String s = JSON.toJSONString(a)，然后把s写入文件xxx.json中 因为写入的时候s是没有格式的，只有一行，所以在xxx.json中把它格式化了一下（仅仅为了好看） 然后再从文件xxx.json中读取s出来，反序列化： A a = JSON.parseObject(s, A.class);就出错了，报错信息是说Queue无法实例化（后来实现了个Queue的反序列化接口来进行queue字段的反序列化也不行&lt;@JSONFiled(deserializeUsing = xxx.class)&gt;） ![image](https://user-images.githubusercontent.com/21658981/51296258-404fec00-1a56-11e9-86b6-3e11ff8df4c2.png) 但是，，，如果我没有对xxx.json文件中的内容进行格式化，却是正常反序列化的……有人知道原因么 </body>
		<created>2019-01-17 04:50:03</created>
		<closed>2019-01-20 12:26:46</closed>
	</bug>
	<bug>
		<id>2249</id>
		<title>印度站fastjson升级枚举类型问题</title>
		<body> fastjson 1.2.8.sec04升级到1.2.54,引入下面的调用错误: ![image](https://user-images.githubusercontent.com/46747533/51246712-fa4b4780-19c5-11e9-8993-7ac5fbf5d6bf.png)  fastjson需支持: 1. 枚举字符串传空（null或者空字符串）： 转换为null   2. 枚举类型传非法值，映射不到枚举值：直接抛出异常</body>
		<created>2019-01-16 11:37:32</created>
		<closed>2019-01-20 12:26:58</closed>
	</bug>
	<bug>
		<id>2246</id>
		<title>JSON.toJSON 的SerializeConfig 参数只能带一层。</title>
		<body> 方法里面，以1.2.54为例。line:930,line:943,line:968  ``` public static Object toJSON(Object javaObject, SerializeConfig config){    ....              for (int i = 0; i &lt; len; ++i) {                 Object item = Array.get(javaObject, i);                /*                   这里是不是应该修改为                   Object jsonValue = toJSON(item, config);                    更为妥当一点么？                 */                 Object jsonValue = toJSON(item);                 array.add(jsonValue);             }    .... } ```  JSON.toJSON 中的 SerializeConfig 参数在toJSON  内有效，而当toJSON 遍历时，调用的是原生的toJSON，造成只有SerializeConfig.globalInstance 生效，而自定义的 SerializeConfig 无法调用超过一层。</body>
		<created>2019-01-15 08:40:56</created>
		<closed>2019-01-20 12:26:34</closed>
	</bug>
	<bug>
		<id>2240</id>
		<title>关于重复依赖检测机制</title>
		<body>请问重复依赖检测机制是什么? 目前好像没有关闭重复依赖但是开启循环依赖的方法? 如下代码ResultList不会产生`$ref`, ResultMap会产生`$ref`.  --- ```java     @Test     public void testJSON() {         ResultMap resultMap = new ResultMap();         resultMap.setA(Collections.emptyMap());         resultMap.setB(Collections.emptyMap());         System.out.println(JSON.toJSONString(resultMap));          ResultList resultList = new ResultList();         resultList.setA(Collections.emptyList());         resultList.setB(Collections.emptyList());         System.out.println(JSON.toJSONString(resultList));     }      public static class ResultMap {         private Map&lt;Long, Integer&gt; a;         private Map&lt;Long, Integer&gt; b;          public Map&lt;Long, Integer&gt; getA() {             return a;         }          public void setA(Map&lt;Long, Integer&gt; a) {             this.a = a;         }          public Map&lt;Long, Integer&gt; getB() {             return b;         }          public void setB(Map&lt;Long, Integer&gt; b) {             this.b = b;         }     }      public static class ResultList {         private List&lt;Long&gt; a;         private List&lt;Long&gt; b;          public List&lt;Long&gt; getA() {             return a;         }          public void setA(List&lt;Long&gt; a) {             this.a = a;         }          public List&lt;Long&gt; getB() {             return b;         }          public void setB(List&lt;Long&gt; b) {             this.b = b;         }     }  ``` --- ```bash {"a":{},"b":{"$ref":"$.a"}} {"a":[],"b":[]} ```</body>
		<created>2019-01-13 14:24:49</created>
		<closed>2019-01-20 13:30:13</closed>
	</bug>
	<bug>
		<id>2224</id>
		<title>复杂继承情况下 TypeUtils.getCollectionItemType() 获取类型错误导致反序列化失败</title>
		<body>`TypeUtils.getCollectionItemType()` 取了第一个泛型类型 以下情况下,不应该取第一个 ``` public abstract class KeyedCollection&lt;TKey, TItem&gt; implements Collection&lt;TItem&gt;{ ... }  public class GoodsSkuSpecValueCollection extends KeyedCollection&lt;String,GoodsSkuSpecValue&gt; { ... }  @Test public void test() {     String a = "[{\"specId\":\"chima\",\"specValueId\":\"chima_14\"}]";     GoodsSkuSpecValueCollection collection = JSON.parseObject(a, GoodsSkuSpecValueCollection.class);     Assert.assertNotNull(collection); } ``` 我稍后创建一个 pull request. </body>
		<created>2019-01-07 06:53:39</created>
		<closed>2019-01-09 07:44:53</closed>
	</bug>
	<bug>
		<id>2216</id>
		<title>请问 20181229162849000+0800 这样的时间解析错误 怎么处理</title>
		<body>https://github.com/alibaba/fastjson/blob/72a2df2a64c2c09c4fdb96563362690449711b6b/src/main/java/com/alibaba/fastjson/util/TypeUtils.java#L342 这里应该是不能进判断的 这个时间格式是 阿里开放平台返回的时间格式 直接用 `yyyyMMddHHmmssSSSZ` 是可以解析成功的 但是FastJSON这里没有做处理</body>
		<created>2018-12-29 09:22:25</created>
		<closed>2019-01-20 12:27:18</closed>
	</bug>
	<bug>
		<id>2210</id>
		<title>org.hibernate.TransientObjectException: Proxy [***] is detached</title>
		<body>a Entity instance that select with hibernate from db, but it's a HibernateProxy ```java import javax.persistence.Entity; import javax.persistence.ManyToOne; import org.hibernate.annotations.DynamicUpdate; import lombok.Getter; import lombok.Setter;  @Getter @Setter @Entity @DynamicUpdate public class DemoEntity {   @Id   private Long id;   private Date createTime; } ``` --- ```text org.hibernate.TransientObjectException: Proxy [***] is detached (i.e, session is null). The read-only/modifiable setting is only accessible when the proxy is associated with an open session.     at org.hibernate.proxy.AbstractLazyInitializer.errorIfReadOnlySettingNotAvailable(AbstractLazyInitializer.java:343) ~[hibernate-core-5.3.6.Final.jar:5.3.6.Final]     at org.hibernate.proxy.AbstractLazyInitializer.isReadOnly(AbstractLazyInitializer.java:356) ~[hibernate-core-5.3.6.Final.jar:5.3.6.Final]     at com.alibaba.fastjson.serializer.ASMSerializer_3_ByteBuddyInterceptor.write(Unknown Source) ~[?:?]     at com.alibaba.fastjson.serializer.JSONSerializer.writeWithFieldName(JSONSerializer.java:310) ~[fastjson-1.2.54.jar:?]     at com.alibaba.fastjson.serializer.ASMSerializer_2_User$HibernateProxy$L6fu5lwn.write(Unknown Source) ~[?:?]     at com.alibaba.fastjson.serializer.JSONSerializer.writeWithFieldName(JSONSerializer.java:310) ~[fastjson-1.2.54.jar:?]     at com.alibaba.fastjson.serializer.ASMSerializer_1_Follow.write(Unknown Source) ~[?:?]     at com.alibaba.fastjson.serializer.JSONSerializer.write(JSONSerializer.java:281) ~[fastjson-1.2.54.jar:?]     at com.alibaba.fastjson.JSON.toJSONString(JSON.java:676) ~[fastjson-1.2.54.jar:?]     at com.alibaba.fastjson.JSON.toJSONString(JSON.java:614) ~[fastjson-1.2.54.jar:?]     at com.alibaba.fastjson.JSON.toJSONString(JSON.java:579) ~[fastjson-1.2.54.jar:?]     at *** ``` 使用jackson 2.9.4如下： ```json {     "updateTime": 1545586755082,     "createTime": 1545586755082,     "id": 13,     "user": {         "updateTime": 1545811281536,         "createTime": 1545297317167,         "id": 391365082,         "hibernateLazyInitializer": {}     },     "attr": 2 } ```</body>
		<created>2018-12-26 17:49:46</created>
		<closed>2019-01-20 12:29:38</closed>
	</bug>
	<bug>
		<id>2206</id>
		<title>LocalDateTime反序列化时没有使用配置的时间格式</title>
		<body>例如自定义时间格式 `fastJsonConfig.setDateFormat("yyyyMMddHHmmss");` 在Jdk8DateCodec类的parseDateTime方法中在瞎猜格式，没有使用这个自定义格式进行format。</body>
		<created>2018-12-25 07:26:29</created>
		<closed>2019-01-20 13:29:16</closed>
	</bug>
	<bug>
		<id>2189</id>
		<title>jsonpath 1.2.54解析有问题</title>
		<body>例如：[{"id":"1","name":"a"},{"id":"2","name":"b"}]执行$.*[?(@.name=='b')].id结果是 [{"id":"2","name":"b"}]而不是2</body>
		<created>2018-12-14 07:32:39</created>
		<closed>2019-04-11 14:58:27</closed>
	</bug>
	<bug>
		<id>2165</id>
		<title>使用JSON.parseObject后发现，字符串“9295260120”变为 705325528. Jackson会报数字溢出。</title>
		<body>#缘起  使用JSON.parseObject后发现，字符串“9295260120”变为 705325528 `             &lt;dependency&gt;                 &lt;groupId&gt;com.alibaba&lt;/groupId&gt;                 &lt;artifactId&gt;fastjson&lt;/artifactId&gt;                 &lt;version&gt;1.2.54&lt;/version&gt;             &lt;/dependency&gt; `  #结论 经过DEBUG后发现：关键在929526012*10后，溢出了，整数最大21亿多：2,147,483,647  按理fastjson应该抛出异常才对，对比Jackson发现没这个问题。暂时先修改model class，改为Long类型。  # 详细debug分析过程：  ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/1134d374944a752660a604a1acfcab2a.png)  1、 ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/1a029d0b282d5e1c0fa3b5cf5404f44d.png)  2、 ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/bf7dba42638aa778f1ff0420c5c2dc2f.png)   。。。。   3、 ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/1a7d80b79d7678b8b34f6b922ef8a24d.png) ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/3a842a8218a81fc9e7a216be4068e868.png) 4、 ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/2f2bd9d88d65024248d50a9843bb50cf.png)  #关键在9295260120*10后，溢出了，整数最大21亿多：2,147,483,647 ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/2deec6a5ac806b465ca137b28bdd8ae7.png)  #Jackson会报溢出错误： ![image.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/d5cd933dfac103885879731c2ed563d0.png)  </body>
		<created>2018-12-05 07:50:00</created>
		<closed>2019-01-20 12:28:14</closed>
	</bug>
	<bug>
		<id>2157</id>
		<title>java.math.BigInteger 在使用 BrowserCompatible 时无效，没有转换成String</title>
		<body>java.math.BigInteger 在使用 BrowserCompatible 时无效，没有转换成String   ```java Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;(); map.put("id1", 9223370018640066466L); map.put("id2", new BigInteger("9223370018640066466")); System.out.println(JSON.toJSONString(map, SerializerFeature.BrowserCompatible)); ```  结果 ```java {"id1":"9223370018640066466","id2":9223370018640066466} ```  </body>
		<created>2018-11-28 14:49:43</created>
		<closed>2018-11-30 05:56:02</closed>
	</bug>
	<bug>
		<id>2156</id>
		<title>序列化时对java.sql.Date和java.util.Date应用不同的DateFormat？</title>
		<body>如题，希望默认序列化java.sql.Date为yyyy-MM-dd，而java.util.Date为yyyy-MM-dd HH:mm:ss。能支持吗？如何设置？如果用FastJsonConfig会两者都影响吧？</body>
		<created>2018-11-28 09:56:25</created>
		<closed>2019-04-11 14:59:02</closed>
	</bug>
	<bug>
		<id>2130</id>
		<title>Float 转换错误</title>
		<body>目前遇到这么一个问题：在对象中存在Float类型字段，在调用JSON.parseObject()反序列化时，会出现解析异常的问题。 eg：  传入json字符串为：{“score”:0.000099369485}，（没有使用科学计数法表示时）  在解析完之后score值会变为：-0.1366129   查看相关源码发现可能是在Float类型转换时，小数位比较多情况，例如：0.000099369485，会导致power溢出。 ![json](https://user-images.githubusercontent.com/44799742/48051664-b62b1200-e1e0-11e8-80b6-1bf03764c46e.PNG)</body>
		<created>2018-11-06 11:03:22</created>
		<closed>2018-11-18 09:53:01</closed>
	</bug>
	<bug>
		<id>1988</id>
		<title>JSONPath.contains()不支持中文key?</title>
		<body>fastjson版本1.2.33   在使用fastjson判断json字符串某个节点是否存在时，JSONPath.contains()似乎不支持中文key，或者需要做特殊设置？ 感谢。  `$.product.features.规格` ，这种方式会报错，错误如下：  `com.alibaba.fastjson.JSONPathException: illeal jsonpath syntax. $.product.features.规格`  `$.product.features.specification` ，这种方式就没问题。  @wenshao </body>
		<created>2018-08-01 05:13:11</created>
		<closed>2018-08-05 18:28:30</closed>
	</bug>
	<bug>
		<id>1987</id>
		<title>LocalDateTime包含纳秒,反序列化失败</title>
		<body>```java public class JsonExample {      private LocalDateTime testLocalDateTime;      public LocalDateTime getTestLocalDateTime() {         return testLocalDateTime;     }      public void setTestLocalDateTime(LocalDateTime testLocalDateTime) {         this.testLocalDateTime = testLocalDateTime;     } }      public static void main(String[] args) { //        JSON.DEFFAULT_DATE_FORMAT = "yyyy-MM-dd HH:mm:ss:SSS";          JsonExample example = new JsonExample();          //test1 正确执行, test2, test3 执行出错 com.alibaba.fastjson.JSONException: can not cast to : java.time.LocalDateTime         example.setTestLocalDateTime(LocalDateTime.now());          //纳秒数设置为0 ,test1,test2,test3 全部正确执行         //example.setTestLocalDateTime(LocalDateTime.now().withNano(0));         String text = JSON.toJSONString(example, SerializerFeature.PrettyFormat);         System.out.println(text);          //test1, 全部可以正常执行         JsonExample example1 = JSON.parseObject(text, JsonExample.class);         System.out.println(JSON.toJSONString(example1));          //test2  纳秒数为0, 可以正常执行, 不为0则报错         JsonExample example2 = JSONObject.parseObject(text).toJavaObject(JsonExample.class);         System.out.println(JSON.toJSONString(example2));          //test3 纳秒数为0, 可以正常执行, 不为0则报错         JsonExample example3 = JSON.parseObject(text).toJavaObject(JsonExample.class);         System.out.println(JSON.toJSONString(example3));     } ``` fastjson :1.2.47   错误信息:   Exception in thread "main" com.alibaba.fastjson.JSONException: can not cast to : java.time.LocalDateTime at com.alibaba.fastjson.util.TypeUtils.castToJavaBean(TypeUtils.java:1036) at com.alibaba.fastjson.util.TypeUtils.cast(TypeUtils.java:691) at com.alibaba.fastjson.JSON.toJavaObject(JSON.java:1004) at Main.main(Main.java:27) Caused by: com.alibaba.fastjson.JSONException: can not cast to : java.time.LocalDateTime at com.alibaba.fastjson.util.TypeUtils.cast(TypeUtils.java:803) at com.alibaba.fastjson.util.TypeUtils.cast(TypeUtils.java:846) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.createInstance(JavaBeanDeserializer.java:1159) at com.alibaba.fastjson.util.TypeUtils.castToJavaBean(TypeUtils.java:1034) ... 3 more</body>
		<created>2018-08-01 01:40:19</created>
		<closed>2018-08-05 18:28:19</closed>
	</bug>
	<bug>
		<id>1982</id>
		<title>SerializerFeature.WriteBigDecimalAsPlain not working</title>
		<body>The problem dose exist or am I using the wrong way?  fastJson version: 1.2.29 java version: 1.8.0_172 ```     /**      * @since 1.2.16      */     WriteBigDecimalAsPlain, ``` ```java public class BigDecimalBean {     private String type;     private BigDecimal value;      public String getType() {         return type;     }      public void setType(String type) {         this.type = type;     }      public BigDecimal getValue() {         return value;     }      public void setValue(BigDecimal value) {         this.value = value;     }      public static void main(String[] args) throws JsonProcessingException {         BigDecimalBean bean = new BigDecimalBean();         bean.setType("bigDecimal");         bean.setValue(new BigDecimal("0.0000000001"));         ObjectMapper objectMapper = new ObjectMapper();         System.out.println(objectMapper.writeValueAsString(bean));         objectMapper.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true);         System.out.println(objectMapper.writeValueAsString(bean));         System.out.println(JSON.toJSONString(bean));         System.out.println(JSON.toJSONString(bean, SerializerFeature.WriteBigDecimalAsPlain));     } } ``` output： ``` {"type":"bigDecimal","value":1E-10} {"type":"bigDecimal","value":0.0000000001} {"type":"bigDecimal","value":1E-10} {"type":"bigDecimal","value":1E-10} ```</body>
		<created>2018-07-30 07:53:40</created>
		<closed>2018-08-05 18:28:24</closed>
	</bug>
	<bug>
		<id>1962</id>
		<title>autoType is not support. org.springframework.security.oauth2.common.DefaultOAuth2AccessToken</title>
		<body>保存jwt的token到redis中，报以下错误，尝试了开启autotype，还是无解，麻烦大家帮看一下。 error:autoType is not support. org.springframework.security.oauth2.common.DefaultOAuth2AccessToken RedisCodec: ```java  @Bean     public RedisCodec&lt;String, Object&gt; redisCodec() {         FastJsonCodec fastJsonCodec=new FastJsonCodec&lt;&gt;(Object.class);         // 全局开启AutoType，不建议使用 //         ParserConfig.getGlobalInstance().setAutoTypeSupport(true);         // 建议使用这种方式，小范围指定白名单         ParserConfig.getGlobalInstance().addAccept("org.springframework.security.oauth2.common.");          return fastJsonCodec;     } ``` FastJsonCodec : ```java  @Override     public T decodeValue(ByteBuffer bytes) {         byte[] bytesArray = new byte[bytes.remaining()];         bytes.get(bytesArray);         if (bytesArray == null || bytesArray.length &lt;= 0) {             return null;         }else{             try {                 String str = new String(bytesArray,  IOUtils.UTF8);                 return JSON.parseObject(str, clazz);             } catch (Exception e) {                 log.error("decodeValue error:{}",e.getMessage());                 return null;             }         }      }   @Override     public ByteBuffer encodeValue(T t) {         if (t == null) {             return ByteBuffer.wrap(new byte[0]);         }else{             try {                 return ByteBuffer.wrap(JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(IOUtils.UTF8));             } catch (Exception e) {                 throw new SerializationException("Could not serialize: " + e.getMessage(), e);             }         }      }  ```</body>
		<created>2018-07-15 05:57:32</created>
		<closed>2018-08-05 18:28:14</closed>
	</bug>
	<bug>
		<id>1945</id>
		<title>Class[] 在Map之后会导致反序列化失败，json语法错误</title>
		<body>当一个类中有Map和Class[]时，整个类会反序列化失败。 ``` java static class B implements Serializable { public Class[] clazz; public Map aInstance; }  public static void main(String[] args) { B b = new B(); b.clazz = new Class[]{String.class}; b.aInstance = new HashMap(); b.aInstance.put("test", "test"); String s = JSON.toJSONString(b, WriteClassName); B a1 = JSON.parseObject(s, B.class); } ```  异常信息 ``` Exception in thread "main" com.alibaba.fastjson.JSONException: syntax error, expect ,, actual string at com.alibaba.fastjson.parser.DefaultJSONParser.accept(DefaultJSONParser.java:1458) at com.alibaba.fastjson.serializer.MiscCodec.deserialze(MiscCodec.java:224) at com.alibaba.fastjson.parser.DefaultJSONParser.parseArray(DefaultJSONParser.java:747) at com.alibaba.fastjson.serializer.ObjectArrayCodec.deserialze(ObjectArrayCodec.java:183) at com.alibaba.fastjson.parser.deserializer.DefaultFieldDeserializer.parseField(DefaultFieldDeserializer.java:86) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.parseField(JavaBeanDeserializer.java:1078) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:773) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:271) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:267) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:661) at com.alibaba.fastjson.JSON.parseObject(JSON.java:365) at com.alibaba.fastjson.JSON.parseObject(JSON.java:269) at com.alibaba.fastjson.JSON.parseObject(JSON.java:488) at Test.main(Test.java:21) ``` 测试版本是1.2.47</body>
		<created>2018-07-05 02:53:42</created>
		<closed>2018-08-05 18:28:09</closed>
	</bug>
	<bug>
		<id>1944</id>
		<title>反序列化float精度超出会出现问题</title>
		<body>在反序列化的时候，如果数据类型是一个float类型，而对应的值超过了float类型很多的话，反序列化会出现很奇怪的数字。 代码如下： ```     public static void main(String[] args) {         String json="{\"num\":90.82195113}";         Num num= JSONObject.parseObject(json,Num.class);         System.out.println(num.getNum());     }       public static class Num {         private float num;          public float getNum() {             return num;         }          public void setNum(float num) {             this.num = num;         }     } ``` 输出结果如下： ``` 4.922605 ``` </body>
		<created>2018-07-04 11:40:46</created>
		<closed>2018-08-05 18:28:50</closed>
	</bug>
	<bug>
		<id>1941</id>
		<title>1.2.47 当@JSONType 中指定了typeKey, 反序列化时会丢失此typeKey之前的所有字段</title>
		<body>```java @JSONType(seeAlso = {FloorV2.class}, typeKey = "type") public interface Area { }  @JSONType(typeName = "floorV2") public static class FloorV2 implements Area {     public String type;     public String templateId;     public String name; }  String json = "{\"type\":\"floorV2\",\"templateId\":\"x123\",\"name\":\"floorname2\"}"; Area  a=JSON.parseObject(json,Area.class); System.out.println("name&gt;&gt;&gt; " + a.name); ``` 若json为 "{\"type\":\"floorV2\",\"templateId\":\"x123\",\"name\":\"floorname2\"}"时,反序列化完全正常  若json为"{\"name\":\"floorname2\",\"type\":\"floorV2\",\"templateId\":\"x123\"}";反序列化后,name字段为null   找到个类似的问题 #291   若我在FloorV2类中 设置@JSONType(... orders={"type","name","templateId"}) 或 设置type字段@JSONField(ordinal = -1) 想在反序列化的时候把type字段放在首位, 但是报如下错误: ```java com.alibaba.fastjson.JSONException at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:665) at com.alibaba.fastjson.JSON.parseObject(JSON.java:365) at com.alibaba.fastjson.JSON.parseObject(JSON.java:269) at com.alibaba.fastjson.JSON.parseObject(JSON.java:488) at com.mytest.jsontestMethod Caused by: java.lang.NullPointerException at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:722) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:271) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:267) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:661) ... 38 more ``` </body>
		<created>2018-07-03 07:19:46</created>
		<closed>2019-03-24 18:06:06</closed>
	</bug>
	<bug>
		<id>1939</id>
		<title>序列化ElementNSImpl时导致StackOverflow</title>
		<body>fastjson version: 1.2.46 java version: 1.7.0_40  在com.sun.org.apache.xerces.internal.dom.ElementNSImpl中包含多个互相引用, 如ownerNode, previousSibling等; 对于同一个对象, 直接使用JSON.toJSON(dto)将会抛出StackOverflowError, 使用JSON.toJSONString(dto) 则有一定概率抛出;  是否可以不使用自定义序列化, 来改变此处的行为?  `其他json库的做法: jackson: 将整个ElementNSImpl转化为字符串 `</body>
		<created>2018-07-03 01:40:39</created>
		<closed>2018-08-05 18:28:55</closed>
	</bug>
	<bug>
		<id>1903</id>
		<title>全接口对象@Transient失效</title>
		<body>一个全接口对象, 通过代理生成的, 在接口中只声明了get, set方法, 没有字段申明.   在get上添加@Transient, 会将这个字段序列出来.  原因是FieldInfo中强制判断了必须要有field才会判断是否是fieldTransient  fastjson/src/main/java/com/alibaba/fastjson/util/FieldInfo.java   </body>
		<created>2018-06-13 06:52:04</created>
		<closed>2019-12-13 08:13:42</closed>
	</bug>
	<bug>
		<id>1902</id>
		<title>JSONPath后模糊匹配bug</title>
		<body>`JSONPath.read("{\"table\":\"_order_base\"}", "[table LIKE 'order_base%']");` table字段前面有_，LIKE表达式值前面没有_，期望结果不匹配，实际匹配。 看源码觉得JSONPath 1079行逻辑有问题。</body>
		<created>2018-06-12 07:17:47</created>
		<closed>2018-08-05 18:29:08</closed>
	</bug>
	<bug>
		<id>1901</id>
		<title>日期解析问题</title>
		<body>我想要解析带有“Thu Mar 22 08:58:37 +0000 2018”这种Date输出格式的日期属性的类，但是解析异常，我配置的属性注解如下：      @JSONField(format = "EEE MMM dd HH:mm:ss zzz yyyy")     private Date time;  这么做不能解析成功，但我试着用这种格式生成日期json，结果是：“星期二 六月 12 13:04:10 +0000 2018”  为什么会是这样，fastjson现在支持这种格式的解析吗</body>
		<created>2018-06-12 05:51:53</created>
		<closed>2018-08-05 18:28:02</closed>
	</bug>
	<bug>
		<id>1892</id>
		<title>LocalDateTime序列化问题</title>
		<body>![image](https://user-images.githubusercontent.com/6291759/40912231-8c4410ae-6823-11e8-8e51-52b5835fc929.png)  如图，同样是LocalDateTime，值的不同会导致序列化结果不一致</body>
		<created>2018-06-04 10:16:20</created>
		<closed>2018-08-05 18:29:13</closed>
	</bug>
	<bug>
		<id>1886</id>
		<title>kotlin data class 使用1.2.47 出现create instance error</title>
		<body>kotlin data class 使用1.2.47 出现create instance error</body>
		<created>2018-05-31 11:02:34</created>
		<closed>2018-08-05 18:29:18</closed>
	</bug>
	<bug>
		<id>1878</id>
		<title>fastjson夏令时期间Date转换导致时区错误问题</title>
		<body>我们发现在使用fastjson(包括最版版本的fastjson)的方法: JSON.toJSONString(date, SerializerFeature.UseISO8601DateFormat) 做Date-&gt;String的转换时没有考虑夏令时, 所以会导致在洛杉矶时区中在夏令时期间做此转换会不符合业务预期.  (1)fastjson获取毫秒偏移的方法为：calendar.getTimeZone().getRawOffset()，而getRawOffset()是不考虑夏令时。  (2)javax中的原生方法获取毫秒偏移方法为：calendar.getTimeZone().getOffset(long date)，getOffset(long date)方法会考虑夏令时。  具体可以见之前转的邮件"fastjson夏令时期间Date转换导致时区错误问题分析"</body>
		<created>2018-05-28 09:07:48</created>
		<closed>2018-08-05 18:29:23</closed>
	</bug>
	<bug>
		<id>1856</id>
		<title>Labels.excludes预期效果不对</title>
		<body> ``` org.junit.ComparisonFailure:  Expected :{"id":123,"info":"fofo","name":"wenshao"} Actual   :{"info":"fofo"} ```  想排除掉 “AuditIdEntity”  的字段，但是直接吧 “LogicDeleteEntity” 的字段也排除掉了，我的用法不对吗？测试代码如下  ```java  @Test     public void test_excludes() throws Exception {         VO vo = new VO();         vo.setId(123);         vo.setName("wenshao");         vo.setPassword("ooxxx");         vo.setInfo("fofo");          String text = JSON.toJSONString(vo, Labels.excludes("AuditIdEntity"));         Assert.assertEquals("{\"id\":123,\"info\":\"fofo\",\"name\":\"wenshao\"}", text);     }      public static class VO {          private int    id;         private String name;         private String password;         private String info;          @JSONField(label = "LogicDeleteEntity")         public int getId() {             return id;         }          public void setId(int id) {             this.id = id;         }          @JSONField(label = "LogicDeleteEntity")         public String getName() {             return name;         }          public void setName(String name) {             this.name = name;         }          @JSONField(label = "AuditIdEntity")         public String getPassword() {             return password;         }          public void setPassword(String password) {             this.password = password;         }          public String getInfo() {             return info;         }          public void setInfo(String info) {             this.info = info;         }      } ```</body>
		<created>2018-05-18 07:03:29</created>
		<closed>2018-08-05 18:29:02</closed>
	</bug>
	<bug>
		<id>1841</id>
		<title>反序列化英文格式时间异常</title>
		<body>如果采用标准英文时间格式会提示 以下异常 `Caused by: java.lang.NumberFormatException: For input string: "Wed May 09 16:55:00 CST 2018" `</body>
		<created>2018-05-10 03:59:25</created>
		<closed>2018-08-05 18:27:56</closed>
	</bug>
	<bug>
		<id>1839</id>
		<title>JsonPath支持Map条件筛选对象</title>
		<body>jsonpath直接支持Map条件筛选  如有以下对象，希望筛选出score&gt;0.7的的对象列表，用jsonPath编写时发现不能支持，目前只支持List模式，是否可直接支持Map？ ```sql import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.JSONPath; def jsonStr =""" { "risk_sexy_trade_stream_plus": { "score": 0 }, "chemical_medicine_stream_plus": { "score": 0 }, "gambling_trade_stream_plus": { "score": 0 }, "politics_stream_plus": { "score": 0.89513221556685012 }, "risk_tool_gun_stream_plus": { "score": 0 }, "sex_model_stream_plus": { "score": 0.7237896928683851 }, "risk_tool_cheat_stream_plus": { "score": 0 }, "risk_tool_certif_stream_plus": { "score": 0 }, "gamble_model_stream_plus": { "score": 0.3453003960431523 }, "risk_tool_vpn_stream_plus": { "score": 0 }, "vpndetect_stream_plus": { "score": 0.3467174233072834 } } """; ```</body>
		<created>2018-05-09 14:41:58</created>
		<closed>2018-08-05 18:27:51</closed>
	</bug>
	<bug>
		<id>1835</id>
		<title>versions difference between 1.2.5 and lastest</title>
		<body>There is a running difference in SerializerFeature:  ```java public static final int WRITE_MAP_NULL_FEATURES             = WriteMapNullValue.getMask()             | WriteNullBooleanAsFalse.getMask()             | WriteNullListAsEmpty.getMask()             | WriteNullNumberAsZero.getMask()             | WriteNullStringAsEmpty.getMask()             ; ```  The lastest version will take WriteMapNullValue, WriteNullBooleanAsFalse, WriteNullListAsEmpty, WriteNullNumberAsZero, WriteNullStringAsEmpty as **WriteMapNullValue** while old version take SIMPLE WriteMapNullValue.  This will result different output when we set WriteNullStringAsEmpty with no WriteMapNullValue setted. Nulled fields will be skipped in old versions but they will be "null" in newer versions.  Does it make sense?</body>
		<created>2018-05-08 10:09:08</created>
		<closed>2018-08-05 18:27:46</closed>
	</bug>
	<bug>
		<id>1834</id>
		<title>fastjson解析json字符串到java对象，当存在通配符继承Comparable时报堆栈溢出。</title>
		<body>fastjson 版本，从1.2.35到最新1.2.46均试过均存在一下问题； jdk版本：和jdk版本无关  问题描述： ```java public class FastJsonTest {      public static void main(String[] args) {         IndexQuery_Number query_number = new IndexQuery_Number();         IndexQuery_Comparable query_comparable = new IndexQuery_Comparable();         List&lt;Integer&gt; keys = Arrays.asList(1234);         query_number.setKeys(keys);         query_comparable.setKeys(keys);          try{             System.out.println("======= query with number =======");             String json1 = JSON.toJSONString(query_number);             System.out.println(json1);             IndexQuery_Number queryNumber = JSON.parseObject(json1, new TypeReference&lt;IndexQuery_Number&gt;(){});             System.out.println(queryNumber);              System.out.println("\n======= query with comparable =======");             String json2 = JSON.toJSONString(query_comparable);             System.out.println(json2);             IndexQuery_Comparable queryComparable = JSON.parseObject(json2, new TypeReference&lt;IndexQuery_Comparable&gt;(){});             System.out.println(queryComparable);          }catch (Throwable e){             e.printStackTrace();         }     }      static class IndexQuery_Comparable{         List&lt;? extends Comparable&gt; keys;          public List&lt;? extends Comparable&gt; getKeys() {             return keys;         }          public void setKeys(List&lt;? extends Comparable&gt; keys) {             this.keys = keys;         }          @Override         public String toString() {             return "IndexQuery{" +                     "keys=" + keys +                     '}';         }     }      static class IndexQuery_Number{         List&lt;? extends Number&gt; keys;          public List&lt;? extends Number&gt; getKeys() {             return keys;         }          public void setKeys(List&lt;? extends Number&gt; keys) {             this.keys = keys;         }          @Override         public String toString() {             return "IndexQuery{" +                     "keys=" + keys +                     '}';         }     }  } ``` 问题现象： 通配符继承Comparable会报堆栈溢出，通配符继承Number则完成正常解析。错误结果输入如下： ======= query with number ======= {"keys":[1234]} IndexQuery{keys=[1234]}  ======= query with comparable ======= {"keys":[1234]} com.alibaba.fastjson.JSONException at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:665) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:633) at com.alibaba.fastjson.parser.deserializer.JavaObjectDeserializer.deserialze(JavaObjectDeserializer.java:42) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:661) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:633) at com.alibaba.fastjson.parser.deserializer.JavaObjectDeserializer.deserialze(JavaObjectDeserializer.java:42) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:661) ……………………………………………… ……………………………………………… at com.alibaba.fastjson.parser.deserializer.JavaObjectDeserializer.deserialze(JavaObjectDeserializer.java:42) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:661) Caused by: java.lang.StackOverflowError at java.lang.Exception.&lt;init&gt;(Exception.java:84) at java.lang.RuntimeException.&lt;init&gt;(RuntimeException.java:80) at com.alibaba.fastjson.JSONException.&lt;init&gt;(JSONException.java:33) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:665) </body>
		<created>2018-05-08 09:45:37</created>
		<closed>2018-08-05 18:27:40</closed>
	</bug>
	<bug>
		<id>1833</id>
		<title>FastJson 在解析 &lt;? extends Comparable&gt;  泛型时报栈溢出的错误</title>
		<body>fastjson版本是1.2.29在使用通配符&lt;? extends Comparable&gt; 进行解析时汇报栈溢出的错误 数据格式如图 ![image](https://user-images.githubusercontent.com/12388190/39750219-417a3054-52e7-11e8-917c-e6d45e07d1ba.png) 错误异常如图 ![image](https://user-images.githubusercontent.com/12388190/39750245-5441457e-52e7-11e8-9a4b-1b3da3f34da2.png)  但是如果使用 &lt; ? extends Number &gt;  或 &lt; ? &gt;      时则没有问题 </body>
		<created>2018-05-08 09:45:28</created>
		<closed>2018-08-05 18:27:31</closed>
	</bug>
	<bug>
		<id>1821</id>
		<title>当Base64字符串中的斜杠`/`被转义为`\/`后，解析为`byte[]`有问题</title>
		<body>fastjson-1.2.47，当Base64字符串中的斜杠`/`被转义为`\/`后，解析为`byte[]`有问题。  ```java @JSONType public class TestEntity { @JSONField(name="type") public int type;  @JSONField(name="data") public byte[] data; } ``` 如下调用： ```java String j1 = "{\"type\":800,\"data\":\"HuYgMIxwfqdtvOJNv6kK025g5fh3yFHI2kaByO7udKk6FOBC3PGRWkGfwV0\\/vWQW6roN5ftKDHFZ3PWl0715OYue0rZj\\/VwrNsMvIL4MqTUNBBUGFU9SgZu87ss7RqmyijH6\\/sM968cK1Dv5U7Rrw79idl\\/hW8SILLn1YXvUa60=\"}"; try { JSONObject y1 = JSON.parseObject(j1); Log.e(TAG, "y1=" + y1);  TestEntity y2 = y1.toJavaObject(TestEntity.class); Log.e(TAG, "y2=" + JSON.toJSONString(y2));  TestEntity y3 = JSON.parseObject(j1, TestEntity.class); Log.e(TAG, "y3=" + JSON.toJSONString(y3)); } catch (Exception e) { // TODO: handle exception Log.e(TAG, "xx", e); } ``` 结果： ``` 04-27 08:21:11.907: E/xx(14883): y1={"data":"HuYgMIxwfqdtvOJNv6kK025g5fh3yFHI2kaByO7udKk6FOBC3PGRWkGfwV0/vWQW6roN5ftKDHFZ3PWl0715OYue0rZj/VwrNsMvIL4MqTUNBBUGFU9SgZu87ss7RqmyijH6/sM968cK1Dv5U7Rrw79idl/hW8SILLn1YXvUa60=","type":800} 04-27 08:21:11.924: E/xx(14883): y2={"data":"HuYgMIxwfqdtvOJNv6kK025g5fh3yFHI2kaByO7udKk6FOBC3PGRWkGfwV0/vWQW6roN5ftKDHFZ3PWl0715OYue0rZj/VwrNsMvIL4MqTUNBBUGFU9SgZu87ss7RqmyijH6/sM968cK1Dv5U7Rrw79idl/hW8SILLn1YXvUa60=","type":800} 04-27 08:21:11.927: E/xx(14883): y3={"data":"HuYgMIxwfqdtvOJNv6kK025g5fh3yFHI2kaByO7udKk6FOBC3PGRWkGf/////vWQW6roN5ftKDHFZ3PWl0715OYue0rZ///VwrNsMvIL4MqTUNBBUGFU9SgZu87ss7Rqmyij////sM968cK1Dv5U7Rrw79id///hW8SILLn1YXvU","type":800} ```  其中y1和y2是正确的，而y3是错误的。</body>
		<created>2018-04-27 08:37:24</created>
		<closed>2019-09-04 00:29:15</closed>
	</bug>
	<bug>
		<id>1814</id>
		<title>kotlin存在内部类对象时转JSON字符串空指针问题</title>
		<body>` import com.alibaba.fastjson.JSONObject import com.fasterxml.jackson.databind.ObjectMapper  class SpendLog(id: String) {     var id: String? = id     var event: Event? = null     inner class Event internal constructor(var id: String)     init {         this.event = Event(id)     } } fun main(args: Array&lt;String&gt;) {     println(ObjectMapper().writeValueAsString(SpendLog("1")))     println(JSONObject.toJSONString(SpendLog("2"))) } ` 引用了一个内部类对象时，jackson能正常转换，结果为{"id":"1","event":{"id":"1"}}，fastjson报空指针异常，是否用法有误？ </body>
		<created>2018-04-20 08:12:39</created>
		<closed>2018-08-05 18:29:28</closed>
	</bug>
	<bug>
		<id>1785</id>
		<title>Caused by: com.alibaba.fastjson.JSONException: can not cast to Timestamp, value : 2006-8-9</title>
		<body>Use Fastjson 1.2.47 Caused by: com.alibaba.fastjson.JSONException: can not cast to Timestamp, value : 2006-8-9 at com.alibaba.fastjson.util.TypeUtils.castToSqlDate(TypeUtils.java:412) at com.alibaba.fastjson.util.TypeUtils.cast(TypeUtils.java:750) at com.bcss.poi.excel.utils.ExcelUtils.setProperty(ExcelUtils.java:1414) at com.bcss.poi.excel.utils.ExcelUtils.readRow(ExcelUtils.java:424)</body>
		<created>2018-04-01 04:22:41</created>
		<closed>2018-08-05 18:27:11</closed>
	</bug>
	<bug>
		<id>1780</id>
		<title>org.json.JSONObject 问题</title>
		<body>        org.json.JSONObject req = new org.json.JSONObject();         req.put("id", 1111);         req.put("name", "name11");         System.out.println(com.alibaba.fastjson.JSON.toJSONString(req)); // 输出"{}"  本来是用com.alibaba.fastjson.JSONObject，误用了org.json.JSONObject时发现这问题。</body>
		<created>2018-03-27 03:54:10</created>
		<closed>2019-12-03 07:18:34</closed>
	</bug>
	<bug>
		<id>1772</id>
		<title>关于Bean序列化与反序列化Map&lt;String,String&gt;中属性Date类型值为1970年前的问题能否优化？</title>
		<body>` Map&lt;String,String&gt; hash = JSONObject.parseObject(JSON.toJSONString(bean), new TypeReference&lt;Map&lt;String, String&gt;&gt;(){});` 方法可以将Bean序列化成Map&lt;String,String&gt;。  `JSONObject.toJavaObject((JSONObject)JSON.toJSON(hash),clazz);` 方法反序列化成Bean时，如果属性类型为Date值为1970年以前时间时，会报序列化失败。看了下是com.alibaba.fastjson.util.TypeUils类中castToDate方法第307行代码针对format的处理有些问题，不支持“--355132800000”字符串的处理。  建议307行判断条件改为： if(strVal.indexOf('-',1) != -1){  </body>
		<created>2018-03-21 14:50:57</created>
		<closed>2018-08-05 18:25:17</closed>
	</bug>
	<bug>
		<id>1769</id>
		<title>@JsonField解析Date变量，使用format=“yyyyMMddHHmmss”，解析字符串“420180319160440”为42070903200720</title>
		<body>是否可以提供选项，设置解析时使用的SimpleDateFormat的Lenient来严格按照format解析？ ```java @JSONType(orders = {"beginTime"}) public class QueryTaskResultReq {     @JSONField(format = "yyyyMMddHHmmss")     private Date beginTime; } public class Test3 {     public static void main(String[] args) throws ParseException     {         byte[] newby = "{\"beginTime\":\"420180319160440\"}".getBytes();         QueryTaskResultReq rsp3 = JSON.parseObject(newby, QueryTaskResultReq.class);         System.out.println(new String(JSON.toJSONBytes(rsp3)));     } } ``` 输出为{"beginTime":"42070903200720"}  </body>
		<created>2018-03-19 12:59:26</created>
		<closed>2018-08-05 18:29:43</closed>
	</bug>
	<bug>
		<id>1763</id>
		<title>多级泛型的里层无法正常解析</title>
		<body>class：BaseResult ``` public class BaseResult&lt;T&gt;  ``` class：InteractiveOrderMaterielQueryResult ```java public class InteractiveOrderMaterielQueryResult&lt;T extends InteractiveOrderMaterielModel&gt; extends BasePageQueryResult&lt;T&gt; ``` method： queryProcurementOrderList ```java BaseResult&lt;InteractiveProcurementOrderList&gt; queryProcurementOrderList(InteractiveOrderBatchQueryCloudParam param); ```  调用queryProcurementOrderList的返回结果调用JSON.parseObject() ，里层的InteractiveOrderMaterielModel无法正常解析，测试代码如下：  ```java String s = "{\"result\":{\"modelList\":[{\"sourceId\":\"81900002\",\"categoryNames\":[\"一级类目A\",\"二级类目A1\",\"三级类目a2\"],\"materielCode\":\"wanhuacaigou095\",\"categoryIds\":[10001158,10001159,10001161],\"systemName\":\"framework\",\"unitName\":\"个\",\"materielName\":\"wanhuacaigou095\",\"class\":\"com.alibaba.procurement.api.interactive.model.InteractiveOrderMaterielModel\",\"materielItemId\":\"10172\"},{\"sourceId\":\"81900002\",\"categoryNames\":[\"一级类目A\",\"二级类目A1\",\"三级类目a2\"],\"materielCode\":\"wanhuacaigou096\",\"categoryIds\":[10001158,10001159,10001161],\"systemName\":\"framework\",\"unitName\":\"个\",\"materielName\":\"wanhuacaigou096\",\"class\":\"com.alibaba.procurement.api.interactive.model.InteractiveOrderMaterielModel\",\"materielItemId\":\"10173\"},{\"sourceId\":\"81892012\",\"categoryNames\":[],\"materielCode\":\"80005351\",\"categoryIds\":[],\"systemName\":\"framework\",\"unitName\":\"PC\",\"materielName\":\"法兰 CL150 DN25 SO-RF HG20615(Ib) 20#\",\"class\":\"com.alibaba.procurement.api.interactive.model.InteractiveOrderMaterielModel\",\"materielItemId\":\"10167\"},{\"sourceId\":\"2062014\",\"categoryNames\":[],\"materielCode\":\"80005350\",\"categoryIds\":[],\"systemName\":\"framework\",\"unitName\":\"PC\",\"materielName\":\"法兰CL150DN200SO-RFHG2061520\",\"class\":\"com.alibaba.procurement.api.interactive.model.InteractiveOrderMaterielModel\",\"materielItemId\":\"10022\"},{\"sourceId\":\"2082007\",\"categoryNames\":[],\"materielCode\":\"xpommm114\",\"categoryIds\":[],\"systemName\":\"framework\",\"unitName\":\"1\",\"materielName\":\"xpommm114\",\"class\":\"com.alibaba.procurement.api.interactive.model.InteractiveOrderMaterielModel\",\"materielItemId\":\"10145\"},{\"sourceId\":\"2082007\",\"categoryNames\":[],\"materielCode\":\"xpommm115\",\"categoryIds\":[],\"systemName\":\"framework\",\"unitName\":\"个\",\"materielName\":\"xpommm115\",\"class\":\"com.alibaba.procurement.api.interactive.model.InteractiveOrderMaterielModel\",\"materielItemId\":\"10146\"},{\"sourceId\":\"2082007\",\"categoryNames\":[],\"materielCode\":\"xpommm109\",\"categoryIds\":[],\"systemName\":\"framework\",\"unitName\":\"个\",\"materielName\":\"xpommm109\",\"class\":\"com.alibaba.procurement.api.interactive.model.InteractiveOrderMaterielModel\",\"materielItemId\":\"10147\"}],\"totalCount\":52,\"class\":\"com.alibaba.procurement.api.interactive.result.InteractiveOrderMaterielQueryResult\"},\"class\":\"com.alibaba.procurement.api.base.result.BaseResult\",\"isSuccess\":true}";          Method method = null;         Method[] ms = ProcurementOrderInteractiveServiceForCloud.class.getMethods();         for(Method m : ms){             if(m.getName().equals("queryOrderMateriel")){                 method = m;             }         }         Type type = method.getGenericReturnType();         BaseResult&lt;InteractiveOrderMaterielQueryResult&gt; o = JSON.parseObject(s,  type); ``` ![123](https://user-images.githubusercontent.com/5425784/37339891-21b93d12-26f7-11e8-8c50-d6512c3297c9.png) </body>
		<created>2018-03-13 11:46:11</created>
		<closed>2018-03-15 11:14:14</closed>
	</bug>
	<bug>
		<id>1750</id>
		<title>fastjon_1.2.46  多次调用结果不一样  open-jdk-1.8.0_112.jdk</title>
		<body>实体类是如下（kotlin） ```kotlin class ProcessBO (){     lateinit var masterId: String     lateinit var processId: String     lateinit var taskId: String     lateinit var taskName: String        constructor(masterId: String, processId: String, taskId: String, taskName: String) : this() {         this.masterId = masterId         this.processId = processId         this.taskId = taskId         this.taskName = taskName     }      override fun toString(): String {         return JSON.toJSONString(this)     } } ``` 调用方法如下： ```kotlin fun main(args: Array&lt;String&gt;) {     val data = """         { "masterId": "1111111111111", "processId": "222222222222222", "taskId": "33333333333333", "taskName": "44444444444444" }         """     val result = JSON.parseObject(data, ProcessBO::class.javaObjectType)     println(result) } 执行结果（十次以内一定异常）： {"masterId":"1111111111111","processId":"222222222222222","taskId":"33333333333333","taskName":"44444444444444"}  {"masterId":"33333333333333","processId":"44444444444444","taskId":"222222222222222","taskName":"1111111111111"} ```  1.2.44也是这个问题 </body>
		<created>2018-03-02 05:33:53</created>
		<closed>2018-03-15 11:12:39</closed>
	</bug>
	<bug>
		<id>1723</id>
		<title>v1.2.40  反序列化float field，当field精度超过float的精度范围，结果出现负数</title>
		<body>```java // Bean 对象  public class User {     private float age;     public float getAge() {         return age;     }     public void setAge(float age) {         this.age = age;     }     @Override     public String toString() {         return "User{" +                 "age=" + age +                 '}';     } } ```  ```java // 反序列化代码 User user = JSON.parseObject("{\"age\":\"0.9390308260917664\"}", User.class);  System.out.println(user);  ```  结果： 期望结果是：**User{age=0.9390308}** 实际结果是：**User{age=-1.1075817}**</body>
		<created>2018-01-25 09:12:58</created>
		<closed>2018-03-15 11:12:34</closed>
	</bug>
	<bug>
		<id>1699</id>
		<title>FastJson升级到1.2.44报错</title>
		<body>原使用FastJson 1.2.7版本，使用上没有问题，但升级到1.2.44版本报错。 com.alibaba.fastjson.JSONException: syntax error, expect ,, actual string         at com.alibaba.fastjson.parser.DefaultJSONParser.accept(DefaultJSONParser.java:1451)         at com.alibaba.fastjson.serializer.MiscCodec.deserialze(MiscCodec.java:224)         at com.alibaba.fastjson.parser.deserializer.FastjsonASMDeserializer_17_RatingDetailATO.deserialze(Unknown Source)         at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:267)         at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:378)         at com.alibaba.fastjson.parser.DefaultJSONParser.parse(DefaultJSONParser.java:1349)         at com.alibaba.fastjson.parser.deserializer.JavaObjectDeserializer.deserialze(JavaObjectDeserializer.java:45)         at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:654)         at com.alibaba.fastjson.JSON.parseObject(JSON.java:365)         at com.alibaba.fastjson.JSON.parseObject(JSON.java:269)         at com.alibaba.fastjson.JSON.parseObject(JSON.java:488)     升级到1.2.7.sec01，并通过脚本方式开启autoType白名单运行正常。   </body>
		<created>2018-01-09 12:49:12</created>
		<closed>2018-01-23 02:00:22</closed>
	</bug>
	<bug>
		<id>1673</id>
		<title>在kotlin  使用TypeReference的fastjsonframework不能解析项目实体类</title>
		<body>java:  public class Test {      public static void  main() {         String jsonString = "[{\"ptId\":1,\"ptName\":\"KeMotion\"},{\"ptId\":2,\"ptName\":\"KePlast\"},{\"ptId\":3,\"ptName\":\"KeTop\"}]";         TypeReference type=new TypeReference&lt;List&lt;TestBean&gt;&gt;(){};         List&lt;TestBean&gt; list= JSONObject.parseObject(jsonString, type.getType());         for (TestBean testBean : list) {             System.out.println(testBean.ptName);         }     }     public static class  TestBean{        public String  ptId;         public  String ptName;     } }  运行没有问题   kotlin：1.2.0 版本 object Test {      fun main() {         val jsonString = "[{\"ptId\":1,\"ptName\":\"KeMotion\"},{\"ptId\":2,\"ptName\":\"KePlast\"},{\"ptId\":3,\"ptName\":\"KeTop\"}]"         val type = object : TypeReference&lt;List&lt;TestBean&gt;&gt;() {          }         val list = JSONObject.parseObject&lt;List&lt;TestBean&gt;&gt;(jsonString, type.type)         for (testBean in list) {             println(testBean.ptName)         }     }      class TestBean {         var ptId: String? = null         var ptName: String? = null     } } kotlin 解析：错误日志: fastjson: Caused by: java.lang.ClassCastException: com.alibaba.fastjson.JSONObject cannot be cast to com.keba.utils.Test$TestBean</body>
		<created>2017-12-23 02:19:36</created>
		<closed>2018-01-01 15:35:47</closed>
	</bug>
	<bug>
		<id>1665</id>
		<title>com.alibaba.fastjson.util.TypeUtils类cast对Collection是否支持？</title>
		<body>```java @SuppressWarnings({ "rawtypes", "unchecked" })     public static &lt;T&gt; T cast(Object obj, ParameterizedType type, ParserConfig mapping) {         Type rawTye = type.getRawType();          if (rawTye == Set.class || rawTye == HashSet.class //             || rawTye == TreeSet.class //             || rawTye == List.class //             || rawTye == ArrayList.class) {             Type itemType = type.getActualTypeArguments()[0];`  ``` 这里为什么不加入 || rawType == Collection.class   以支持Collection  还是说是个bug?</body>
		<created>2017-12-20 12:06:54</created>
		<closed>2017-12-25 12:25:48</closed>
	</bug>
	<bug>
		<id>1652</id>
		<title>建议ASMDeserializerFactory中一段代码 ASMDeserializerFactory.class.getPackage().getName();修改为ASMDeserializerFactory.class.getName(),因为在一些情况下会出现null</title>
		<body>例如：使用Mockito mock数据单元测试时，如果我们使用mockClassLoader类加载器时，mockClassLoader不会definePackages，导致getPackAge为null</body>
		<created>2017-12-14 11:28:00</created>
		<closed>2017-12-16 07:50:19</closed>
	</bug>
	<bug>
		<id>1651</id>
		<title>jsonpath length()报错</title>
		<body>$是一个json数组，使用$.length()报错，$.size()不报错，但是文档(https://github.com/alibaba/fastjson/wiki/JSONPath )中有length()的说明。 fastjson版本:1.2.42  com.alibaba.fastjson.JSONPathException: not support jsonpath : $.length() at com.alibaba.fastjson.JSONPath$JSONPathParser.readSegement(JSONPath.java:687) at com.alibaba.fastjson.JSONPath$JSONPathParser.explain(JSONPath.java:1290) at com.alibaba.fastjson.JSONPath.init(JSONPath.java:60) at com.alibaba.fastjson.JSONPath.eval(JSONPath.java:69) at com.alibaba.fastjson.JSONPath.eval(JSONPath.java:355) at com.szr.fastjson.test.FastJsonJunitTest.testJsonpath(FastJsonJunitTest.java:34) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)  </body>
		<created>2017-12-14 07:26:20</created>
		<closed>2017-12-16 07:51:09</closed>
	</bug>
	<bug>
		<id>1649</id>
		<title>@JSONType注解的serialzeFeatures属性无效</title>
		<body>``` @JSONType(serialzeFeatures = {SerializerFeature.WriteNullStringAsEmpty,SerializerFeature.WriteMapNullValue}) public class Apple {      // @JSONField(serialzeFeatures = {SerializerFeature.WriteNullStringAsEmpty, SerializerFeature.WriteMapNullValue})     private String color;     private String productCity;     private int size;      public String getColor() {         return color;     }      public Apple setColor(String color) {         this.color = color;         return this;     }      public int getSize() {         return size;     }      public Apple setSize(int size) {         this.size = size;         return this;     }      public String getProductCity() {         return productCity;     }      public Apple setProductCity(String productCity) {         this.productCity = productCity;         return this;     }      @Override     public String toString() {         return JSON.toJSONString(this);     }      public static void main(String[] args) {         System.out.println(JSON.toJSONString(new Apple()));     } } ``` 在类上加上@JSONType注解，注释掉字段color的注解，serialzeFeatures没生效。</body>
		<created>2017-12-14 06:47:20</created>
		<closed>2017-12-16 07:51:18</closed>
	</bug>
	<bug>
		<id>1647</id>
		<title>Failed to deserialize list property if property name is snake case</title>
		<body>fastjson version: 1.2.42  POJO ``` @Setter @Getter @Accessors(chain = true) @JSONType(naming = PropertyNamingStrategy.SnakeCase) public class Params {      private boolean withFields;      private List&lt;String&gt; verificationIds; } ```  Test Case ``` @org.junit.Test     public void test() {         Params params = new Params()                 .setVerificationIds(Arrays.asList(new String[]{"a", "b"}))                 .setWithFields(true);          String json = JSON.toJSONString(params);         log.debug(json);          params = JSON.parseObject(json, Params.class);         log.debug(JSON.toJSONString(params));     } ```  log output ```  - {"verification_ids":["a","b"],"with_fields":true}  - {"with_fields":true} ```  As the log shows, the property **verification_ids** is lost. I've figured out that if I change **verification_ids** to **verifications**(no camel) or annotate the property with `@JSONField(name = "verification_ids")` or change **List&lt;String&gt;** to **String[]**, then it works fine.</body>
		<created>2017-12-13 10:01:49</created>
		<closed>2017-12-16 07:50:56</closed>
	</bug>
	<bug>
		<id>1645</id>
		<title>反序列化后使用JSON对象获取JavaObject时，解析LocalDateTime发生错误</title>
		<body> fastjson版本: 1.2.39  测试类:  ```java @Data public class TestDateClass{     String name;     LocalDateTime testDateTime; } ```  反序列化代码: ```java     @Test     public void testEnum() {         String test = "{\"name\":\"test\",\"testDateTime\":\"2017-12-08 14:55:16\"}";          //success         logger.info(JSON.toJSONString(JSON.parseObject(test, TestDateClass.class), SerializerFeature.PrettyFormat));          //fail         logger.info(JSON.toJSONString(JSON.parseObject(test).toJavaObject(TestDateClass.class), SerializerFeature.PrettyFormat));     } ``` 结果: ```java 15:14:49.374 [main] INFO com.my.test.TestEnum - { "name":"test", "testDateTime":"2017-12-08 14:55:16" }  com.alibaba.fastjson.JSONException: can not cast to : java.time.LocalDateTime  at com.alibaba.fastjson.util.TypeUtils.castToJavaBean(TypeUtils.java:941) at com.alibaba.fastjson.util.TypeUtils.cast(TypeUtils.java:644) at com.alibaba.fastjson.JSON.toJavaObject(JSON.java:971) at com.netease.mail.service.TestEnum.testRole(TestEnum.java:209) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: com.alibaba.fastjson.JSONException: can not cast to : java.time.LocalDateTime at com.alibaba.fastjson.util.TypeUtils.cast(TypeUtils.java:745) at com.alibaba.fastjson.util.TypeUtils.cast(TypeUtils.java:788) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.createInstance(JavaBeanDeserializer.java:1153) at com.alibaba.fastjson.util.TypeUtils.castToJavaBean(TypeUtils.java:939) ... 25 more ```</body>
		<created>2017-12-13 07:22:04</created>
		<closed>2017-12-25 12:25:40</closed>
	</bug>
	<bug>
		<id>1644</id>
		<title>反序列化不支持java.sql.Time类型</title>
		<body>对象内有`java.sql.Time`类型字段时 反序列化会报错, 跟踪代码发现是`com/alibaba/fastjson/util/TypeUtils.java`类中没有对`java.sql.Time`的反序列进行支持.</body>
		<created>2017-12-13 07:17:27</created>
		<closed>2017-12-16 07:50:46</closed>
	</bug>
	<bug>
		<id>1636</id>
		<title>JSONCreator BUG</title>
		<body>如果使用@JSONField对一个字段设置了别名，调用标记@JSONCreator的构造函数时，无法初始化字段，只有**案三**是能正常反序列化的。  出错版本：version:1.2.41 之前使用：1.2.15，案一正常，只是不能使用其它的setter。  案一： ```java public class Item {     @JSONField(name="m")     private int modelId;      @JSONCreator     public Item(@JSONField(name="m") int modelId){         // 这里为零         this.modelId=modelId     } } ```  案二： ```java public class Item {     @JSONField     private int modelId;      @JSONCreator     public Item(@JSONField int modelId){         // 这里为零         this.modelId=modelId     } } ```  案三： ```java public class Item {     @JSONField     private int modelId;      @JSONCreator     public Item(@JSONField(modelId="modelId") int modelId){         // 这里终于正确了         this.modelId=modelId     } } ```  案四： ```java public class Item {     @JSONField(modelId="m")     private int modelId;      @JSONCreator     public Item(@JSONField(modelId="modelId") int modelId){         // 这里还是为零         this.modelId=modelId     } } ```</body>
		<created>2017-12-07 13:37:51</created>
		<closed>2017-12-14 02:24:17</closed>
	</bug>
	<bug>
		<id>1627</id>
		<title>JSONPath判断key值存在报错</title>
		<body>```java  String a = "{\"101a0.test-b\":\"tt\"}";         Object o = JSON.parse(a);         String s = "101a0.test-b";         System.out.println(JSONPath.contains(o, "$." + JsonUtil.escapeString(s))); ``` 上端代码应该打印出true，但是打印的是false，JsonUtil.escapeString()方法代码如下:  ```java public static String escapeString(String s) {         StringBuilder buf = new StringBuilder();          for(int i = 0; i &lt; s.length(); ++i) {             char c = s.charAt(i);             if((c &lt; 48 || c &gt; 57) &amp;&amp; (c &lt; 65 || c &gt; 90) &amp;&amp; (c &lt; 97 || c &gt; 122)) {                 buf.append("\\" + c);             } else {                 buf.append(c);             }         }          return buf.toString();     } ```</body>
		<created>2017-12-04 11:49:43</created>
		<closed>2017-12-14 02:24:57</closed>
	</bug>
	<bug>
		<id>1614</id>
		<title>util/FieldInfo.java 里 getInheritGenericType() 可疑的空指针解引用</title>
		<body>Hi,  我们的代码检查器 Pinpoint 报告了一处可疑的空指针解引用， https://github.com/alibaba/fastjson/blob/fcd2ae7723ddc84191cc9b90b453d58b30c02e2c/src/main/java/com/alibaba/fastjson/util/FieldInfo.java#L349-L378  349 行是否可能返回 false，导致 377 行使用 `class_gd` 时触发空指针解引用？  祝好， Sourcebrella Inc.</body>
		<created>2017-11-27 09:53:37</created>
		<closed>2017-12-14 02:23:20</closed>
	</bug>
	<bug>
		<id>1613</id>
		<title>parser/deserializer/ThrowableDeserializer.java 里 deserialze() 可疑的空指针解引用 </title>
		<body>Hi,  我们的代码检查器 Pinpoint 报告了一处可疑的空指针解引用， https://github.com/alibaba/fastjson/blob/fcd2ae7723ddc84191cc9b90b453d58b30c02e2c/src/main/java/com/alibaba/fastjson/parser/deserializer/ThrowableDeserializer.java#L131-L150  149 行的 `exBeanDeser` 变量是否有可能跳过全部初始化赋值（139 返回 false 的话） 导致维持 null 值，然后触发空指针解用？  这处是真的有潜在问题?，还是 139 行的检查是非必要？  祝好， Sourcebrella Inc.</body>
		<created>2017-11-27 09:43:35</created>
		<closed>2017-12-14 02:25:31</closed>
	</bug>
	<bug>
		<id>1611</id>
		<title>在Kotlin对JSONObject对象使用“toJavaObject”方法转为Pojo类时，当字段首字母为大写时报错</title>
		<body>Pojo ```kotlin data class Test(         @JSONField(name = "Name")         var name: String = "" ) ``` 当运行以下代码时报错 ```kotlin fun main(args: Array&lt;String&gt;) {     val pristineJson = "{\"data\":{\"lists\":[{\"Name\":\"Mark\"}]}}"     val list = JSONObject.parseObject(pristineJson).getJSONObject("data").getJSONArray("lists")     for (i in list.indices) {         var sss = list.getJSONObject(i)         val single: Test = sss.toJavaObject(Test::class.java)     } } ``` 当转换为字符串时就不会报错 ```kotlin fun main(args: Array&lt;String&gt;) {     val pristineJson = "{\"data\":{\"lists\":[{\"Name\":\"Mark\"}]}}"     val list = JSONObject.parseObject(pristineJson).getJSONObject("data").getJSONArray("lists")     for (i in list.indices) {         var sss = list.getJSONObject(i)         val single: Test = JSON.parseObject(sss.toJSONString(),Test::class.java)     } } ``` </body>
		<created>2017-11-26 07:32:00</created>
		<closed>2017-12-14 02:23:41</closed>
	</bug>
	<bug>
		<id>1603</id>
		<title>请支持集合类型反序列化报错，　java.lang.UnsupportedOperationException ,谢谢。</title>
		<body>在应用　GenericFastJsonRedisSerializer　实现shiro 的 session 序列化，在反序化过程中报异常，  fastjson 版本：　１.２.４１ 反序列化内容：　 ```json {   "@type": "org.apache.shiro.session.mgt.SimpleSession",   "attributeKeys": [     "shiroSavedRequest"   ],   "attributes": {     "@type": "java.util.HashMap",     "shiroSavedRequest": {       "@type": "org.apache.shiro.web.util.SavedRequest",       "method": "GET",       "requestURI": "/",       "requestUrl": "/"     }   },   "expired": false,   "host": "0:0:0:0:0:0:0:1",   "id": "04471851-7b22-4539-9d4b-ecc4e8423ce8",   "lastAccessTime": 1511430200586,   "startTimestamp": 1511430200586,   "timeout": 1800000,   "valid": true } ``` 异常：  java.lang.UnsupportedOperationException: null at java.util.AbstractCollection.add(AbstractCollection.java:262) at java.util.AbstractCollection.addAll(AbstractCollection.java:344) at com.alibaba.fastjson.parser.deserializer.FieldDeserializer.setValue(FieldDeserializer.java:92) at com.alibaba.fastjson.parser.deserializer.DefaultFieldDeserializer.parseField(DefaultFieldDeserializer.java:118) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:728) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:271) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:267) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:370) at com.alibaba.fastjson.parser.DefaultJSONParser.parse(DefaultJSONParser.java:1335) at com.alibaba.fastjson.parser.deserializer.JavaObjectDeserializer.deserialze(JavaObjectDeserializer.java:45) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:640) at com.alibaba.fastjson.JSON.parseObject(JSON.java:365) at com.alibaba.fastjson.JSON.parseObject(JSON.java:328) at com.alibaba.fastjson.support.spring.GenericFastJsonRedisSerializer.deserialize(GenericFastJsonRedisSerializer.java:37) </body>
		<created>2017-11-23 09:54:17</created>
		<closed>2017-12-14 02:23:54</closed>
	</bug>
	<bug>
		<id>1593</id>
		<title>default constructor not found in Kotlin</title>
		<body>I've got [this](https://github.com/alibaba/fastjson/wiki/Use-Fastjson-in-Kotlin)  ## Data Class  ```java data class Configuration(val signature: String, val last_update: Long, val plugins: List&lt;Plugins&gt;) ```  ## Try to serialize  ```java val configuration = JSON.parseObject(jsonString, Configuration::class.javaObjectType) ```  ## Exception  ``` com.alibaba.fastjson.JSONException: default constructor not found. class packagename.Configuration    at com.alibaba.fastjson.parser.JavaBeanInfo.build(JavaBeanInfo.java:496)    at com.alibaba.fastjson.parser.JavaBeanDeserializer.&lt;init&gt;(JavaBeanDeserializer.java:35)    at com.alibaba.fastjson.parser.ParserConfig.getDeserializer(ParserConfig.java:225)    at com.alibaba.fastjson.parser.ParserConfig.getDeserializer(ParserConfig.java:144)    at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:683)    at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:659)    at com.alibaba.fastjson.JSON.parseObject(JSON.java:212)    at com.alibaba.fastjson.JSON.parseObject(JSON.java:184)    at com.alibaba.fastjson.JSON.parseObject(JSON.java:143)    at com.alibaba.fastjson.JSON.parseObject(JSON.java:252)    at packagename.Worker.run(Worker.kt:195)    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:422)    at java.util.concurrent.FutureTask.run(FutureTask.java:237)    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)    at java.lang.Thread.run(Thread.java:841) ```  ## Fastjson Version  1.1.64.android</body>
		<created>2017-11-20 11:22:31</created>
		<closed>2019-07-08 09:54:10</closed>
	</bug>
	<bug>
		<id>1583</id>
		<title>Map.Entry 反序列化异常，</title>
		<body>如题目， 在序列化后，反序列化异常，异常信息如下  `Exception in thread "main" com.alibaba.fastjson.JSONException: expect string at com.alibaba.fastjson.serializer.MiscCodec.deserialze(MiscCodec.java:265) at com.alibaba.fastjson.parser.DefaultJSONParser.parseArray(DefaultJSONParser.java:712) at com.alibaba.fastjson.serializer.CollectionCodec.deserialze(CollectionCodec.java:120) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:626) at com.alibaba.fastjson.JSON.parseObject(JSON.java:348) at com.alibaba.fastjson.JSON.parseObject(JSON.java:316) at com.alibaba.fastjson.JSON.parseObject(JSON.java:230) at MapToJson.main(MapToJson.java:31)`  源代码如下： ```java Map&lt;String, List&lt;String&gt;&gt; totalMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; 2; j++) { list.add("list" + j); } totalMap.put("map" + i, list); } List&lt;Map.Entry&lt;String, List&lt;String&gt;&gt;&gt; mapList = new ArrayList&lt;&gt;(totalMap.entrySet()); List&lt;Map&lt;String, List&lt;String&gt;&gt;&gt; mapList1 = new ArrayList&lt;&gt;(); mapList1.add(totalMap); String jsonString = JSON.toJSONString(mapList1, SerializerFeature.DisableCircularReferenceDetect); System.out.println(jsonString); List&lt;Map.Entry&lt;String, List&lt;String&gt;&gt;&gt; parse = JSON.parseObject(jsonString, new TypeReference&lt;List&lt;Map.Entry&lt;String, List&lt;String&gt;&gt;&gt;&gt;() {}); System.out.println(parse); ```  使用环境：fastjson-1.2.40</body>
		<created>2017-11-14 07:55:57</created>
		<closed>2017-12-09 02:40:53</closed>
	</bug>
	<bug>
		<id>1580</id>
		<title>PropertyFilter 和 SerializerFeature.BeanToArray 联合使用有错</title>
		<body>需要jsonToString 一个 java bean, 使用了PropertyFilter 和 SerializerFeature.BeanToArray ,想要筛选几个需要的属性，然后去掉key,array输出, code 类似：  SimplePropertyPreFilter classAFilter = new SimplePropertyPreFilter(ClassA.class, "code");   SerializeFilter[] filters =new SerializeFilter[]{classAFilter}; JSON.toJSONString(classA, filters, SerializerFeature.BeanToArray ); 但是结果，显示只有SerializerFeature.BeanToArray 起了作用，filter 没有 如果去掉feature, 则可以使filter 起作用 问，如何同时起作用？</body>
		<created>2017-11-13 07:05:37</created>
		<closed>2018-01-23 02:00:01</closed>
	</bug>
	<bug>
		<id>1572</id>
		<title>JSONPath.paths的结果感觉有点问题</title>
		<body>你好！     在使用fastjson的JSONPath时，发现如下问题:  1、有一个类Person， ```java static class Person{          private String name;          private String id;          //get set... } ```  2、实例化该类后将id和name的值设置为同一个值，假设值都设置为“id”，而后用JSONPath.paths(Object obj)解析该实例，如下。得到的path只有"/"和"/id"，没有"/name"。个人觉得得到的path不应该是"/"、"/id"、"/name"吗？ ```java Person person = new Person();  person.setId("id");  person.setName("id");  Map&lt;String, Object&gt; pathValues = JSONPath.paths(person);  Set&lt;String&gt; paths = pathValues.keySet();  for (String path : paths) {  LOG.info(path); } ```  debug下了源码，里面用于用到的是一个Map&lt;Object,String&gt;，根据该map是否含有key来判断是否属于结果集。而对于上面的情况，由于id和name的值都是"id"，所以处理了id属性之后，处理name属性时，由于map中已存在key相同的值，所以"/name"这个path就没有放入该map中了。不知道是我用的不对还是逻辑上有问题？   Hope to hear from you, sincerely.  使用的fastjson版本是1.2.40，如下: ```xml &lt;dependency&gt;     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;     &lt;artifactId&gt;fastjson&lt;/artifactId&gt;     &lt;version&gt;1.2.40&lt;/version&gt; &lt;/dependency&gt; ```</body>
		<created>2017-11-08 09:44:05</created>
		<closed>2017-11-22 15:01:32</closed>
	</bug>
	<bug>
		<id>1570</id>
		<title>新版本JSON.toJSONString(testingOrder, SerializerFeature.WriteNullBooleanAsFalse),随便加一个类似的feauture,就会把模型类的null值给打印出来</title>
		<body>新版本JSON.toJSONString(testingOrder, SerializerFeature.WriteNullBooleanAsFalse),随便加一个类似的feauture,就会把模型类的null值给打印出来  System.out.println(com.alibaba.fastjson.JSON.toJSONString(testingOrder));         System.out.println(com.alibaba.fastjson.JSON.toJSONString(testingOrder,                 SerializerFeature.WriteNullBooleanAsFalse)); 下面是对比。 {"delFlag":"0","new":true}  {"age":null,"approvePoints":null,"bloodFigures":null"}  求指教</body>
		<created>2017-11-07 09:16:54</created>
		<closed>2017-11-22 15:02:00</closed>
	</bug>
	<bug>
		<id>1569</id>
		<title>  1.2.37版本开始出现：default constructor not found 异常</title>
		<body>1.2.40版本，kotlin代码如下： ``` class User() {     constructor(userId: Long, loginName: String) : this() {         this.userId = userId         this.loginName = loginName     }      var userId: Long = Long.MIN_VALUE         private set     var loginName: String = ""         private set }   fun main(args: Array&lt;String&gt;) {     val json = "{\"loginName\":\"san\",\"userId\":1}"     JSON.parseObject(json, User::class.java) }  ```  异常： ``` Exception in thread "main" com.alibaba.fastjson.JSONException: default constructor not found. class com.juxia.mpcrm.application.model.User at com.alibaba.fastjson.util.JavaBeanInfo.build(JavaBeanInfo.java:450) at com.alibaba.fastjson.util.JavaBeanInfo.build(JavaBeanInfo.java:211) at com.alibaba.fastjson.parser.ParserConfig.createJavaBeanDeserializer(ParserConfig.java:611) at com.alibaba.fastjson.parser.ParserConfig.getDeserializer(ParserConfig.java:528) at com.alibaba.fastjson.parser.ParserConfig.getDeserializer(ParserConfig.java:341) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:637) at com.alibaba.fastjson.JSON.parseObject(JSON.java:365) at com.alibaba.fastjson.JSON.parseObject(JSON.java:269) at com.alibaba.fastjson.JSON.parseObject(JSON.java:488) at com.juxia.mpcrm.application.model.SessionUserKt.main(SessionUser.kt:23) ```  已经提供无参默认构造函数为什么还说找不到？    </body>
		<created>2017-11-07 06:58:52</created>
		<closed>2018-08-05 18:31:45</closed>
	</bug>
	<bug>
		<id>1565</id>
		<title>当JavaBean的字段数量超过256个时，PropertyNamingStrategy.SnakeCase设置无效。</title>
		<body> [LargeBean.java.txt](https://github.com/alibaba/fastjson/files/1443862/LargeBean.java.txt) 当JavaBean的字段数量超过256个时，PropertyNamingStrategy.SnakeCase设置无效。 请问下JavaBean的字段数量是否有限制？ fastjson:1.2.40 环境:spring mvc，idea 示例如下：     @Test     public void testToSnakeCaseJson() throws Exception {         LargeBean expectedBean = new LargeBean();         expectedBean.setId("S35669");         expectedBean.setNetValueDate(20171105);         String expectedStr = "{\"id\":\"S35669\",\"net_value_date\":20171105}";         SerializeConfig serializeConfig = new SerializeConfig();         serializeConfig.propertyNamingStrategy = PropertyNamingStrategy.SnakeCase;         String actualStr = JSON.toJSONString(expectedBean, serializeConfig);         JSONObject actualBean = JSON.parseObject(actualStr);         Assert.assertEquals(expectedStr, actualStr);         Assert.assertEquals(expectedBean.getId(), actualBean.getString("id"));         Assert.assertEquals(expectedBean.getNetValueDate(), actualBean.getInteger("net_value_date"));     }  </body>
		<created>2017-11-05 09:35:51</created>
		<closed>2017-11-22 15:00:57</closed>
	</bug>
	<bug>
		<id>1560</id>
		<title>new JSONObject(true)数据无序</title>
		<body>JSONObject 是通过 new JSONObject(true)实例化的，但是读取出来的数据还是无序！</body>
		<created>2017-11-02 09:30:27</created>
		<closed>2017-11-03 12:01:20</closed>
	</bug>
	<bug>
		<id>1548</id>
		<title>1.2.29版本可以解析，1.2.36版本解析报错</title>
		<body>```java public class TestIncSelector {     public static class PublishDoc implements Serializable {          public static final String LSN_META_NAME = "LSN";         public static final String DOCTYPE_META_NAME = "TYPE";         public static final String AREA_META_NAME = "AREA";         public static final String PRIMARY_KEY_META_NAME = "PRIMARY_KEY";         public static final String SECONDARY_KEY_META_NAME = "SECONDARY_KEY";          private JSONObject meta;         private JSONObject doc;          public PublishDoc() {             this.meta = new JSONObject();             this.doc = new JSONObject();         }          public JSONObject getMeta() {             return meta;         }          public void setMeta(JSONObject meta) {             this.meta = meta;         }          public JSONObject getDoc() {             return doc;         }          public void setDoc(JSONObject doc) {             this.doc = doc;         }          @JSONField(serialize = false)         public void addMeta(String name, Object value) {             this.meta.put(name, value);         }          @JSONField(serialize = false)         public Object getMeta(String name) {             return this.meta.get(name);         }          @JSONField(serialize = false)         public Long getLSN() {             return this.meta.getLong(LSN_META_NAME);         }          @JSONField(serialize = false)         public void setLSN(Long lsn) {             this.meta.put(LSN_META_NAME, lsn);         }          @JSONField(serialize = false)         public DocType getDocType() {             return DocType.valueOf(this.meta.getString(DOCTYPE_META_NAME));         }          @JSONField(serialize = false)         public void setDocType(DocType docType) {             this.meta.put(DOCTYPE_META_NAME, docType.toString());         }          @JSONField(serialize = false)         public List&lt;String&gt; getPrimaryKey() {             return this.meta.getJSONArray(PRIMARY_KEY_META_NAME).toJavaList(String.class);         }          @JSONField(serialize = false)         public void setPrimaryKey(List&lt;String&gt; primaryKey) {             this.meta.put(PRIMARY_KEY_META_NAME, primaryKey);         }          @JSONField(serialize = false)         public List&lt;String&gt; getSecondaryKey() {             return this.meta.getJSONArray(SECONDARY_KEY_META_NAME).toJavaList(String.class);         }          @JSONField(serialize = false)         public void setSecondaryKey(List&lt;String&gt; secondaryKey) {             this.meta.put(SECONDARY_KEY_META_NAME, secondaryKey);         }          @JSONField(serialize = false)         public String getArea() {             return this.meta.getString(AREA_META_NAME);         }          @JSONField(serialize = false)         public void setArea(String area) {             this.meta.put(AREA_META_NAME, area);         }          @Override         public String toString() {             return JSON.toJSONString(this);         }     }         @Test     public void test_1(){         String msg = "[{\"doc\":{\"bottomprice\":80,\"cashpool_isdeleted\":0,\"shopcityid\":190,\"timerange\":\"2017-10-25;2017-10-26\",\"launchentityid\":3048,\"bidprice\":700,\"targetitems\":\"{}\",\"type\":0,\"slottagid\":44,\"targetid\":330048,\"entity_isdeleted\":0,\"bu\":2,\"target_isdeleted\":0,\"shopid\":6067941,\"slotids\":\"50041,10233,50051,10033,50061,50001,10099,10133,50101,10051\",\"launchscope\":0,\"productid\":74,\"creativeid\":300048,\"dpentitystatus\":1,\"accountid\":20151002,\"entitytype\":4,\"launchplatforms\":\"\",\"iszhuantou\":0,\"dpentityid\":6067941,\"timeslotperiod\":\"0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167\",\"templateid\":23,\"category1\":246,\"launch_isdeleted\":0,\"cashpoolid\":20151002,\"creative_isdeleted\":0,\"settlementstatus\":1,\"cityid\":\"190\",\"planid\":1042007,\"categoryid\":\"10 246\",\"price\":700,\"shoptype\":10,\"plan_isdeleted\":0,\"launchid\":30000048,\"creativeext\":\"{\\\"content\\\":\\\"啊啊啊啊啊啊啊啊\\\",\\\"title\\\":\\\"啊啊啊啊啊\\\",\\\"smartPic\\\":0,\\\"mobUrl\\\":\\\"https://evt.dianping.com/midas/1activities/3809/index.html?dpid=7997757988618737578&amp;cityid=1&amp;longitude=121.41543&amp;latitude=31.21684&amp;token=&amp;product=dpapp&amp;area=pc\\\",\\\"mtMobUrl\\\":\\\"https://evt.dianping.com/midas/1activities/3809/index.html?dpid=7997757988618737578&amp;cityid=1&amp;longitude=121.41543&amp;latitude=31.21684&amp;token=&amp;product=dpapp&amp;area=mtapp\\\"}\",\"chargetype\":1,\"channel\":0,\"generatedchannel\":0,\"promotype\":2},\"meta\":{\"LSN\":2077395,\"AREA\":\"engine-searchcpc\",\"PRIMARY_KEY\":[\"creativeid\",\"targetid\"],\"SECONDARY_KEY\":[\"planid\",\"shopid\",\"launchentityid\",\"launchid\",\"cashpoolid\"],\"TYPE\":\"UPDATE\"}}]";         // JSONArray.parse(msg);         JSON.parseArray(msg).toJavaList(PublishDoc.class);         // System.out.println(parseMsg(msg));     } } ``` 如下报错： ``` java.lang.VerifyError: (class: com/alibaba/fastjson/parser/deserializer/FastjsonASMDeserializer_1_PublishDoc, method: deserialzeArrayMapping signature: (Lcom/alibaba/fastjson/parser/DefaultJSONParser;Ljava/lang/reflect/Type;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;) Unable to pop operand off an empty stack  at java.lang.Class.getDeclaredConstructors0(Native Method) at java.lang.Class.privateGetDeclaredConstructors(Class.java:2671) at java.lang.Class.getConstructor0(Class.java:3075) at java.lang.Class.getConstructor(Class.java:1825) at com.alibaba.fastjson.parser.deserializer.ASMDeserializerFactory.createJavaBeanDeserializer(ASMDeserializerFactory.java:81) at com.alibaba.fastjson.parser.ParserConfig.createJavaBeanDeserializer(ParserConfig.java:651) at com.alibaba.fastjson.parser.ParserConfig.getDeserializer(ParserConfig.java:502) at com.alibaba.fastjson.parser.ParserConfig.getDeserializer(ParserConfig.java:357) at com.alibaba.fastjson.util.TypeUtils.castToJavaBean(TypeUtils.java:1077) at com.alibaba.fastjson.util.TypeUtils.cast(TypeUtils.java:725) at com.alibaba.fastjson.JSONArray.toJavaList(JSONArray.java:430) at com.dianping.midas.lego.select.test.TestIncSelector.test_1(TestIncSelector.java:122) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:117) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144) ```  经测试 1.29版本正常运行，1.36版本报上述错误</body>
		<created>2017-10-26 11:16:37</created>
		<closed>2017-11-04 10:45:27</closed>
	</bug>
	<bug>
		<id>1543</id>
		<title>Kotlin反序列化异常</title>
		<body>kotlin 1.1.51 jdk8_92 fastjson 1.2.39  复现测试样例： ```kotlin fun main(args: Array&lt;String&gt;) {     println(JSON.VERSION)     try {         val user = mapOf("id" to 1, "name" to "test1")         //直接报错         println(JSON.parseObject(JSON.toJSONString(user), User::class.javaObjectType))     } catch (e: Exception) {         e.printStackTrace()     }     val cluster = mapOf("cluster_enabled" to 1)     //内容为空     println(JSON.parseObject(JSON.toJSONString(cluster), Cluster::class.javaObjectType)) }  data class User(var id: Int? = null, var name: String? = null)  data class Cluster(@JSONField(name = "cluster_enabled") var clusterEnabled: Int? = null) ```</body>
		<created>2017-10-24 12:07:20</created>
		<closed>2017-11-04 10:45:46</closed>
	</bug>
	<bug>
		<id>1529</id>
		<title>fastjson-android  parse crash</title>
		<body>问题版本 ： &gt;= 1.1.60 复现Case：      public static class Person {         public int Id;         public String name;         public double height;     }     jsonStr ："[{\"isId\":false,\"Id\":138042533,\"name\":\"example\",\"height\":172}]"     List&lt;Person&gt; list = JSON.parseArray(jsonStr, Person.class); 结果：    com.alibaba.fastjson.JSONException: cast error, field : Id, value false </body>
		<created>2017-10-18 02:43:55</created>
		<closed>2017-11-03 11:11:19</closed>
	</bug>
	<bug>
		<id>1526</id>
		<title>@JSONField not working on kotlin</title>
		<body>Sample code is: ```kotlin import com.alibaba.fastjson.JSON import com.alibaba.fastjson.annotation.JSONField  fun main(args: Array&lt;String&gt;) {     val dt = DataClass("ccc", "ddd")     val json = JSON.toJSONString(dt)     println(json) }  data class DataClass(     @JSONField(name = "Id")     val Aa: String,      @JSONField(name = "Name")     val Bb: String ) ``` It's output: ```json {"aa":"ccc","bb":"ddd"} ``` This is not correct, it's output should be `{"Id":"ccc","Name":"ddd"}`  If I change the field name `Aa` to `aa`, it is working normal  Environment: fastjson version: 1.2.39 kotlin version: 1.1.51 java version: 1.8.0_144</body>
		<created>2017-10-13 08:07:10</created>
		<closed>2017-11-04 10:45:18</closed>
	</bug>
	<bug>
		<id>1510</id>
		<title>@JSONField(format = "yyyy-MM-dd") 无效</title>
		<body>@JSONField(format = "yyyy-MM-dd") private Date startTime; @JSONField(format = "yyyy-MM-dd") private Date endTime;  版本 1.2.38</body>
		<created>2017-10-05 06:23:56</created>
		<closed>2018-08-05 18:31:26</closed>
	</bug>
	<bug>
		<id>1503</id>
		<title>Map null key值序例化空指针</title>
		<body>版本1.2.38  ``` static {     ParserConfig.getGlobalInstance().setAutoTypeSupport(true); }  public static class Bean {  }  @Test public void test() {     Map&lt;Long, Bean&gt; map = new HashMap&lt;&gt;();     map.put(null, new Bean());     Map&lt;Long, Bean&gt; rmap = (Map&lt;Long, Bean&gt;) JSON.parse(JSON.toJSONString(map, SerializerFeature.WriteClassName));     System.out.println(rmap); } ``` ``` java.lang.NullPointerException at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:518) at com.alibaba.fastjson.parser.deserializer.MapDeserializer.deserialze(MapDeserializer.java:64) at com.alibaba.fastjson.parser.deserializer.MapDeserializer.deserialze(MapDeserializer.java:41) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:358) at com.alibaba.fastjson.parser.DefaultJSONParser.parse(DefaultJSONParser.java:1321) at com.alibaba.fastjson.parser.DefaultJSONParser.parse(DefaultJSONParser.java:1287) at com.alibaba.fastjson.JSON.parse(JSON.java:139) at com.alibaba.fastjson.JSON.parse(JSON.java:130) at com.yhtframework.utils.third.FastjsonUtilsTest.test(FastjsonUtilsTest.java:63) ``` </body>
		<created>2017-09-29 10:10:05</created>
		<closed>2017-10-01 16:39:45</closed>
	</bug>
	<bug>
		<id>1496</id>
		<title>枚举类的枚举变量实现接口以后，@JSONType(serializeEnumAsJavaBean = true)注解或者configEnumAsJavaBean失效</title>
		<body>```xml  &lt;dependency&gt;             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;             &lt;artifactId&gt;fastjson&lt;/artifactId&gt;             &lt;version&gt;1.2.38&lt;/version&gt;  &lt;/dependency&gt; ```  接口 ```java public interface ISetupStatusInfo {     List&lt;SetupStatus&gt; nextList();      Boolean isFirst();      Boolean isLast(); } ````  ```java public interface ISetupStatusProcess {      /**      *      * @return      */     SetupStatus refuse();      /**      * 状态转移失败返回null      *      * @param name      * @return      */     SetupStatus next(String name);  } ````  枚举实现 ```java @JSONType(serializeEnumAsJavaBean = true) public enum SetupStatus implements ISetupStatusInfo, ISetupStatusProcess {     EDIT(0, "EDIT", "编辑中") {         @Override         public List&lt;SetupStatus&gt; nextList() {             return Arrays.asList(FIRST_TRAIL);         }          @Override         public Boolean isFirst() {             return true;         }          @Override         public SetupStatus refuse() {             return EDIT;         }      }, FIRST_TRAIL(1, "FIRST_TRAIL", "初审") {         @Override         public List&lt;SetupStatus&gt; nextList() {             return Arrays.asList(EXPERT, FINAL_TRAIL);         }          @Override         public SetupStatus refuse() {             return EDIT;         }      }, EXPERT(2, "EXPERT", "专家补充意见", false) {         @Override         public List&lt;SetupStatus&gt; nextList() {             return Arrays.asList(FINAL_TRAIL);         }      }, FINAL_TRAIL(3, "FINAL_TRAIL", "公益委员会/理事会/理事长审核") {         @Override         public List&lt;SetupStatus&gt; nextList() {             return Arrays.asList(PASS);         }          @Override         public SetupStatus refuse() {             return EDIT;         }     }, PASS(4, "PASS", "项目通过", false) {         @Override         public List&lt;SetupStatus&gt; nextList() {             return Arrays.asList(SIGN);         }     }, SIGN(5, "SIGN", "协议签署", false) {         @Override         public List&lt;SetupStatus&gt; nextList() {             return Arrays.asList(ACTIVE);         }     }, ACTIVE(6, "ACTIVE", "启动") {         @Override         public List&lt;SetupStatus&gt; nextList() {             return null;         }          @Override         public Boolean isLast() {             return true;         }     };     private int code;     private String name;     private String nameCn;     private boolean canRefuse;      SetupStatus(int code, String name, String nameCn) {         this.code = code;         this.name = name;         this.nameCn = nameCn;         this.canRefuse = true;     }      SetupStatus(int code, String name, String nameCn, boolean canRefuse) {         this.code = code;         this.name = name;         this.nameCn = nameCn;         this.canRefuse = canRefuse;     }      public int getCode() {         return code;     }      public void setCode(int code) {         this.code = code;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public String getNameCn() {         return nameCn;     }      public void setNameCn(String nameCn) {         this.nameCn = nameCn;     }      public boolean isCanRefuse() {         return canRefuse;     }      public void setCanRefuse(boolean canRefuse) {         this.canRefuse = canRefuse;     }      public static SetupStatus getFromCode(Integer code) {         if (code == null) {             return null;         }         for (SetupStatus status : values()) {             if (status.code == code) {                 return status;             }         }         throw new IllegalArgumentException("unknown SetupStatus enumeration code:" + code);     }      public static SetupStatus getFromName(String name) {         if (name == null) {             return null;         }         for (SetupStatus status : values()) {             if (status.name.equals(name)) {                 return status;             }         }         return null;     }      @Override     public Boolean isFirst() {         return false;     }      @Override     public Boolean isLast() {         return false;     }      @Override     public SetupStatus refuse() {         return null;     }      @Override     public SetupStatus next(String name) {         SetupStatus status = getFromName(name);         return name != null &amp;&amp; this.nextList().contains(status) ? status : null;     }      @Override     public String toString() {         return "SetupStatus{" + "code=" + code + ", name='" + name + '\'' + ", nameCn='" + nameCn + '\'' + ", canRefuse=" + canRefuse + '}';     }      public static void main(String[] args) {         SerializeConfig serializeConfig = new SerializeConfig();         System.out.println("edit class:" + EDIT.getClass());         System.out.println("setupStatus class:" + SetupStatus.class);         //配置         serializeConfig.configEnumAsJavaBean(EDIT.getClass());         serializeConfig.configEnumAsJavaBean(SetupStatus.class);         //输出         System.out.println("通过枚举值getClass配置的枚举值可以使用javaBean序列化函数："+JSON.toJSONString(EDIT, serializeConfig));         System.out.println("通过枚举类.class配置的枚举值不可以可以使用javaBean序列化函数："+JSON.toJSONString(FINAL_TRAIL, serializeConfig));     } } ``` 输出 ``` edit class:class com.alijijinhui.enums.project.SetupStatus$1 setupStatus class:class com.alijijinhui.enums.project.SetupStatus 通过枚举值getClass配置的枚举值可以使用javaBean序列化函数：{"canRefuse":true,"code":0,"declaringClass":"com.alijijinhui.enums.project.SetupStatus","first":true,"last":false,"name":"EDIT","nameCn":"编辑中"} 通过枚举类.class配置的枚举值不可以可以使用javaBean序列化函数："FINAL_TRAIL" ```  应该是实现接口后的枚举值成了内部类，类名不同，无法根据枚举类直接获取设置好的javaBeanSerializer</body>
		<created>2017-09-27 02:47:13</created>
		<closed>2017-10-01 16:42:08</closed>
	</bug>
	<bug>
		<id>1494</id>
		<title>SupportNonPublicField不支持parse基类的private成员</title>
		<body>加SupportNonPublicField特性parse到类中普通的private成员没有问题, 但这个类如果有基类, 那么基类的private成员应该也能支持parse吧? 目前的1.2.38版貌似不支持.</body>
		<created>2017-09-25 07:51:15</created>
		<closed>2017-10-01 16:37:25</closed>
	</bug>
	<bug>
		<id>1488</id>
		<title>kotlin在多线程下反序列化会报错</title>
		<body>kotlin 1.1.4-3 jdk 1.8-112 fastjson 1.2.38 场景是开多线程，反序列化同一个data class,使用的方法是JSON.parseObject(String, Class) 线程数在1-3的时候正常，从4个线程开始，出现报错： com.alibaba.fastjson.JSONException: default constructor not found. class com.haiziwang.platform.krediskt.common.pojo.info.Server at com.alibaba.fastjson.util.JavaBeanInfo.build(JavaBeanInfo.java:409) at com.alibaba.fastjson.util.JavaBeanInfo.build(JavaBeanInfo.java:175) at com.alibaba.fastjson.parser.ParserConfig.createJavaBeanDeserializer(ParserConfig.java:602) at com.alibaba.fastjson.parser.ParserConfig.getDeserializer(ParserConfig.java:519) at com.alibaba.fastjson.parser.ParserConfig.getDeserializer(ParserConfig.java:341) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:623) at com.alibaba.fastjson.JSON.parseObject(JSON.java:348) at com.alibaba.fastjson.JSON.parseObject(JSON.java:252) at com.alibaba.fastjson.JSON.parseObject(JSON.java:471)  跟了下代码，发现应该是TypeUtils.getKoltinConstructorParameters(Class)这个方法的问题 刚进入这个方法，TypeUtils类中kotlin_kclass_constructor属性就不为空，但是kotlin_kclass_getConstructors为空，导致在TypeUtils.java的2091行报错空指针，导致这个方法返回null，然后出现上述问题</body>
		<created>2017-09-21 01:59:39</created>
		<closed>2017-11-04 10:45:07</closed>
	</bug>
	<bug>
		<id>1482</id>
		<title>序列化 "2017-06-28T07:20:05.000+05:30" 报错</title>
		<body>https://github.com/alibaba/fastjson/blob/0818ecf14649b2893b486441f685ed8eb2ffd510/src/main/java/com/alibaba/fastjson/parser/JSONScanner.java#L583</body>
		<created>2017-09-19 02:51:50</created>
		<closed>2017-10-03 18:15:42</closed>
	</bug>
	<bug>
		<id>1478</id>
		<title>@JSONField(name = "MD5")，失败，用的最新版</title>
		<body>@JSONField(name = "MD5") private String md5; 转化之后是 “mD5”。用的是最新版 “1.1.63.android”</body>
		<created>2017-09-15 07:59:54</created>
		<closed>2017-11-17 04:47:44</closed>
	</bug>
	<bug>
		<id>1474</id>
		<title>JSONField 注解的 unwrap 特性有 bug</title>
		<body>当 JSONField 注解的参数 `unwrapped` 设为 true 时，若 该对象的字段值全为 null，序列化之后 会多一个逗号， fastjson版本为最新版 1.2.38  java 代码 ``` import java.util.HashMap; import java.util.Map;  import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.annotation.JSONField;  public class FastjsonBugTest { public static void main(String[] args) { Map&lt;String,Object&gt; extraData = new HashMap&lt;String,Object&gt;(); extraData.put("ext_1", null); extraData.put("ext_2", null);  People p = new People(); p.setId("001"); p.setName("顾客"); p.setExtraData(extraData);  System.out.println(JSON.toJSONString(p)); }  static class People{ private String name; private String id; @JSONField(unwrapped=true) private Object extraData;  public String getName() { return name; } public void setName(String name) { this.name = name; } public String getId() { return id; } public void setId(String id) { this.id = id; } public Object getExtraData() { return extraData; } public void setExtraData(Object extraData) { this.extraData = extraData; } } } ```  预期结果： ``` {"id":"001","name":"顾客"} ```  实际结果： ``` {,"id":"001","name":"顾客"} ```</body>
		<created>2017-09-13 10:27:13</created>
		<closed>2017-11-04 10:44:58</closed>
	</bug>
	<bug>
		<id>1462</id>
		<title>kotlin，反序列化时，没有属性字段的set方法，不执行。求解决</title>
		<body>序列化操作时，想隐藏字段。所以data class里属性设置为serialize =false。  ``` data class ObjectA(         @JSONField(serialize = false)         var a:String?="" ){     fun getB():String? = this.a     fun setB(v:String){         this.a = "b"     } }  fun testjson3(){     var a:ObjectA = ObjectA()     a.a = "c"     val json:String = JSON.toJSONString(a)     println(json)     val obj:ObjectA = JSON.parseObject(json, ObjectA::class.java)     println(obj) } ```  输出结果： ``` {"b":"c"} ObjectA(a=null) ```  toJSONString()的时候，执行了getB()方法。 parseObject()的时候，没有执行setB()这个方法。  使用的fastjson 版本是 1.2.37 kotlin版本是1.1.4-2  在java版本里这样子操作是正常的。kotlin不执行set方法。求解决！</body>
		<created>2017-09-08 08:59:05</created>
		<closed>2017-10-01 16:41:57</closed>
	</bug>
	<bug>
		<id>1458</id>
		<title>使用JSONCreator初始化实例后，反序列化不调用Setter。</title>
		<body>见代码： ```java public class HostPoint implements Serializable {      // ------------------------------------------------------------------------      private final static long serialVersionUID = 1L;      private final HostAddress address;      @JSONField(name = "fingerprint")     private Fingerprint fingerprint;      @JSONField(name = "unkown")     private boolean unkown;      // ------------------------------------------------------------------------      @JSONCreator     public HostPoint(@JSONField(name = "address") HostAddress addr) {         this.address = addr;     }      // ------------------------------------------------------------------------      public boolean isChanged() {         return false;     }      public boolean isMatched() {         return false;     }      // ------------------------------------------------------------------------      @Override     public String toString() {         return MoreObjects.toStringHelper(getClass()) //             .addValue(address)                        //             .addValue(fingerprint)                    //             .toString();     }      @Override     public int hashCode() {         return Objects.hash(address);     }      // ------------------------------------------------------------------------      public HostAddress getAddress() {         return address;     }      public Fingerprint getFingerprint() {         return fingerprint;     }      public void setFingerprint(Fingerprint fingerprint) {         this.fingerprint = fingerprint;     }      public boolean isUnkown() {         return unkown;     }      public void setUnkown(boolean unkown) {         this.unkown = unkown;     }  } ``` 调用反序列化后，如下打印： ```json HostPoint{HostAddress{192.168.10.101}, null} ``` 调用JSONObject obj, 打印JSON如下： ```json { "address":{ "hostAddress":"192.168.10.101" }, "unkown":false, "fingerprint":{ "source":"abc" }, "matched":false, "changed":false } ``` 即在使用标签指定构造器后，反序列化器不调用Setter了。</body>
		<created>2017-09-07 07:11:17</created>
		<closed>2017-10-01 16:37:08</closed>
	</bug>
	<bug>
		<id>1449</id>
		<title>对enum对象的序列化与反序列化</title>
		<body>在对enum序列化时,实现JSONSerializable接口后,只有toJSONString方法有效,toJSON无效. 看了下代码,原因应该在于toJSON方法中的 if (clazz.isEnum()) { return ((Enum) javaObject).name(); }. 反序列化时,只能根据enum的name和ordinal去反序列化. fastjson version:1.2.37 test case: ```java public enum Sex implements JSONSerializable {  NONE("0","NONE"),MAN("1","男"),WOMAN("2","女"); private final String code; private final String des; private Sex(String code, String des) { this.code = code; this.des = des; }  public String getCode() { return code; }  public String getDes() { return des; }  @Override public void write(JSONSerializer serializer, Object fieldName, Type fieldType, int features) throws IOException {  JSONObject object = new JSONObject(); object.put("code", code); object.put("des", des); serializer.write(object);  } } public class Student implements Serializable {  /**  *   */ private static final long serialVersionUID = 3083987595140340233L;  private Long id;  private String name;  private Sex sex;         // getter and setter public static void main(String[] args) { Student student = new Student(); student.setName("name"); student.setId(1L); student.setSex(Sex.MAN); System.out.println(JSON.toJSON(student).toString()); System.out.println(JSON.toJSONString(student)); String str1 = "{\"id\":1,\"name\":\"name\",\"sex\":\"MAN\"}"; Student stu1 = JSON.parseObject(str1,Student.class); System.out.println(JSON.toJSONString(stu1)); String str2 = "{\"id\":1,\"name\":\"name\",\"sex\":{\"code\":\"1\",\"des\":\"男\"}}"; JSON.parseObject(str2, Student.class); } } ``` 输出: {"sex":"MAN","name":"name","id":1} {"id":1,"name":"name","sex":{"code":"1","des":"男"}} {"id":1,"name":"name","sex":{"code":"1","des":"男"}} Exception in thread "main" com.alibaba.fastjson.JSONException: parse enum ......</body>
		<created>2017-08-31 15:41:36</created>
		<closed>2017-09-01 14:06:19</closed>
	</bug>
	<bug>
		<id>1444</id>
		<title>页面发出ajax的post请求，参数是一个string，接受端为enum字段，enum上加deserializer没用</title>
		<body>页面发出ajax的post请求，参数是一个string，接受端为enum字段，enum上加@JSONType(deserializer= EnvEnumDeserializer.class) 希望EnvEnumDeserializer能够反序列化传来的string，变为enum </body>
		<created>2017-08-28 07:46:09</created>
		<closed>2017-09-01 14:04:44</closed>
	</bug>
	<bug>
		<id>1429</id>
		<title>@type 放在json body最后一个属性的位置时，JSON.parse(jsonString) 反序列出来的类属性没有赋值</title>
		<body>```json {     "args": [         [{             "@type": "com.taobao.Student",             "age": 22,             "id": 1,             "name": "hello"         }, {             "age": 22,             "id": 1,             "name": "hhh",             "@type": "com.taobao.Student"         }]     ] } ``` 第一个Student字段有赋值，后面的没有赋值。 ![image](https://user-images.githubusercontent.com/5318474/29550923-faa3adec-8742-11e7-8344-689597eddf65.png)  版本：1.2.31</body>
		<created>2017-08-22 06:05:49</created>
		<closed>2017-09-01 14:06:10</closed>
	</bug>
	<bug>
		<id>1425</id>
		<title>使用features 组合 出现 java.lang.NullPointerException</title>
		<body>测试版本：1.2.28， 1.2.37 测试代码 public class DicDomain  {      private String code;      private String name;      public String getCode() {         return code;     }      public void setCode(String code) {         this.code = code;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     } }  public static void main(String[] args) {         DicDomain dicDomain = new DicDomain();         dicDomain.setCode("A001");         dicDomain.setName("测试");          SerializerFeature[] features = new SerializerFeature[]{                 SerializerFeature.NotWriteRootClassName,                 SerializerFeature.WriteClassName,                 SerializerFeature.DisableCircularReferenceDetect         };          System.out.println(JSON.toJSONString(dicDomain, features));     } 错误原因：       只有当这个三个features 搭配使用会出现错误，是这三个不能搭配使用么？。去掉其中任何一个都不会错误。  错误信息; Exception in thread "main" java.lang.NullPointerException at com.alibaba.fastjson.serializer.JSONSerializer.isWriteClassName(JSONSerializer.java:140) at com.alibaba.fastjson.serializer.ASMSerializer_1_DicDomain.writeNormal(Unknown Source) at com.alibaba.fastjson.serializer.ASMSerializer_1_DicDomain.write(Unknown Source) at com.alibaba.fastjson.serializer.JSONSerializer.write(JSONSerializer.java:278) at com.alibaba.fastjson.JSON.toJSONString(JSON.java:587) at com.alibaba.fastjson.JSON.toJSONString(JSON.java:576) at com.zcareze.json.DicTest.main(DicTest.java:35)</body>
		<created>2017-08-21 03:31:16</created>
		<closed>2017-09-01 14:04:32</closed>
	</bug>
	<bug>
		<id>1423</id>
		<title>FastJson 1.2.37 parsing overlow long value issue</title>
		<body>Give class:  ```java     public static class LongVal {         private long v;         public void setV(long v) {             this.v = v;         }          @Override         public String toString() {             return String.valueOf(v);         }     } ```  Give the following code to call fastjson:  ```java         BigInteger n = new BigInteger(String.valueOf(Long.MAX_VALUE)).add(new BigInteger("1"));         Map&lt;String, BigInteger&gt; map = new HashMap&lt;&gt;();         map.put("v", n);         String strBad = JSON.toJSONString(map);         System.out.println(JSON.parseObject(strBad, LongVal.class)); ```  Expected behavior: raise `NumberFormatException`  found it print out `-9223372036854775808`  Screenshot: ![image](https://user-images.githubusercontent.com/216930/29490663-4e5b35cc-8586-11e7-9979-2f74b27987f9.png)  The full source code the reproduce this issue: https://gist.github.com/greenlaw110/e906970a13921fc30adada704468c63f   </body>
		<created>2017-08-19 23:02:51</created>
		<closed>2017-09-01 14:05:28</closed>
	</bug>
	<bug>
		<id>1422</id>
		<title>FastJson 1.2.37 "unclosed.str" issue with valid input</title>
		<body>Note the issue only captured on [v1.2.37](https://github.com/alibaba/fastjson/releases/tag/1.2.37).  Given two strings below:  ```java String strOk = "{\"v\": 111}"; String strBad = "{\"v\":111}"; ```  Note the only difference is there is a whitespace behind `:` in `strOk`.  parsing `strOk` is fine:  ``` Foo ok = JSON.parseObject(strOk, Foo.class); ```  This will cause the `unclosed.str` issue:  ``` Foo bad = JSON.parseObject(strBad, Foo.class); ```  Screenshot: ![image](https://user-images.githubusercontent.com/216930/29490423-74f36cb6-857e-11e7-8fa5-d603b557eb64.png)   The full code to reproduce the issue:  https://gist.github.com/greenlaw110/3d0fc68a569565bdf1c9056ef25ab1fb</body>
		<created>2017-08-19 22:07:46</created>
		<closed>2017-09-01 14:05:37</closed>
	</bug>
	<bug>
		<id>1420</id>
		<title>更新到1.2.37版本后，原本正常的kotlin类无法被正确解析</title>
		<body>```kotlin import com.alibaba.fastjson.JSON import org.junit.Assert import org.junit.Test  class A {     var id: Long = 0     var name: String = "" }  class Test {     @Test     fun test() {         val s = "{\"id\":1,\"name\":\"a\"}"         val o = JSON.parseObject(s, A::class.java)          Assert.assertEquals(1, o.id) // 失败         Assert.assertEquals("a", o.name) // 失败     } } ```  1.2.36版本正常，kotlin 1.1.4</body>
		<created>2017-08-18 09:37:56</created>
		<closed>2017-08-21 02:53:28</closed>
	</bug>
	<bug>
		<id>1407</id>
		<title>fastjson的IdentityHashMap并发时会出错</title>
		<body>并发的往IdentityHashMap中put数据时，可能会没有put进去。 可以用下面这段groovy脚本验证。  两个线程同时往map中put字符串，立刻又get这个字符串，key是同一个对象，但有时会返回null。 如果uncomment掉synchronize语句就不会有这个问题。 ```java import com.alibaba.fastjson.util.IdentityHashMap;  String key = "kkkkkkkkkkkkkkkk"  IdentityHashMap map = new IdentityHashMap(2)  Random ran = new Random()  new Thread() { public void run() { while(true) { String kk = key + ran.nextInt(2) //synchronized(map) { map.put(kk, kk); //} Object val = map.get(kk) if(val == null) { println "found" } } } }.start();  new Thread() { public void run() { while(true) { String kk = key + ran.nextInt(2) //synchronized(map) { map.put(kk, kk); //} Object val = map.get(kk) if(val == null) { println "found" } } } }.start(); ```                 </body>
		<created>2017-08-14 03:17:50</created>
		<closed>2017-08-16 14:30:34</closed>
	</bug>
	<bug>
		<id>1392</id>
		<title>fastjson 1.2.29 升级到1.2.36 导致FastJsonProvider 提前被注册引发个性定制失效</title>
		<body>/**      * 注册共性扩展点      */  protected void registerProviders() {         //基础扩展插件簇         register(MultiPartFeature.class);         //use alibaba fastsjon         register(FastJsonFeature.class);         //register(JacksonObjectMapperProvider.class);         //register(JacksonFeature.class); }  FastJsonFeature 代码如下：  public class FastJsonFeature implements Feature {      private final static String JSON_FEATURE = FastJsonFeature.class.getSimpleName();      @Override     public boolean configure(final FeatureContext context) {         final Configuration config = context.getConfiguration();         final String jsonFeature = CommonProperties.getValue(config.getProperties(), config.getRuntimeType(), InternalProperties.JSON_FEATURE, JSON_FEATURE,             String.class);         // Other JSON providers registered.         if (!JSON_FEATURE.equalsIgnoreCase(jsonFeature)) {             return false;         }         // Disable other JSON providers.         context.property(PropertiesHelper.getPropertyNameForRuntime(InternalProperties.JSON_FEATURE, config.getRuntimeType()), JSON_FEATURE);         // Register FastJson.         if (!config.isRegistered(FastJsonProvider.class)) {             FastJsonProvider fastJsonProvider = new FastJsonProvider();             FastJsonConfig fastJsonConfig=new FastJsonConfig();             fastJsonConfig.setSerializerFeatures(SerializerFeature.DisableCircularReferenceDetect,SerializerFeature.BrowserSecure);             fastJsonProvider.setFastJsonConfig(fastJsonConfig);             context.register(fastJsonProvider, MessageBodyReader.class, MessageBodyWriter.class);         }         return true;     }  }  为什么不直接在registerProviders方法中注册         register(FastJsonProvider.class); 而是 register(FastJsonFeature.class);是因为我在想定制失效循环检测特性以及开始浏览器安全特性，  如：   FastJsonProvider fastJsonProvider = new FastJsonProvider();             FastJsonConfig fastJsonConfig=new FastJsonConfig();             fastJsonConfig.setSerializerFeatures(SerializerFeature.DisableCircularReferenceDetect,SerializerFeature.BrowserSecure);             fastJsonProvider.setFastJsonConfig(fastJsonConfig);             context.register(fastJsonProvider, MessageBodyReader.class, MessageBodyWriter.class);  上述代码我升级到1.2.36后，这个if语句里代码进不去了，我初步判断原因是:  1.2.36中FastJsonProvider默认被jersey发现注册了，替换到了默认的jackson序列化  而1.2.29版本中，是需要显示注册 register(FastJsonProvider.class);的  我想要的效果需要自己代码注册FastJsonProvider，除非默认自动注册的FastJsonProvider默认自带             fastJsonConfig.setSerializerFeatures(SerializerFeature.DisableCircularReferenceDetect,SerializerFeature.BrowserSecure);  这2个feature   </body>
		<created>2017-08-09 12:32:49</created>
		<closed>2017-08-16 14:31:32</closed>
	</bug>
	<bug>
		<id>1390</id>
		<title>org.springframework.data.redis.serializer.SerializationException: Could not deserialize: autoType is not support. org.springframework.security.web.savedrequest.DefaultSavedRequest; nested exception is com.alibaba.fastjson.JSONException: autoType is not support. </title>
		<body>Spring boot +Spring Security在整合SpringSession时， 使用FastJson作为序列化，报了下面的错，搞不清为什么  ```java     /**      * 注入RedisHttpSessionConfiguration中的defaultRedisSerializer属性，      * 替换原来jdk默认的serializer      *      * @return      */     @Bean("springSessionDefaultRedisSerializer")     public GenericFastJsonRedisSerializer redisSessionSerializer() {         return new GenericFastJsonRedisSerializer();     } ```  下面是报错的日志信息：  ···java  org.springframework.data.redis.serializer.SerializationException: Could not deserialize: autoType is not support. org.springframework.security.web.savedrequest.DefaultSavedRequest; nested exception is com.alibaba.fastjson.JSONException: autoType is not support. org.springframework.security.web.savedrequest.DefaultSavedRequest at com.alibaba.fastjson.support.spring.GenericFastJsonRedisSerializer.deserialize(GenericFastJsonRedisSerializer.java:39) at org.springframework.data.redis.core.AbstractOperations.deserializeHashValue(AbstractOperations.java:338) at org.springframework.data.redis.core.AbstractOperations.deserializeHashMap(AbstractOperations.java:282) at org.springframework.data.redis.core.DefaultHashOperations.entries(DefaultHashOperations.java:227) at org.springframework.data.redis.core.DefaultBoundHashOperations.entries(DefaultBoundHashOperations.java:102) at org.springframework.session.data.redis.RedisOperationsSessionRepository.getSession(RedisOperationsSessionRepository.java:432) at org.springframework.session.data.redis.RedisOperationsSessionRepository.getSession(RedisOperationsSessionRepository.java:402) at org.springframework.session.data.redis.RedisOperationsSessionRepository.getSession(RedisOperationsSessionRepository.java:245) at org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper.getSession(SessionRepositoryFilter.java:327) at org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper.getSession(SessionRepositoryFilter.java:344) at org.springframework.session.web.http.SessionRepositoryFilter$SessionRepositoryRequestWrapper.getSession(SessionRepositoryFilter.java:217) at javax.servlet.http.HttpServletRequestWrapper.getSession(HttpServletRequestWrapper.java:270) at org.springframework.security.web.context.HttpSessionSecurityContextRepository.loadContext(HttpSessionSecurityContextRepository.java:110) at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:100) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:331) at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:214) at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:177) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:262) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:105) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.session.web.http.SessionRepositoryFilter.doFilterInternal(SessionRepositoryFilter.java:167) at org.springframework.session.web.http.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:80) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:106) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:595) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:80) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:624) at org.apache.catalina.valves.RemoteIpValve.invoke(RemoteIpValve.java:677) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:799) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:861) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1455) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745) Caused by: com.alibaba.fastjson.JSONException: autoType is not support. org.springframework.security.web.savedrequest.DefaultSavedRequest at com.alibaba.fastjson.parser.ParserConfig.checkAutoType(ParserConfig.java:832) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:304) at com.alibaba.fastjson.parser.DefaultJSONParser.parse(DefaultJSONParser.java:1318) at com.alibaba.fastjson.parser.deserializer.JavaObjectDeserializer.deserialze(JavaObjectDeserializer.java:45) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:623) at com.alibaba.fastjson.JSON.parseObject(JSON.java:361) at com.alibaba.fastjson.JSON.parseObject(JSON.java:324) at com.alibaba.fastjson.support.spring.GenericFastJsonRedisSerializer.deserialize(GenericFastJsonRedisSerializer.java:37) ... 65 common frames omitted ```</body>
		<created>2017-08-09 10:18:05</created>
		<closed>2017-08-16 14:31:05</closed>
	</bug>
	<bug>
		<id>1375</id>
		<title>LinkedList序列化的性能bug</title>
		<body>测试代码如下： import com.alibaba.fastjson.JSON;  import java.util.ArrayList; import java.util.LinkedList; import java.util.List;  /***  * @auth yfeng  * @create 2017-08-06 9:53  */ public class FastJSONTest {     public static void main(String[] args) {         List&lt;Integer&gt; arraylist = new ArrayList&lt;&gt;();         List&lt;Integer&gt; linkedlist = new LinkedList&lt;&gt;();          fillData(arraylist);         fillData(linkedlist);          toJSONTest(arraylist);         toJSONTest(linkedlist);     }      private static void fillData(List&lt;Integer&gt; list) {         for (int i = 0; i &lt; 50000; i++) {             list.add(i + 1);         }     }      private static void toJSONTest(List&lt;Integer&gt; list) {         long start = System.currentTimeMillis();         String data = JSON.toJSONString(list, false);         long end = System.currentTimeMillis();         System.out.println(String.format("spend time %s ms", end - start));     } } 我的本机笔记本输出： spend time 143 ms spend time 5293 ms  性能bug的代码原因在JSONSerializer这个类中，对于prettyFormat = true的情况使用java 5增强for循环，即遍历器进行元素遍历序列化。但是对于prettyFormat = false的逻辑分支则统一使用了Object item = list.get(i);下标值的方式遍历，恰好对于LinkedList的链表结构非常吃力。</body>
		<created>2017-08-06 02:16:54</created>
		<closed>2017-08-08 16:50:15</closed>
	</bug>
	<bug>
		<id>1371</id>
		<title>SerializerFeature.WriteNonStringKeyAsString时，Enum双引号加了两次</title>
		<body>```java import static org.assertj.core.api.Assertions.assertThat;  import java.util.Map; import java.util.TreeMap;  import org.junit.Assert; import org.junit.Test;  import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.parser.Feature; import com.alibaba.fastjson.serializer.SerializerFeature; import com.google.gson.Gson;  public class FastJsonTest {  private enum Rooms{ A, B, C, D ,E ; }  @Test public void testFastjsonEnum(){  Map&lt;Rooms, Rooms&gt; enumMap = new TreeMap&lt;Rooms, Rooms&gt;();  enumMap.put(Rooms.C, Rooms.D); enumMap.put(Rooms.E, Rooms.A);  Assert.assertEquals(JSON.toJSONString(enumMap, SerializerFeature.WriteNonStringKeyAsString), "{\"C\":\"D\",\"E\":\"A\"}");  }              @Test public void testParsed(){  String oldStyleJson = "{1:'abc', 2:'cde'}";  Gson gson = new Gson();  Map fromJson = gson.fromJson(oldStyleJson, Map.class);  Assert.assertNull(fromJson.get(1));  Assert.assertEquals(fromJson.get("1"), "abc" );  Map parsed = JSON.parseObject(oldStyleJson, Map.class, Feature.IgnoreAutoType, Feature.DisableFieldSmartMatch);   Assert.assertNull(parsed.get(1));  Assert.assertEquals(parsed.get("1"), "abc" );  } } ```  因为浏览器按照RFC7159 I-JSON标准，新的javascript API (IE,FF,chrome均是) JSON.parse要求key必定需要双引号，但是中文不一定需要UTF code，于是我们全局使用SerializerFeature.WriteNonStringKeyAsString，但这个时候enum key变成{"\"C\"":"D","\"E\"":"A"}了。请注意Gson默认输出已经是I-JSON规范，因此兼容所有浏览器。  另外，因为JSON不存在所谓的数字key，即便是旧的json，key的语义也是String，因此parse(object, Map.class)的默认不应该返回数字的key，Gson此处仍然正确。  希望可以搞个1.3版本来按I-JSON标准处理？ </body>
		<created>2017-08-04 09:05:11</created>
		<closed>2017-08-08 16:50:25</closed>
	</bug>
	<bug>
		<id>1370</id>
		<title>JsonObject转为java对象（包含Timestamp）报错com.alibaba.fastjson.JSONException: can not cast to Timestamp, value : 2017-08-04 15:16:41.0</title>
		<body>数据库 Timestamp类型 字段createtime：2017-08-04 15:16:41.000000000 Policy  包含 creatime 属性的实体对象。 ```java         List&lt;JSONObject&gt; policys = ps.GetPolicys();         for (JSONObject js : policys) {             System.out.println("查询策略列表..............");                          Policy p = JSON.toJavaObject(js, Policy.class); ```  ```java com.alibaba.fastjson.JSONException: can not cast to Timestamp, value : 2017-08-04 15:16:41.0 at com.alibaba.fastjson.util.TypeUtils.castToJavaBean(TypeUtils.java:1077) at com.alibaba.fastjson.util.TypeUtils.cast(TypeUtils.java:714) at com.alibaba.fastjson.JSON.toJavaObject(JSON.java:945) at cn.com.nei.drmp.feign.controller.MainController.setTask(MainController.java:126) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.scheduling.support.ScheduledMethodRunnable.run(ScheduledMethodRunnable.java:65) at org.springframework.scheduling.support.DelegatingErrorHandlingRunnable.run(DelegatingErrorHandlingRunnable.java:54) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.runAndReset(FutureTask.java:308) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$301(ScheduledThreadPoolExecutor.java:180) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:294) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745) ```</body>
		<created>2017-08-04 07:56:07</created>
		<closed>2017-08-08 16:50:39</closed>
	</bug>
	<bug>
		<id>1367</id>
		<title>FastJsonpHttpMessageConverter4或FastJsonHttpMessageConverter4对泛型支持不是很友好</title>
		<body>public Object read(Type type, Class&lt;?&gt; contextClass, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException; 在上述方法中可以通过contextClass获取type的实际类型，可否考虑之后版本中加以支持</body>
		<created>2017-08-03 09:51:29</created>
		<closed>2017-08-05 07:07:24</closed>
	</bug>
	<bug>
		<id>1363</id>
		<title>反序列化时对map对象的处理的问题</title>
		<body>版本1.2.35，根据网友的http://blog.csdn.net/kkgbn/article/details/76349803 这个博客，问题仍旧在，问题出在DefaultJSONParser.handleResovleTask这个方法里，对于$ref这种，跟踪代码的时候都是扔ResovleTask交给DefaultJSONParser.handleResovleTask处理，问题原因就是对于$ref 指向前面map中的value时没有处理好，结果反序列化为null</body>
		<created>2017-08-02 10:08:09</created>
		<closed>2017-08-08 16:51:05</closed>
	</bug>
	<bug>
		<id>1362</id>
		<title>getXXXValue() 有可能报空引用的问题</title>
		<body>JSONObject的getDoubleValue()有可能报空引用，因为调用了可能会返回空对象的方法，如下假设key为空字符串的话： ``` public double getDoubleValue(String key) {      Object value = get(key);       if (value == null) {          return 0D;      }       return castToDouble(value); } public static Double castToDouble(Object value) {         if (value == null) {             return null;         }          if (value instanceof Number) {             return ((Number) value).doubleValue();         }          if (value instanceof String) {             String strVal = value.toString();             if (strVal.length() == 0 //                 || "null".equals(strVal) //                 || "NULL".equals(strVal)) {                 return null;             }              if (strVal.indexOf(',') != 0) {                 strVal = strVal.replaceAll(",", "");             }              return Double.parseDouble(strVal);         }          throw new JSONException("can not cast to double, value : " + value);     } ```</body>
		<created>2017-08-02 07:52:43</created>
		<closed>2017-08-08 16:50:50</closed>
	</bug>
	<bug>
		<id>1361</id>
		<title>FastJsonProvider+httpclient出现异常"Content-Length header already present"</title>
		<body>在resteasy client中使用fastjson的 provider替换默认的jackson,提交json数据是出现异常"Content-Length header already present", resteasy client使用的是httpclient提交数据,这个异常是httpclient检查到http header里已经存在Content-Length所以抛出的, 在FastJsonProvider里writeTo方法发现有这样一句:httpHeaders.add("Content-Length", String.valueOf(len));  </body>
		<created>2017-08-01 09:10:27</created>
		<closed>2017-08-08 16:51:15</closed>
	</bug>
	<bug>
		<id>1335</id>
		<title>fastjson for android  version can't compatible with “optimal_width”-&gt;“optimalWidth”</title>
		<body>Json数据： ```json { "id": "21496a63f5", "title": "", "url": "http://hl-img.peco.uodoo.com/hubble-test/app/sm/e9b884c1dcd671f128bac020e070e273.jpg;,,JPG;3,208x", "type": "JPG", "optimal_width": 400, "optimal_height": 267, "original_save_url": "http://hl-img.peco.uodoo.com/hubble-test/app/sm/e9b884c1dcd671f128bac020e070e273.jpg", "phash": "62717D190987A7AE"                             } ```  JavaBean结构: ```java  public class Image {     public String id;     public String title;     public String url;     public String type;     public int optimalWidth;     public int optimalHeight;     public String original_save_url;     public String phash; } ```  目标： 把Json数据parse为JavaBean。 用'com.alibaba:fastjson:1.2.33'版本，可以正确处理“optimal_width”-&gt;"optimalWidth"的映射，但使用android版本'com.alibaba:fastjson:1.1.59.android'，处理不了这种映射关系，导致optimalWidth未能正确赋值。  望解决，谢谢。</body>
		<created>2017-07-21 07:01:09</created>
		<closed>2017-07-26 02:22:32</closed>
	</bug>
	<bug>
		<id>1316</id>
		<title>fastjson &lt;1.2.34&gt; java.lang.NullPointerException: null at com.alibaba.fastjson.util.FieldInfo.getFieldType(FieldInfo.java:302)</title>
		<body>  if (fieldType instanceof ParameterizedType) {             ParameterizedType parameterizedFieldType = (ParameterizedType) fieldType;              Type[] arguments = parameterizedFieldType.getActualTypeArguments();             TypeVariable&lt;?&gt;[] typeVariables = null;             ParameterizedType paramType = null;             if (type instanceof ParameterizedType) {                 paramType = (ParameterizedType) type;                 typeVariables = clazz.getTypeParameters();             } else if(clazz.getGenericSuperclass() instanceof ParameterizedType) {                 paramType = (ParameterizedType) clazz.getGenericSuperclass();                 typeVariables = clazz.getSuperclass().getTypeParameters();             }              boolean changed = getArgument(arguments, typeVariables, paramType.getActualTypeArguments());             if (changed) {                 fieldType = new ParameterizedTypeImpl(arguments, parameterizedFieldType.getOwnerType(),                                                       parameterizedFieldType.getRawType());                 return fieldType;             }         }   ParameterizedType paramType  is null    下面的if判断条件都不满足，抛出异常了</body>
		<created>2017-07-07 10:30:06</created>
		<closed>2017-07-16 05:04:22</closed>
	</bug>
	<bug>
		<id>1307</id>
		<title>ContextValueFilter not effect when just using ContextValueFilter, but effect when using with ValueFilter</title>
		<body>``` import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.serializer.BeanContext; import com.alibaba.fastjson.serializer.ContextValueFilter; import com.alibaba.fastjson.serializer.SerializeFilter; import com.alibaba.fastjson.serializer.ValueFilter; import org.junit.Assert; import org.junit.Test;  import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class FastJsonContextValueFilterTest {     ContextValueFilter contextValueFilter = new ContextValueFilter() {          @Override         public Object process(BeanContext beanContext, Object obj, String name, Object value) {             return "mark-"+value;         }     };     ValueFilter valueFilter = new ValueFilter() {         @Override         public Object process(Object object, String name, Object value) {              return value;         }     };      @Test     public void test_context_value_filter_not_effected () {          List&lt;Object&gt; params = new ArrayList&lt;&gt;();         Map data = new HashMap&lt;&gt;();         data.put("name", "ace");         params.add(data);         //fail Actual   :[{"name":"ace"}]         Assert.assertEquals("[{\"name\":\"mark-ace\"}]", JSON.toJSONString(params,             new SerializeFilter[]{                 contextValueFilter //                ,valueFilter             })         );      }      @Test     public void test_context_value_filter_effected() {          List&lt;Object&gt; params = new ArrayList&lt;&gt;();         Map data = new HashMap&lt;&gt;();         data.put("name", "ace");         params.add(data);         //success         Assert.assertEquals("[{\"name\":\"mark-ace\"}]", JSON.toJSONString(params,                 new SerializeFilter[]{                             contextValueFilter,                             valueFilter                 })         );     } } ``` test on maven version with 1.2.24 and 1.2.29 and 1.2.9 / jdk8  all got same result above. Must we use ContextValueFilter with ValueFilter repeatedly? If yes, Please udpate the tips on page [ContextValueFilter-Wiki](https://github.com/alibaba/fastjson/wiki/ContextValueFilter) thank you </body>
		<created>2017-07-03 15:21:16</created>
		<closed>2017-07-05 14:20:55</closed>
	</bug>
	<bug>
		<id>1306</id>
		<title>NullPointerException版本1.2.33开始，之前版本不会</title>
		<body>``` package com.yht.goods.model;  import com.alibaba.fastjson.JSON; import org.junit.Test;  import java.io.Serializable; import java.util.Arrays; import java.util.List;  public class FastjsonTest {      public static abstract class IdEntity&lt;ID extends Serializable&gt; implements Cloneable, Serializable{          private static final long serialVersionUID = 4877536176216854937L;          public IdEntity() {}          public abstract ID getId();         public abstract void setId(ID id);     }      public static class LongEntity extends IdEntity&lt;Long&gt; {          private static final long serialVersionUID = -2740365657805589848L;          private Long id;          @Override         public Long getId() {             return id;         }          public void setId(Long id) {             this.id = id;         }     }      public static class Goods extends LongEntity{         private static final long serialVersionUID = -5751106975913625097L;         private List&lt;Property&gt; properties;          public List&lt;Property&gt; getProperties() {             return properties;         }          public void setProperties(List&lt;Property&gt; properties) {             this.properties = properties;         }          public static class Property extends LongEntity{             private static final long serialVersionUID = 7941148286688199390L;         }     }      public static class TT extends LongEntity {         private static final long serialVersionUID = 2988415809510669142L;          public TT(){}         public TT(Goods goods){             goodsList = Arrays.asList(goods);         }           private List&lt;Goods&gt; goodsList;          public List&lt;Goods&gt; getGoodsList() {             return goodsList;         }          public void setGoodsList(List&lt;Goods&gt; goodsList) {             this.goodsList = goodsList;         }     }      @Test     public void fast() {         Goods goods = new Goods();         goods.setProperties(Arrays.asList(new Goods.Property()));          TT tt = new TT(goods);          TT n = JSON.parseObject(JSON.toJSONString(tt), TT.class);         System.out.println(n);     } } ```  ``` java.lang.NullPointerException at com.alibaba.fastjson.util.FieldInfo.getFieldType(FieldInfo.java:302) at com.alibaba.fastjson.util.FieldInfo.&lt;init&gt;(FieldInfo.java:208) at com.alibaba.fastjson.util.TypeUtils.computeGetters(TypeUtils.java:1575) at com.alibaba.fastjson.util.TypeUtils.buildBeanInfo(TypeUtils.java:1360) at com.alibaba.fastjson.serializer.SerializeConfig.createJavaBeanSerializer(SerializeConfig.java:118) at com.alibaba.fastjson.serializer.SerializeConfig.getObjectWriter(SerializeConfig.java:636) at com.alibaba.fastjson.serializer.SerializeConfig.getObjectWriter(SerializeConfig.java:400) at com.alibaba.fastjson.serializer.JSONSerializer.getObjectWriter(JSONSerializer.java:359) at com.alibaba.fastjson.serializer.JSONSerializer.write(JSONSerializer.java:275) at com.alibaba.fastjson.JSON.toJSONString(JSON.java:656) at com.alibaba.fastjson.JSON.toJSONString(JSON.java:598) at com.alibaba.fastjson.JSON.toJSONString(JSON.java:563) at com.yht.goods.model.FastjsonTest.fast(FastjsonTest.java:97) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:119) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74) ```</body>
		<created>2017-07-03 11:12:05</created>
		<closed>2017-07-16 05:04:51</closed>
	</bug>
	<bug>
		<id>1305</id>
		<title>对象转Json报错空指针错误版本1.2.31不报错,1.2.32开始报错</title>
		<body>从fastjson 1.2.32版本开始,xml转对象后(转换成功),再转Json (JSON.toJSONString)报错: fieldinfo空指针错误  XML: &lt;config&gt;   &lt;category&gt;   &lt;category value="treeTable" label="树结构表（一体）"&gt; &lt;template&gt;treetable/controller.xml&lt;/template&gt; &lt;template&gt;treetable/service.xml&lt;/template&gt; &lt;template&gt;treetable/dao.xml&lt;/template&gt; &lt;template&gt;treetable/entity.xml&lt;/template&gt; &lt;template&gt;treetable/mapper.xml&lt;/template&gt; &lt;template&gt;treetable/viewForm.xml&lt;/template&gt; &lt;template&gt;treetable/viewList.xml&lt;/template&gt; &lt;/category&gt;     &lt;/category&gt;   &lt;javaType&gt; &lt;dict value="String" label="String"/&gt; &lt;dict value="Long" label="Long"/&gt; &lt;dict value="Integer" label="Integer"/&gt; &lt;dict value="Double" label="Double"/&gt; &lt;dict value="java.util.Date" label="Date"/&gt; &lt;dict value="com.treps.modules.sys.entity.SysUser" label="User"/&gt; &lt;dict value="com.treps.modules.sys.entity.Org" label="Org"/&gt; &lt;dict value="com.treps.modules.sys.entity.Area" label="Area"/&gt; &lt;dict value="This" label="ThisObj" description="生成当前对象"/&gt; &lt;dict value="Custom" label="Custom" description="自定义对象，生成后手动设置"/&gt; &lt;/javaType&gt;   &lt;queryType&gt; &lt;dict value="=" label="="/&gt; &lt;dict value="!=" label="!="/&gt; &lt;dict value="&amp;gt;" label="&amp;gt;"/&gt; &lt;dict value="&amp;gt;=" label="&amp;gt;="/&gt; &lt;dict value="&amp;lt;" label="&amp;lt;"/&gt; &lt;dict value="&amp;lt;=" label="&amp;lt;="/&gt; &lt;dict value="between" label="Between"/&gt; &lt;dict value="like" label="Like"/&gt; &lt;dict value="left_like" label="Left Like"/&gt; &lt;dict value="right_like" label="Right Like"/&gt; &lt;/queryType&gt;   &lt;showType&gt; &lt;dict value="label" label="标签"/&gt; &lt;dict value="input" label="单行文本"/&gt; &lt;dict value="textarea" label="多行文本"/&gt; &lt;dict value="select" label="下拉选项"/&gt; &lt;dict value="radiobox" label="单选按钮"/&gt; &lt;dict value="checkbox" label="复选框"/&gt; &lt;dict value="dateselect" label="日期选择"/&gt; &lt;dict value="userselect" label="人员选择"/&gt; &lt;dict value="orgselect" label="部门选择"/&gt; &lt;dict value="areaselect" label="区域选择"/&gt; &lt;dict value="treeselect" label="树选择控件"/&gt; &lt;dict value="fileselect" label="文件上传选择"/&gt; &lt;/showType&gt; &lt;/config&gt;  class1: GenConfig ///////////////////////////////////// import java.io.Serializable; import java.util.List;  import javax.xml.bind.annotation.XmlElement; import javax.xml.bind.annotation.XmlElementWrapper; import javax.xml.bind.annotation.XmlRootElement;  import com.treps.modules.sys.entity.Dict;    @XmlRootElement(name="config") public class GenConfig implements Serializable {  private static final long serialVersionUID = 1L; private List&lt;GenCategory&gt; categoryList;// 代码模板分类 private List&lt;Dict&gt; javaTypeList;// Java类型 private List&lt;Dict&gt; queryTypeList;// 查询类型 private List&lt;Dict&gt; showTypeList;// 显示类型  public GenConfig() { super(); }  @XmlElementWrapper(name = "category") @XmlElement(name = "category") public List&lt;GenCategory&gt; getCategoryList() { return categoryList; }  public void setCategoryList(List&lt;GenCategory&gt; categoryList) { this.categoryList = categoryList; }  @XmlElementWrapper(name = "javaType") @XmlElement(name = "dict") public List&lt;Dict&gt; getJavaTypeList() { return javaTypeList; }  public void setJavaTypeList(List&lt;Dict&gt; javaTypeList) { this.javaTypeList = javaTypeList; }  @XmlElementWrapper(name = "queryType") @XmlElement(name = "dict") public List&lt;Dict&gt; getQueryTypeList() { return queryTypeList; }  public void setQueryTypeList(List&lt;Dict&gt; queryTypeList) { this.queryTypeList = queryTypeList; }  @XmlElementWrapper(name = "showType") @XmlElement(name = "dict") public List&lt;Dict&gt; getShowTypeList() { return showTypeList; }  public void setShowTypeList(List&lt;Dict&gt; showTypeList) { this.showTypeList = showTypeList; }  }   /////////////////////////////////////</body>
		<created>2017-07-03 05:28:41</created>
		<closed>2017-07-22 15:23:37</closed>
	</bug>
	<bug>
		<id>1300</id>
		<title>使用@JSONCreator注解，当JSON字段与构造方法参数不匹配时报错</title>
		<body>```java public class City implements Parcelable {     public final int code;     public final String name;     public final String pinyin;      @JSONCreator     public City(@JSONField(name = "code") int code,                 @JSONField(name = "name") String name,                 @JSONField(name = "pinyin") String pinyin) {         this.code = code;         this.name = name;         this.pinyin = pinyin;     } } ``` ```java      @Test     public void testFullJSON() {         JSONObject data = new JSONObject();         data.put("name", "string");         data.put("code", 1);         data.put("pinyin", "pinyin");         City object = TypeUtils.castToJavaBean(data, City.class);         Assert.assertEquals("string", object.name);         Assert.assertEquals(1, object.code);         Assert.assertEquals("pinyin", object.pinyin);     }      @Test     public void testEmptyJSON() {         City object = TypeUtils.castToJavaBean(new JSONObject(), City.class);         Assert.assertEquals(null, object.name);         Assert.assertEquals(0, object.code);     } ``` 在第二个测试用例中，由于json里面缺少City构造方法中的参数所对应的字段，导致报错： ``` Caused by: com.alibaba.fastjson.JSONException: default constructor not found. class com.parkingwang.api.service.city.objects.City at com.alibaba.fastjson.util.JavaBeanInfo.build(JavaBeanInfo.java:213) at com.alibaba.fastjson.parser.ParserConfig.createJavaBeanDeserializer(ParserConfig.java:522) at com.alibaba.fastjson.parser.ParserConfig.getDeserializer(ParserConfig.java:457) at com.alibaba.fastjson.parser.ParserConfig.getDeserializer(ParserConfig.java:312) at com.alibaba.fastjson.util.TypeUtils.castToJavaBean(TypeUtils.java:911) ... 30 more ``` 1.1.58.android / 1.2.33</body>
		<created>2017-06-30 05:57:04</created>
		<closed>2017-07-15 04:09:36</closed>
	</bug>
	<bug>
		<id>1298</id>
		<title>can not cast to Date, value : 2017-06-29T08:06:30.000+05:30</title>
		<body>使用北京时区 +08:00 转换没有问题，切换时区后，转换出现异常； com.alibaba.fastjson.JSONException: can not cast to Date, value : 2017-06-29T08:06:30.000+05:30 at com.alibaba.fastjson.util.TypeUtils.castToDate(TypeUtils.java:327) at com.alibaba.fastjson.JSONObject.getDate(JSONObject.java:286) </body>
		<created>2017-06-29 05:33:44</created>
		<closed>2017-07-16 05:03:50</closed>
	</bug>
	<bug>
		<id>1281</id>
		<title>使用TypeReference导致我的应用内存泄露</title>
		<body>写了段测试代码，放在Activity的onCreate执行，代码如下： while (true) {             String responseStr2 = "json数据";             Result&lt;Map&lt;String, Object&gt;&gt; responseObject = JSON.parseObject(responseStr2, new       TypeReference&lt;Result&lt;Map&lt;String, Object&gt;&gt;&gt;() {});         } 在运行过程中可以看到内存一直在稳定增长，请问为什么没有释放掉？ 如果循环里面没有使用TypeReference，内存稳定在一定区域。 我使用的是    compile 'com.alibaba:fastjson:1.1.58.android' 如果使用方式有问题，请帮我指出，谢谢！  </body>
		<created>2017-06-21 06:33:09</created>
		<closed>2017-06-27 07:42:20</closed>
	</bug>
	<bug>
		<id>1276</id>
		<title>fastjson反序列化异常类时丢失信息</title>
		<body>自定义的一些字段并没有被反序列化： 我定义的类内容如下： ```java public class MyException extends RuntimeException{     private static final long serialVersionUID = 7815426752583648734L;     private long code;      public MyException() {         super();     }      public MyException(String message, Throwable cause) {         super(message, cause);     }      public MyException(String message) {         super(message);     }      public MyException(Throwable cause) {         super(cause);     }      public MyException(long code) {         super();         this.code = code;     }      public MyException(long code, String message, Throwable cause) {         super(message, cause);         this.code = code;     }      public MyException(long code, String message) {         super(message);         this.code = code;     }      public MyException(long code, Throwable cause) {         super(cause);         this.code = code;     }      public void setCode(long code) {         this.code = code;     }      public long getCode() {         return code;     }      @Override     public String toString() {         return "MyException{" +                 "code=" + code +                 '}';     } }  MyException myException = new MyException(100,"error msg");      str= JSON.toJSONString(myException); 序列化后str的内容为： { "@type": "MyException", "code": 100, "localizedMessage": "error msg", "message": "error msg", "stackTrace": [{ "className": "Main", "fileName": "Main.java", "lineNumber": 103, "methodName": "main", "nativeMethod": false }, { "className": "sun.reflect.NativeMethodAccessorImpl", "fileName": "NativeMethodAccessorImpl.java", "lineNumber": -2, "methodName": "invoke0", "nativeMethod": true }, { "className": "sun.reflect.NativeMethodAccessorImpl", "fileName": "NativeMethodAccessorImpl.java", "lineNumber": 57, "methodName": "invoke", "nativeMethod": false }, { "className": "sun.reflect.DelegatingMethodAccessorImpl", "fileName": "DelegatingMethodAccessorImpl.java", "lineNumber": 43, "methodName": "invoke", "nativeMethod": false }, { "className": "java.lang.reflect.Method", "fileName": "Method.java", "lineNumber": 606, "methodName": "invoke", "nativeMethod": false }, { "className": "com.intellij.rt.execution.application.AppMain", "fileName": "AppMain.java", "lineNumber": 144, "methodName": "main", "nativeMethod": false }], "suppressed": [] } ``` 但通过MyException myExceptionJson = JSON.parseObject(str,MyException.class); 反序列化后，得到的myExceptionJson的code字段并没有被反序列化出来。</body>
		<created>2017-06-16 12:15:13</created>
		<closed>2017-07-02 15:02:15</closed>
	</bug>
	<bug>
		<id>1265</id>
		<title>android版解析同样数据时，有时解析正确有时错误</title>
		<body>fastjson： 1.1.58.android android：4.4.4 调用方式：`JSON.parseObject(json, mType)` 我们查看了会谈返回的json数据， fastjson解析错误与正确的时候，json完全一致。 type为：`new TypeReference&lt;A&lt;B&gt;&gt;() {}` 解析错误时，成功解析A对象，A下面的B只解析成JSONObject</body>
		<created>2017-06-15 05:48:24</created>
		<closed>2017-07-26 02:22:06</closed>
	</bug>
	<bug>
		<id>1258</id>
		<title>class泄漏问题</title>
		<body>在jetty容器中用fastjson序列化HttpServletRequest对象或导致class泄漏，严重时会导致meta区溢出，导致无限FGC。详见: [分析文档](http://13009206.blog.51cto.com/12999206/1934624)</body>
		<created>2017-06-12 08:34:39</created>
		<closed>2017-07-02 15:01:49</closed>
	</bug>
	<bug>
		<id>1240</id>
		<title>org.springframework.util.LinkedMultiValueMap反序列化失败</title>
		<body>fastjson版本：1.2.32 LinkedMultiValueMap数据无法反序列化  testcase： ```         ParserConfig.getGlobalInstance().setAutoTypeSupport(true);         LinkedMultiValueMap&lt;String, String&gt; result = new LinkedMultiValueMap();         result.add("test", "11111");         String test = JSON.toJSONString(result, SerializerFeature.WriteClassName);         JSON.parseObject(test); ```  报错信息：  ```    Exception in thread "main" com.alibaba.fastjson.JSONException: autoType is not support. org.springframework.util.LinkedMultiValueMap at com.alibaba.fastjson.parser.ParserConfig.checkAutoType(ParserConfig.java:830) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:325) at com.alibaba.fastjson.parser.DefaultJSONParser.parse(DefaultJSONParser.java:1335) at com.alibaba.fastjson.parser.DefaultJSONParser.parse(DefaultJSONParser.java:1301) at com.alibaba.fastjson.JSON.parse(JSON.java:152) at com.alibaba.fastjson.JSON.parse(JSON.java:143) at com.alibaba.fastjson.JSON.parseObject(JSON.java:216) ```</body>
		<created>2017-05-31 14:09:45</created>
		<closed>2017-06-11 17:40:14</closed>
	</bug>
	<bug>
		<id>1233</id>
		<title>android 1.1.57版本 使用ParserConfig.getGlobalInstance().putDeserializer注入自定义反序列化类的时候，(T) JSON.toJavaObject这种方式会导致嵌套反序列化失败</title>
		<body>``` ParserConfig.getGlobalInstance().putDeserializer(Area.class, new ObjectDeserializer() {             @Override             public &lt;T&gt; T deserialze(DefaultJSONParser parser, Type type, Object fieldName) {                 JSONObject jsonObject = (JSONObject) parser.parse();                 String areaType;                  if (jsonObject.get("type") instanceof String) {                     areaType = (String) jsonObject.get("type");                 } else {                     return null;                 }                 if (Area.TYPE_SECTION.equals(areaType)) {                     return (T) JSON.toJavaObject(jsonObject, Section.class);                 } else if (Area.TYPE_FLOORV1.equals(areaType)) {                     return (T) JSON.toJavaObject(jsonObject, FloorV1.class);                 } else if (Area.TYPE_FLOORV2.equals(areaType)) {                     return (T) JSON.toJavaObject(jsonObject, FloorV2.class);                 }                 return null;             }          }); ```  Area接口 ： -- ``` public interface Area {     public static final String TYPE_SECTION = "section";     public static final String TYPE_FLOORV1 = "floorV1";     public static final String TYPE_FLOORV2 = "floorV2";      String getName(); } ``` Section类： -- ``` public class Section implements Area {     public List&lt;Area&gt; children;      public String type;      public String templateId;      @Override     public String getName() {         return templateId;     } } ``` FloorV1类： -- ``` public class FloorV1 implements Area {     public String type;     public String templateId;      @Override     public String getName() {         return templateId;     } } ``` FloorV2类： -- ``` public class Section implements Area {     public List&lt;Area&gt; children;      public String type;      public String templateId;      @Override     public String getName() {         return templateId;     } } ```  JSON 结构 ```     static String jsonData = "{\n" +             "    \"areas\": [\n" +             "      {\n" +             "        \"type\": \"section\",\n" +             "        \"templateId\": \"grid\",\n" +             "        \"children\": [\n" +             "        {\n" +             "        \"type\": \"section\",\n" +             "        \"templateId\": \"grid\",\n" +             "        \"children\": [\n" +             "          {\n" +             "            \"type\": \"floorV2\",\n" +             "            \"templateId\": \"base\",\n" +             "          },\n" +             "          {\n" +             "            \"type\": \"floorV2\",\n" +             "            \"templateId\": \"base\",\n" +             "          }\n" +             "        ]\n" +             "      },\n" +             "          {\n" +             "            \"type\": \"floorV2\",\n" +             "            \"templateId\": \"base\",\n" +             "          },\n" +             "          {\n" +             "            \"type\": \"floorV2\",\n" +             "            \"templateId\": \"base\",\n" +             "          }\n" +             "        ]\n" +             "      },\n" +             "          {\n" +             "            \"type\": \"floorV2\",\n" +             "            \"templateId\": \"base\",\n" +             "          }\n" +             "    ]\n" +             "  }"; ``` 最后的结果就是最里层的floor被解析成了$Proxy 没有解析成floor</body>
		<created>2017-05-26 09:07:26</created>
		<closed>2017-05-30 17:17:07</closed>
	</bug>
	<bug>
		<id>1231</id>
		<title>1.1.57.android  DefaultFieldDeserializer 没有处理 parser.context 为 null 的情况，导致解析出错</title>
		<body>粗略看了下[DefaultJSONParser.java](https://github.com/alibaba/fastjson/blob/android/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java)代码，这个 [context](https://github.com/alibaba/fastjson/blob/android/src/main/java/com/alibaba/fastjson/parser/DefaultJSONParser.java#L1320) 在 `lexer.disableCircularReferenceDetect` 为 true 的时候不会被赋值。即指定了 `Feature.DisableCircularReferenceDetect` 之后。  而 master 分支上的 [DefaultFieldDeserializer.java](https://github.com/alibaba/fastjson/blob/master/src/main/java/com/alibaba/fastjson/parser/deserializer/DefaultFieldDeserializer.java#L51) 代码其实处理了。  </body>
		<created>2017-05-25 10:24:14</created>
		<closed>2017-05-30 17:17:18</closed>
	</bug>
	<bug>
		<id>1225</id>
		<title>1.1.57.android 带泛型的多层继承类的解析bug</title>
		<body>类似testcase  [Bug_for_generic_huansi.java](https://github.com/alibaba/fastjson/blob/android/src/test/java/com/alibaba/json/bvt/bug/Bug_for_generic_huansi.java) 但在第二层继承的时候嵌套了List ```java @RunWith(JUnit4.class) public class GenericObjectJsonParseTest {      @Test     public void parseObject() {         assertEquals("2", JSON.parseObject("{\"data\":[\"1\",\"2\",\"3\"]}",                 new TypeReference&lt;BaseGenericType&lt;List&lt;String&gt;&gt;&gt;(){}).data.get(1));         assertEquals("2", JSON.parseObject("{\"data\":[\"1\",\"2\",\"3\"]}",                 new TypeReference&lt;ExtendGenericType&lt;String&gt;&gt;(){}).data.get(1));         assertEquals("2", JSON.parseObject("{\"data\":[\"1\",\"2\",\"3\"],\"a\":\"a\"}",                 SimpleGenericObject.class).data.get(1));     }      static class BaseGenericType&lt;T&gt; {         public T data;     }      static class ExtendGenericType&lt;T&gt; extends BaseGenericType&lt;List&lt;T&gt;&gt; {     }      static class SimpleGenericObject extends ExtendGenericType&lt;String&gt; {     } } ``` 在解析SimpleGenericObject类的时候单元测试失败： `java.lang.ClassCastException: java.lang.String cannot be cast to java.util.List`</body>
		<created>2017-05-24 11:09:56</created>
		<closed>2017-05-30 17:21:02</closed>
	</bug>
	<bug>
		<id>1222</id>
		<title>enum实现JSONAware的时候，没有调到JSONAware里面去</title>
		<body>定义一个enum，并且实现JSONAware接口。  期望能够使用JSONAware的toJSONString输出，但实际走的是enum的name()。  版本号1.2.27和1.2.32都试过了  在我的工程里可以稳定重现，但目前还未能构造一个精简的case，所有把这段代码摘出来的测试都可以走到JSONAware里面去。  类结构大致如下：  ![image](https://cloud.githubusercontent.com/assets/1854156/26364096/b162cc2c-4015-11e7-8c66-7303b28b78c4.png)  在调用 type的get方法时的堆栈如下：  ![image](https://cloud.githubusercontent.com/assets/1854156/26364214/212cc45e-4016-11e7-86fd-051ec17ff4a4.png)   希望这个堆栈信息能够有所帮助 </body>
		<created>2017-05-23 16:17:16</created>
		<closed>2017-06-11 17:40:26</closed>
	</bug>
	<bug>
		<id>1198</id>
		<title>$ref反序列化出现异常</title>
		<body>` {   "types": [     {       "type": "com.taobao.mtop.common.Result",       "$ref": "com.taobao.mtop.common.Result"     }   ] } ` 这段在反序列化的时候，报错。 ` Object obj=JSON.parse(str, Feature.DisableCircularReferenceDetect); ` 需求是：忽略所有$ref字段</body>
		<created>2017-05-12 05:57:55</created>
		<closed>2017-06-11 17:40:00</closed>
	</bug>
	<bug>
		<id>1196</id>
		<title>fastjson 怎么这么不稳定啊？表示很伤心</title>
		<body>1.2.29版本 @JSONField(serialzeFeatures = SerializerFeature.WriteEnumUsingToString) 无效，已经复写了toString方法，然后切换到1.2.32版本又好了，表示很伤心啊，温少 @wenshao 这样怎么用到生产中啊？！求稳定，一直很看好fastjson的 </body>
		<created>2017-05-10 16:56:43</created>
		<closed>2017-06-11 17:39:41</closed>
	</bug>
	<bug>
		<id>1188</id>
		<title>注解@JSONField(deserialize = false)，反系列化出错</title>
		<body>对象是这样的 ``` public class Info{  @JSONField(deserialize=false) private List&lt;Integer&gt; ids; private String name;  public List&lt;Integer&gt; getIds() { return ids; }  public void setIds(List&lt;Integer&gt; ids) { this.ids = ids; }  public String getName() { return name; }  public void setName(String name) { this.name = name; }  } ``` json是`{"ids":"1,2","name":"abc"}` 反系列化是正常的,ids 也是 null 当json是`{"ids":"a1,a2","name":"abc"}`就出错了 ``` Exception in thread "main" com.alibaba.fastjson.JSONException: For input string: "a1a2" at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:646) at com.alibaba.fastjson.JSON.parseObject(JSON.java:350) at com.alibaba.fastjson.JSON.parseObject(JSON.java:254) at com.alibaba.fastjson.JSON.parseObject(JSON.java:467) at com.huateng.weixin.Test.main(Test.java:54) Caused by: java.lang.NumberFormatException: For input string: "a1a2" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Integer.parseInt(Integer.java:492) at java.lang.Integer.parseInt(Integer.java:527) at com.alibaba.fastjson.util.TypeUtils.castToInt(TypeUtils.java:578) at com.alibaba.fastjson.serializer.IntegerCodec.deserialze(IntegerCodec.java:100) at com.alibaba.fastjson.parser.deserializer.ArrayListTypeFieldDeserializer.parseArray(ArrayListTypeFieldDeserializer.java:174) at com.alibaba.fastjson.parser.deserializer.ArrayListTypeFieldDeserializer.parseField(ArrayListTypeFieldDeserializer.java:62) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:602) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:212) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:208) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:642) ... 4 more  ``` 为什么加了@JSONField(deserialize=false)不是直接忽略 ids呢？ 这个问题要怎么解决呢？ </body>
		<created>2017-05-09 04:14:44</created>
		<closed>2017-05-10 01:33:43</closed>
	</bug>
	<bug>
		<id>1178</id>
		<title>JSON.toJavaObject can't be compatible </title>
		<body>``` public class TestModel implements Serializable {     public String info; } ```  ``` String json = "{\n" +             " \"info\": {\n" +             "        \"test\": \"\", \n" +             "    }\n" +             "}";  JSONObject jsonObject = JSON.parseObject(json); TestModel loginResponse = JSON.toJavaObject(jsonObject, TestModel.class);  ```  If I use the version &lt;= 1.1.46.android,there is no problem.But if I use the version &gt; 1.1.46.android, it will throw a JSONException(can not get javaBeanDeseriallizer)  I must write the modle like this when the version &gt; 1.1.46.android ``` public class TestModel implements Serializable {     public JSONObject info; }  ```  Is there any solution？</body>
		<created>2017-05-02 09:57:54</created>
		<closed>2017-05-02 15:21:21</closed>
	</bug>
	<bug>
		<id>1177</id>
		<title>JSONPath  "deepScan属性访问，例如$..name"  抛出异常</title>
		<body>使用1.2.8版本，main方法中执行以下代码： `String text = "{\"a\":{\"b\":\"c\",\"g\":{\"e\":\"f\"}},\"d\":{\"a\":\"f\",\"h\":[\"s1\"]}} ";         JSONObject jsonObject = JSONObject.parseObject(text);         Object eval = JSONPath.eval(jsonObject, "$..a");`  抛出异常 Exception in thread "main" com.alibaba.fastjson.JSONPathException: illeal jsonpath syntax. $..a at com.alibaba.fastjson.JSONPath$JSONPathParser.readName(JSONPath.java:826) at com.alibaba.fastjson.JSONPath$JSONPathParser.readSegement(JSONPath.java:356) at com.alibaba.fastjson.JSONPath$JSONPathParser.explain(JSONPath.java:889) at com.alibaba.fastjson.JSONPath.init(JSONPath.java:66) at com.alibaba.fastjson.JSONPath.eval(JSONPath.java:75) at com.alibaba.fastjson.JSONPath.eval(JSONPath.java:251) at com.apidocs.test.test.main(test.java:65)</body>
		<created>2017-05-02 07:59:03</created>
		<closed>2017-05-10 01:47:08</closed>
	</bug>
	<bug>
		<id>1161</id>
		<title>JSONCreator 参数不匹配导致反序列化失败</title>
		<body>见#802。 Android版本一直没有修复。</body>
		<created>2017-04-23 06:54:59</created>
		<closed>2017-05-02 15:21:31</closed>
	</bug>
	<bug>
		<id>1160</id>
		<title>JSONCreator 参数不匹配导致反序列化失败</title>
		<body>见#802。 Android版本一直没有修复。</body>
		<created>2017-04-23 06:54:54</created>
		<closed>2017-05-02 15:21:08</closed>
	</bug>
	<bug>
		<id>1152</id>
		<title>JSONField 反序列化iso-8601日期格式“0001-01-01T00:00:00”失败</title>
		<body>@wenshao  JSONField 反序列化iso-8601日期格式“0001-01-01T00:00:00”异常，试了一下小于“1000-01-01T00:00:00”这个时间就异常，否则可以成功。 小于“1000-01-01T00:00:00”的结果： `Exception in thread "main" com.alibaba.fastjson.JSONException: For input string: "0001-01-01T00:00:00" at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:646) at com.alibaba.fastjson.JSON.parseObject(JSON.java:350) at com.alibaba.fastjson.JSON.parseObject(JSON.java:254) at com.alibaba.fastjson.JSON.parseObject(JSON.java:467) at com.credfin.test0.main(test0.java:16) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:597) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147) Caused by: java.lang.NumberFormatException: For input string: "0001-01-01T00:00:00" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:48) at java.lang.Long.parseLong(Long.java:419) at java.lang.Long.parseLong(Long.java:468) at com.alibaba.fastjson.serializer.DateCodec.cast(DateCodec.java:202) at com.alibaba.fastjson.parser.deserializer.AbstractDateDeserializer.deserialze(AbstractDateDeserializer.java:142) at com.alibaba.fastjson.parser.deserializer.AbstractDateDeserializer.deserialze(AbstractDateDeserializer.java:19) at com.alibaba.fastjson.parser.deserializer.DefaultFieldDeserializer.parseField(DefaultFieldDeserializer.java:71) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.parseField(JavaBeanDeserializer.java:828) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:630) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.parseRest(JavaBeanDeserializer.java:1010) at com.alibaba.fastjson.parser.deserializer.FastjsonASMDeserializer_1_TestBean.deserialze(Unknown Source) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:208) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:642) ... 9 more ` 大于等于“1000-01-01T00:00:00”的结果： `1000-01-01 00:00:00`  目前通过自定义反序列化deserializeUsing解决，但是不知道以上情况算不算bug.  测试代码： ```java public class TestBean {      private Date shijian;      public Date getShijian() {         return shijian;     }     @JSONField(name="shijian" )     public void setShijian(Date shijian) {         this.shijian = shijian;     } }  public class test0 {      public static void main(String[] args){         TestBean tb = JSONObject.parseObject("{shijian:\"1000-01-01T00:00:00\"}",TestBean.class);         SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");         System.out.println(sdf.format(tb.getShijian()));     } } ```</body>
		<created>2017-04-19 03:47:40</created>
		<closed>2017-06-11 17:39:51</closed>
	</bug>
	<bug>
		<id>1150</id>
		<title>如果一个字段有数据为数组，没数据为空字符串，我该如何解析</title>
		<body>能不能类型错误的时候 ，给予null值，或者空数组，不要直接崩溃</body>
		<created>2017-04-18 12:44:39</created>
		<closed>2019-07-11 06:06:11</closed>
	</bug>
	<bug>
		<id>1129</id>
		<title>JSONField在某些场景下不起作用</title>
		<body>1. 不是is/set开头的setter方法 2. 方法名称长度小于4的方法</body>
		<created>2017-04-05 15:33:48</created>
		<closed>2017-05-09 18:35:59</closed>
	</bug>
	<bug>
		<id>1120</id>
		<title>如果字段字母大写 @JSONField不起作用 </title>
		<body>@JSONField(name="REQ_NO") private String ReqNo;  字段字母大写 输出结果为"reqNo"</body>
		<created>2017-04-01 08:49:10</created>
		<closed>2017-04-03 08:05:01</closed>
	</bug>
	<bug>
		<id>1112</id>
		<title>解析属性第一位是数字时异常 NumberFormatException</title>
		<body> ##当属性的第一位是数字时（如：345_xiu），JsonPath尝试将属性转换为Integer类型，出现java.lang.NumberFormatException。  我的解决方案是在传入表达式时添加"\\"进行转义，伪代码： String path = "$.xiu.\\345_xiu"; JsonPath.eval(jsonOgject , path);  希望有更好的解决方法。</body>
		<created>2017-03-30 02:50:37</created>
		<closed>2017-04-03 08:04:36</closed>
	</bug>
	<bug>
		<id>1109</id>
		<title>FastJson不能正确处理引号</title>
		<body>重现代码： ```java import com.alibaba.fastjson.JSON; import org.apache.commons.lang3.tuple.Pair;  /**  * Created by xiafei.qiuxf on 2017/3/28.  */ public class FastJsonBug {     public static void main(String[] args) {         Pair&lt;String, String&gt; data = Pair.of("key", "\"the\"content");         System.out.println(JSON.toJSONString(data));     } } ```  输出： ``` {"key":""the"content"} ```  影响版本：1.2.24, 1.2.25  使用的commons-lang3版本为：3.4</body>
		<created>2017-03-28 05:58:59</created>
		<closed>2017-04-03 08:04:28</closed>
	</bug>
	<bug>
		<id>1089</id>
		<title>当json中有下划线和无下划线的相似属性名时解析结果有可能错误</title>
		<body>json串中有两个属性，名称为ab和a_b，差别是一个有下划线而另一个没有，当解析对象时，如果对象的定义中只有ab一个属性，则解析出来的对象中ab的值可能会是json串中a_b属性的值，解析成哪个值跟json串中ab和a_b的顺序有关： ```java @Test public void parseTest() { String json = "{\"ab\":123,\"a_b\":456}"; TestBean tb = JSON.parseObject(json, TestBean.class); Assert.assertEquals(123, tb.getAb()); } private static class TestBean { private int ab; public int getAb() { return ab; } public void setAb(int ab) { this.ab = ab; } }  ``` 结果 java.lang.AssertionError: expected:&lt;123&gt; but was:&lt;456&gt;  测试在1.2.28，1.2.29中有此问题。</body>
		<created>2017-03-20 06:25:02</created>
		<closed>2017-03-26 14:49:07</closed>
	</bug>
	<bug>
		<id>1083</id>
		<title>1.2.29WriteNonStringValueAsString依旧不好用</title>
		<body>test case: Map map = new HashMap(); map.put("userId", 456); JSON.toJSONString(map, SerializerFeature.WriteNonStringValueAsString);  结果： {"userId":456} </body>
		<created>2017-03-17 10:23:15</created>
		<closed>2017-06-11 17:39:31</closed>
	</bug>
	<bug>
		<id>1064</id>
		<title>关于1036的issue未修复问题</title>
		<body>如题，https://github.com/alibaba/fastjson/issues/1036  今天刚看到作者的更新，试了下1.2.28版本，貌似并没有解决该问题，还请麻烦再看下。  BTW：因为没有找到reopen入口，故再开一个issue，抱歉。</body>
		<created>2017-03-13 07:09:07</created>
		<closed>2017-03-16 11:55:22</closed>
	</bug>
	<bug>
		<id>1063</id>
		<title>Timestamp/sql.Date类型在JSON.parseObject和JSONObject.getObject转换成Bean的结果不同</title>
		<body>测试Case： ```java     public static class TimestampBean {         private Timestamp timestamp = null;          public Timestamp getTimestamp() {             return timestamp;         }          public void setTimestamp(Timestamp timestamp) {             this.timestamp = timestamp;         }     }      public static void main(String[] args) throws Exception {         JSON.DEFAULT_GENERATE_FEATURE |= SerializerFeature.DisableCircularReferenceDetect.getMask();         JSON.DEFAULT_GENERATE_FEATURE |= SerializerFeature.WriteDateUseDateFormat.getMask();          TimestampBean bean = new TimestampBean();         bean.setTimestamp(new Timestamp(System.currentTimeMillis()));         String timestampJson = JSON.toJSONString(bean);         System.out.println(timestampJson);          // 这里能转换成功         TimestampBean beanOfJSON = JSON.parseObject(timestampJson, TimestampBean.class);         System.out.println(beanOfJSON.toString());          // 这里抛异常 java.lang.NumberFormatException         JSONObject jsonObject = JSON.parseObject(timestampJson);         Timestamp beanOfJsonObject = jsonObject.getObject("timestamp", Timestamp.class);         System.out.println(beanOfJsonObject.toString());     } ```</body>
		<created>2017-03-10 14:22:56</created>
		<closed>2017-03-16 11:47:33</closed>
	</bug>
	<bug>
		<id>1053</id>
		<title>android 版本 循环引用没有被正确处理</title>
		<body>我的request 在新的1.1.56.android中tojson没有被正确处理，json string如下：  remote request {"indexPhrase":[["确定","确认","是的","好的","没错","可以","对的","行的"],["别了","停止","取消","不对","不行","不好","不是","算了","不要"]],"jsonObject":{"sel_index_phrase":[{"$ref":"$.indexPhrase"},{"$ref":"$.indexPhrase"}]},"paramType":"TYPE_MULTI_SELECTION"}  在1.2.24正式版中，如下：  remote request {"indexPhrase":[["确定","确认","是的","好的","没错","可以","对的","行的"],["别了","停止","取消","不对","不行","不好","不是","算了","不要"]],"jsonObject":{"sel_index_phrase":[{"$ref":"$.indexPhrase[0]"},{"$ref":"$.indexPhrase[1]"}]},"paramType":"TYPE_MULTI_SELECTION"}  显然android版本的循环引用逻辑出了问题，json 没有被正确的序列化。  相关测试code如下：  ```java public class FastJsonTest {     private static final String TAG = "FastJsonTest";      @Test     public void testParseJson() throws InterruptedException {         List&lt;String&gt; a = Arrays.asList("确定", "确认", "是的", "好的", "没错", "可以", "对的", "行的");         List&lt;String&gt; b = Arrays.asList("别了", "停止", "取消", "不对", "不行", "不好", "不是", "算了", "不要");         List&lt;List&gt; c = new ArrayList&lt;&gt;();         c.add(a);         c.add(b);         Request e = new Request("TYPE_MULTI_SELECTION", c);         String request = JSON.toJSONString(e);         Log.e(TAG, " remote request " + request);         Request request1 = null;         try {             request1 = JSON.parseObject(request, Request.class);         } catch (Exception ex) {             Log.e(TAG, "error  :  ", ex);         }         Log.e(TAG, "request1 = " + JSON.toJSONString(request1));     }      public static class Request implements Serializable {          public String paramType;         public JSONObject jsonObject = new JSONObject();          public Request(){          }          public Request(String paramType, List&lt;? extends List&gt; list) {             this.paramType = paramType;             if (null != list) {                 jsonObject.put("sel_index_phrase", list);             }         }          public List&lt;? extends List&gt; getIndexPhrase() {             Object phrases = jsonObject.get("sel_index_phrase");             if (null != phrases) {                 return (List&lt;? extends List&gt;) phrases;             } else {                 return new ArrayList&lt;&gt;();             }         }     } } ```</body>
		<created>2017-03-06 05:55:37</created>
		<closed>2017-05-02 15:21:50</closed>
	</bug>
	<bug>
		<id>1038</id>
		<title>jsonpath 数组表达式解析错误</title>
		<body> JSONPath.remove(jsonObject, "$.aaa[0:1].age");解析出错    JSONPath.remove(jsonObject, "$.aaa[0,1].age");解析出错   JSONPath.remove(jsonObject, "$.aaa[0].age");解析正确   </body>
		<created>2017-02-25 00:42:35</created>
		<closed>2017-03-16 11:45:39</closed>
	</bug>
	<bug>
		<id>1036</id>
		<title>fastjson 1.2.22到1.2.24，反序列化的对象中含有Throwable类型的属性时，报syntax error</title>
		<body>如题，如果参与序列化的对象属性中包含了Throwable类型的属性时，在反序列化时，则会转换错误。 fastjson版本：从1.2.22到1.2.24版本均试过，均存在此类问题。  =================================================== 测试代码case如下： public class DefaultJsonSerializer {      private static final Charset CHARSET = Charset.forName("UTF-8");      public static &lt;T&gt; void serialize(T obj, OutputStream out) {         JSONWriter writer = null;         try {             writer = new JSONWriter(new OutputStreamWriter(out, CHARSET.newEncoder().onMalformedInput(CodingErrorAction.IGNORE)));             writer.config(SerializerFeature.QuoteFieldNames, true);             writer.config(SerializerFeature.SkipTransientField, true);             writer.config(SerializerFeature.SortField, true);             writer.config(SerializerFeature.WriteEnumUsingToString, false);             writer.config(SerializerFeature.WriteClassName, true);             writer.config(SerializerFeature.DisableCircularReferenceDetect, true);             writer.writeObject(obj);             writer.flush();         } catch (Exception e) {             e.printStackTrace();         } finally {             if (writer != null) {                 try {                     writer.close();                 } catch (Exception e) {                 }             }         }     }      public static &lt;T&gt; T deserialize(byte[] in) {         return (T) JSON.parse(in, 0, in.length, CHARSET.newDecoder(), Feature.AllowArbitraryCommas,                 Feature.IgnoreNotMatch, Feature.SortFeidFastMatch, Feature.DisableCircularReferenceDetect,                 Feature.AutoCloseSource);     }  }   //******************      测试代码    ************************* public class Result&lt;T&gt; {     private T data;      private Throwable exception;      public Result(){}      public T getData() {         return data;     }      public void setData(T data) {         this.data = data;     }      public Throwable getException() {         return exception;     }      public void setException(Throwable exception) {         this.exception = exception;     } }  //**************       case       *************** public class ExceptionTest {      public static void main(String[] args) {         NullPointerException exception = new NullPointerException("test");         Result result = new Result();         result.setException(exception);         ByteArrayOutputStream bos = new ByteArrayOutputStream();         try{             DefaultJsonSerializer.serialize(result, bos);             Object object = DefaultJsonSerializer.deserialize(bos.toByteArray());             System.out.println("deserialize result:" + object);         }catch (Throwable e){             e.printStackTrace();         }finally {             try{                 bos.close();             }catch (IOException e){             }         }     } }  //****************  报错如下  **************** com.alibaba.fastjson.JSONException: syntax error at com.alibaba.fastjson.parser.deserializer.ThrowableDeserializer.deserialze(ThrowableDeserializer.java:36) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:530) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:187) at com.alibaba.fastjson.parser.deserializer.DefaultFieldDeserializer.parseField(DefaultFieldDeserializer.java:62) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:547) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:187) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:183) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:355) at com.alibaba.fastjson.parser.DefaultJSONParser.parse(DefaultJSONParser.java:1312) at com.alibaba.fastjson.parser.DefaultJSONParser.parse(DefaultJSONParser.java:1278) at com.alibaba.fastjson.JSON.parse(JSON.java:178) at com.alibaba.fastjson.JSON.parse(JSON.java:162) at tesla.client.test.json.DefaultJsonSerializer.deserialize(DefaultJsonSerializer.java:45) at tesla.client.test.json.ExceptionTest.main(ExceptionTest.java:18) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)  //************     分割线     *************** 请@wenshao 等其他fastjson的作者伙伴们帮忙看看，谢谢。</body>
		<created>2017-02-24 07:40:26</created>
		<closed>2017-03-09 14:11:46</closed>
	</bug>
	<bug>
		<id>1035</id>
		<title>类继承关系&gt;=5时，Android版的首次解析速度非常慢</title>
		<body>经测试，从1.1.47版本往上的所有版本都会存在这个问题。  例子：  class E extends D class D extends C class C extends B class B extends A class A  E data = JSON.parseObject(jsonString, E.class);</body>
		<created>2017-02-23 09:16:57</created>
		<closed>2017-05-02 15:21:40</closed>
	</bug>
	<bug>
		<id>1030</id>
		<title>通过Fastjson的jsonpath得到的数据与jayway官方JsonPath得到数据不一样</title>
		<body>场景是这样，有一个多层array结构的文档，现在需要获取最底层的array的元素。代码如下 ```     public static void main(String[] args) {         String DOC = "{\"books\":[{\"pageWords\":[{\"num\":10},{\"num\":15}]},{\"pageWords\":[{\"num\":20}]}]}";          //fastjson包         JSONObject result = JSONObject.parseObject(DOC);         Object eval = JSONPath.eval(result, "$.books[0:].pageWords[0:]");         System.out.println(JSONObject.toJSONString(eval));          //jayway包         DocumentContext parse = JsonPath.parse(DOC);         Object read = parse.read("$.books[0:].pageWords[0:]");         System.out.println(read.toString());     } ``` 结果： ``` [[{"num":10},{"num":15}],[{"num":20}]] [{"num":10},{"num":15},{"num":20}] ``` 两个的path都一样，结果却不同，我需要的下面那种结果，然后fastjson是需要开启什么配置么？</body>
		<created>2017-02-20 07:34:06</created>
		<closed>2017-03-16 11:50:05</closed>
	</bug>
	<bug>
		<id>1028</id>
		<title>json串里面同时出现id和_id时，对应的java属性id值为后出现的id，可能会使用_id的值</title>
		<body>```java import com.alibaba.fastjson.JSON;  public class JsonTestMain {      public static void main(String[] args) {          String json = "{\"val\":\"val\", \"_v_al\":\"_v_al\"}";         Value parseObject = JSON.parseObject(json, Value.class);         System.out.println(parseObject.val);      }      public static class Value {         String val;          public String getVal() {             return val;         }          public void setVal(String val) {             this.val = val;         }      } } ```  输出：`_v_al`  版本：1.2.24  代码：com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.smartMatch(String)  问题：感觉应该在同时出现的时候，取最佳的匹配，还有去掉_和-是啥场景的需求的。</body>
		<created>2017-02-17 06:36:59</created>
		<closed>2018-07-04 03:39:04</closed>
	</bug>
	<bug>
		<id>1020</id>
		<title>error in Jdk8DateCodec with empty string or null</title>
		<body>```java String json="{\"ld\":\"\"}" ; or String json="{\"ld\":null}"  Vo vo = JSON.parseObject(json, Vo.class); class Vo{ private LocalDate ld; get.. set .. } ```</body>
		<created>2017-02-13 08:52:43</created>
		<closed>2017-03-16 11:49:15</closed>
	</bug>
	<bug>
		<id>1004</id>
		<title>读取readstring,时报了src.length=8192 srcPos=-1 dst.length=8192 dstPos=0 length=8192. </title>
		<body></body>
		<created>2017-01-18 08:03:57</created>
		<closed>2017-07-16 05:05:37</closed>
	</bug>
	<bug>
		<id>998</id>
		<title>kotlin中使用泛型解析的问题</title>
		<body>kotlin中使用TypeReference解析数据的时候无法正确的解析.在相同的代码中 java代码是可以解析的.  版本 : 1.2.22 java代码 ``` java   @Test     public void test() {         File file = new File("d:\\Develop\\Android\\Projects\\cfzx素材\\city\\a.json ");         String s = FilesKt.readText(file, Charset.forName("UTF-8"));         List&lt;Address&gt; addresses = JSON.parseObject(s, new TypeReference&lt;List&lt;Address&gt;&gt;() {         });         System.out.println(addresses);     } ``` 结果正确解析了 ![javaresult](http://ww4.sinaimg.cn/mw690/006gkUyGgw1fbsk4rd6l8j30or08p74i.jpg) kotlin代码 ```kotlin     @Test     fun test3() {         val file = File("d:\\Develop\\Android\\Projects\\cfzx素材\\city\\a.json ")         val s = file.readText()         val addresses = JSON.parseObject(s, object : TypeReference&lt;List&lt;Address&gt;&gt;() {         })         println(addresses)     } ``` 结果解析失败 ![ktreult](http://ww3.sinaimg.cn/mw690/006gkUyGgw1fbsk6qdpxpj30dx06pwet.jpg)  实体类 ```kotlin package com.cfzx.api.util;  class Address {        constructor()     /**      * name : 北京      * code : 100000      * cityArr : [{"name":"北京市","code":"110000","areaArr":[{"name":"朝阳区","code":"110105"},{"name":"海淀区","code":"110108"},{"name":"东城区","code":"110101"},{"name":"西城区","code":"110102"},{"name":"石景山区","code":"110107"},{"name":"丰台区","code":"110106"},{"name":"通州区","code":"110112"},{"name":"昌平区","code":"110114"},{"name":"大兴区","code":"110115"},{"name":"怀柔区","code":"110116"},{"name":"顺义区","code":"110113"},{"name":"平谷区","code":"110117"},{"name":"房山区","code":"110111"},{"name":"门头沟区","code":"110109"},{"name":"密云县","code":"110228"},{"name":"延庆县","code":"110229"}]}]      */      var name: String? = null     var code: String? = null     /**      * name : 北京市      * code : 110000      * areaArr : [{"name":"朝阳区","code":"110105"},{"name":"海淀区","code":"110108"},{"name":"东城区","code":"110101"},{"name":"西城区","code":"110102"},{"name":"石景山区","code":"110107"},{"name":"丰台区","code":"110106"},{"name":"通州区","code":"110112"},{"name":"昌平区","code":"110114"},{"name":"大兴区","code":"110115"},{"name":"怀柔区","code":"110116"},{"name":"顺义区","code":"110113"},{"name":"平谷区","code":"110117"},{"name":"房山区","code":"110111"},{"name":"门头沟区","code":"110109"},{"name":"密云县","code":"110228"},{"name":"延庆县","code":"110229"}]      */      var cityArr: List&lt;CityArrBean&gt; = mutableListOf()       class CityArrBean {         var name: String? = null         var code: String? = null         /**          * name : 朝阳区          * code : 110105          */          var areaArr: List&lt;AreaArrBean&gt; = mutableListOf()          class AreaArrBean {             var name: String? = null             var code: String? = null         }     }   } ``` 数据 ```json [     {         "name": "北京",         "code": "100000",         "cityArr": [             {                 "name": "北京市",                 "code": "110000",                 "areaArr": [                     {                         "name": "朝阳区",                         "code": "110105"                     },                     {                         "name": "海淀区",                         "code": "110108"                     },                     {                         "name": "东城区",                         "code": "110101"                     },                     {                         "name": "西城区",                         "code": "110102"                     },                     {                         "name": "石景山区",                         "code": "110107"                     },                     {                         "name": "丰台区",                         "code": "110106"                     },                     {                         "name": "通州区",                         "code": "110112"                     },                     {                         "name": "昌平区",                         "code": "110114"                     },                     {                         "name": "大兴区",                         "code": "110115"                     },                     {                         "name": "怀柔区",                         "code": "110116"                     },                     {                         "name": "顺义区",                         "code": "110113"                     },                     {                         "name": "平谷区",                         "code": "110117"                     },                     {                         "name": "房山区",                         "code": "110111"                     },                     {                         "name": "门头沟区",                         "code": "110109"                     },                     {                         "name": "密云县",                         "code": "110228"                     },                     {                         "name": "延庆县",                         "code": "110229"                     }                 ]             }         ]     } ] ```  目前追踪到: /com/alibaba/fastjson/JSON.java:339 行 参数clazz kotlin 参数为 : java.util.List&lt;? extends com.cfzx.api.util.Address&gt; java 参数为: java.util.List&lt;com.cfzx.api.util.Address&gt; 导致的问题   </body>
		<created>2017-01-16 08:48:15</created>
		<closed>2017-01-20 05:59:49</closed>
	</bug>
	<bug>
		<id>995</id>
		<title>用jsonpath替换字符串中的值时，如果成员变量是类A，但是这个类没有被初始化，那么替换类A的成员时会报异常</title>
		<body>版本1.2.16、1.2.23均有该问题  异常如下： java.lang.IllegalArgumentException: argument type mismatch   at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)   at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)   at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)   at java.lang.reflect.Method.invoke(Method.java:498)   at com.alibaba.fastjson.parser.deserializer.FieldDeserializer.setValue(FieldDeserializer.java:90)   at com.alibaba.fastjson.JSONPath.setPropertyValue(JSONPath.java:2254)   at com.alibaba.fastjson.JSONPath$PropertySegement.setValue(JSONPath.java:1298)   at com.alibaba.fastjson.JSONPath.set(JSONPath.java:284)   at com.alibaba.fastjson.JSONPath.set(JSONPath.java:349)  测试代码如下：     public void test() {         Person per = new Person();         System.out.println("原生Person：" + per.toString());         String path = "$.nose.name";         String value = "noseName";         Object obj = value;         JSONPath.set(per, path, obj);     }</body>
		<created>2017-01-13 13:04:44</created>
		<closed>2017-01-19 06:31:28</closed>
	</bug>
	<bug>
		<id>989</id>
		<title>serializeUsing在接口类型的字段上的问题</title>
		<body>下面getMyObject方法获取的是同样内容个对象，区别是一个用HashMap一个用TreeMap。但第二次序列化的时候将不会用serializeUsing中指定的类去序列化  public class Mock {  @Test public void test() { Assert.assertEquals(     JSON.toJSONString(getMyObject(new HashMap&lt;String, Name&gt;())),     JSON.toJSONString(getMyObject(new TreeMap&lt;String, Name&gt;())) ); }  private static MyObject getMyObject(Map&lt;String, Name&gt; names) { MyObject mapObj = new MyObject(); mapObj.setNames(names); Name name = new Name(); name.setFirst("foo"); name.setSecond("boo"); names.put("mock", name); return mapObj; }  public static class NameMapCodec implements ObjectSerializer {  @Override public void write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, int features) throws IOException { JSONObject names = new JSONObject(); for(Map.Entry&lt;String, Name&gt; entry : ((Map&lt;String, Name&gt;)object).entrySet()) { Name name = entry.getValue(); names.put(entry.getKey(), name.getFirst() + ":" + name.getSecond()); } MapSerializer.instance.write(serializer, names, fieldName, JSONObject.class, features); }  }  public static class MyObject {  @JSONField(serializeUsing = NameMapCodec.class) private Map&lt;String, Name&gt; names;  public Map&lt;String, Name&gt; getNames() { return names; }  public void setNames(Map&lt;String, Name&gt; names) { this.names = names; }  }  private static class Name {  private String first;  private String second;  public String getFirst() { return first; }  public void setFirst(String first) { this.first = first; }  public String getSecond() { return second; }  public void setSecond(String second) { this.second = second; } }  }  貌似问题处在FieldSerializer中          Class&lt;?&gt; valueClass = propertyValue.getClass();         ObjectSerializer valueSerializer;         if (valueClass == runtimeInfo.runtimeFieldClass) {             valueSerializer = runtimeInfo.fieldSerializer;         } else {             valueSerializer = serializer.getObjectWriter(valueClass);         }  runtimeInfo会缓存第一次序列化时候的类型即HashMap，第二次TreeMap将进入else中。</body>
		<created>2017-01-09 06:26:14</created>
		<closed>2017-01-19 06:31:21</closed>
	</bug>
	<bug>
		<id>987</id>
		<title> com.alibaba.fastjson.JSONException: Invalid long: "2016-11-10T11:40:42.4Z"</title>
		<body>在retrofit使用.addConverterFactory(FastJsonConverterFactory.create())出现的问题 解析字段 "createdAt": "2016-11-09T09:57:20.445Z"，当Z前为三位时可以解析，如果为一位则解析失败报异常。 即使在字段上加上注解也没用@JSONField(format = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'") </body>
		<created>2017-01-08 09:59:42</created>
		<closed>2017-01-15 04:54:37</closed>
	</bug>
	<bug>
		<id>980</id>
		<title>ZonedDateTime反序列化报错</title>
		<body>我清楚如果不涉及到跨时区，用LocalDateTime会更容易，但是现有系统设计时就用了ZonedDateTime  ```java public class VO{     @JSONField(format="yyyy-MM-dd HH:mm:ss")     private ZonedDateTime modifyTime=ZonedDateTime .now();     //...getter/setter } System.err.println(JSON.toJSONString(new VO())); //{"modifyTime": "2017-01-04 13:21:39"} 输出的是东八区，也就是按照@JSONField输出本地时区的日期时间 ```  但是反序列化就不行了  ```java  JSON.parseObject("{'modifyTime': '2017-01-04 13:21:39'}", VO.class);  Exception in thread "main" com.alibaba.fastjson.JSONException: Text '2017-01-04 13:21:39' could not be parsed at index 10 at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:643) at com.alibaba.fastjson.JSON.parseObject(JSON.java:339) at com.alibaba.fastjson.JSON.parseObject(JSON.java:243) at com.alibaba.fastjson.JSON.parseObject(JSON.java:456) at demo.main(demo.java:179) Caused by: java.time.format.DateTimeParseException: Text '2017-01-04 13:21:39' could not be parsed at index 10 at java.time.format.DateTimeFormatter.parseResolved0(DateTimeFormatter.java:1949) at java.time.format.DateTimeFormatter.parse(DateTimeFormatter.java:1851) at java.time.ZonedDateTime.parse(ZonedDateTime.java:597) at java.time.ZonedDateTime.parse(ZonedDateTime.java:582) at com.alibaba.fastjson.parser.deserializer.Jdk8DateCodec.deserialze(Jdk8DateCodec.java:95) at com.alibaba.fastjson.parser.deserializer.DefaultFieldDeserializer.parseField(DefaultFieldDeserializer.java:66) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.parseField(JavaBeanDeserializer.java:722) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:568) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:187) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:183) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:639) ... 4 more ``` JSON.parseObject("{'modifyTime': '2017-01-04 13:21:39'}", Appointment.class);  https://github.com/alibaba/fastjson/blob/master/src/main/java/com/alibaba/fastjson/parser/deserializer/Jdk8DateCodec.java#L64-L97  在Jdk8DateCodec中只对LocalDateTime进行了特殊处理，ZonedDateTime仅仅是ZonedDateTime.parse(text);  需要传入 类似 `2017-01-04T13:21:39.005+08:00[Asia/Shanghai]` 格式的才行，否则统统异常   jackson可以注册一个全局的类型，进行处理  ```java @Configuration public class JacksonConfiguration {      public static final DateTimeFormatter ISO_FIXED_FORMAT =         DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").withZone(ZoneId.of("Asia/Shanghai"));      @Bean     public Jackson2ObjectMapperBuilderCustomizer jacksonCustomizer() {     ObjectMapper objectMapper=new ObjectMapper();     objectMapper.registerModule(new JavaTimeModule());         return jackson2ObjectMapperBuilder -&gt; jackson2ObjectMapperBuilder.serializers(new ZonedDateTimeSerializer(ISO_FIXED_FORMAT));     } } ```  在FastJson中有 JSON.parseObject(input, clazz, config, features)方法进行处理，但是，  ```java ParserConfig config=new ParserConfig(); config.getDerializers().put(ZonedDateTime.class,  DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").withZone(ZoneId.of("Asia/Shanghai"))); ``` 会报错，因为，value是ObjectDeserializer类型的  </body>
		<created>2017-01-04 05:37:31</created>
		<closed>2017-01-11 06:13:02</closed>
	</bug>
	<bug>
		<id>978</id>
		<title>toJSON和toJSONString的问题。</title>
		<body>三个属性 @JSONField(format="yyyy-MM-dd HH:mm:ss") private Date createTime  @JSONField(serialize = false); private String password;  private String email;  使用toJSON输出{"createTime":1483413683714,"email":"eee"} 使用toJSONString输出{"createTime":"2017-01-03 11:21:23","email":"eee"}  为什么format对toJSON不起作用呢</body>
		<created>2017-01-03 03:38:56</created>
		<closed>2017-01-19 06:32:48</closed>
	</bug>
	<bug>
		<id>963</id>
		<title>反序列化失败注解参数deserializeUsing无效</title>
		<body>public class MainTest {  @Test public void test() { Mock mock = JSON.parseObject("{\"type\":\"boolean\"}", Mock.class); Assert.assertEquals(EnumType.BOOLEAN, mock.getType()); }  public enum EnumType { BOOLEAN; @Override public String toString() { return name().toLowerCase(); } }  public static class Mock {  @JSONField(serializeUsing = EnumTypeCodec.class, deserializeUsing = EnumTypeCodec.class) private EnumType type;  public EnumType getType() { return type; }  public void setType(EnumType type) { this.type = type; } }  public static class EnumTypeCodec implements ObjectSerializer, ObjectDeserializer {  @Override public &lt;T&gt; T deserialze(DefaultJSONParser parser, Type type, Object fieldName) { String uncasedSensitive = StringCodec.instance.deserialze(parser, type, fieldName); return (T) EnumType.valueOf(uncasedSensitive.toUpperCase()); }  @Override public int getFastMatchToken() { return JSONToken.LITERAL_STRING; }  @Override public void write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, int features) throws IOException { SerializeWriter out = serializer.out; if (object == null) { out.writeNull(); return; } StringCodec.instance.write(serializer, ((EnumType) object).name().toLowerCase(), fieldName, fieldType, features); }  } }</body>
		<created>2016-12-21 04:43:56</created>
		<closed>2017-01-19 06:32:37</closed>
	</bug>
	<bug>
		<id>955</id>
		<title>JSONPOJOBuilder does not work when using JSONObject / JSONArray.getObject</title>
		<body>&gt; 测试用例  ```java      private Art makeOrigin() {         final long unixTime = System.currentTimeMillis() / 1000;         final Art origin = new Art();         origin.id = "12";         origin.date = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault()).format(new Date(unixTime * 1000));         origin.isSupported = true;         return origin;     }      @Test     public void checkObject() {         Art origin = makeOrigin();         JSONObject articleObj = (JSONObject) JSON.toJSON(origin);          JSONObject dataObj = new JSONObject();         dataObj.put("art", articleObj);          Art other = dataObj.getObject("art", Art.class);// return null;         assertSame(origin, other); // test failed     }      @Test     public void checkArray() throws Exception {         Art origin = makeOrigin();         JSONObject object = (JSONObject) JSON.toJSON(origin);          JSONArray jsonArray = new JSONArray();         jsonArray.add(object);          Art other = JSON.parseObject(jsonArray.getString(0), Art.class);         assertSame(origin, other); // test passed          other = jsonArray.getObject(0, Art.class); // return = null;         assertSame(origin, other); // test failed     }      public void assertSame(@NonNull Art origin, Art another) {         Assert.assertNotNull(another);         Assert.assertEquals(origin.id, another.id);         Assert.assertEquals(origin.date, another.date);         Assert.assertSame(origin.isSupported, another.isSupported);     }      @JSONType(builder = Art.Builder.class)     public static class Art {         private String id;         private String date;         private boolean isSupported;          public String getId() {             return id;         }          public long getDatetime() throws ParseException {             SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault());             return (format.parse(date)).getTime() / 1000;         }          @JSONField(name = "isSupported")         public int isSupported() {             return isSupported ? 1 : 0;         }          @JSONPOJOBuilder()         public final static class Builder {             private final Art article = new Art();              @JSONField(name = "id")             public Builder withId(String id) {                 article.id = id;                 return this;             }              @JSONField(name = "datetime")             public Builder withDateTime(long dateTime) {                 if (dateTime &gt; 0)                     article.date = new SimpleDateFormat("yyyy-MM-dd", Locale.getDefault()).format(new Date(dateTime * 1000));                 return this;              }              @JSONField(name = "isSupported")             public Builder withSupported(int supported) {                 article.isSupported = supported == 1;                 return this;             }              public Art build() {                 return article;             }         }     } ```</body>
		<created>2016-12-14 08:42:51</created>
		<closed>2016-12-20 02:06:52</closed>
	</bug>
	<bug>
		<id>952</id>
		<title>JDK8的LocalDateTime字段序列化不支持UseISO8601DateFormat</title>
		<body>使用版本：1.2.22 序列化VO对象中包含LocalDateTime，设置参数UseISO8601DateFormat 输出结果为：yyyy-MM-dd HH:mm:ss 期望结果为：yyyy-MM-dd'T'HH:mm:ss </body>
		<created>2016-12-13 08:49:14</created>
		<closed>2016-12-20 02:07:34</closed>
	</bug>
	<bug>
		<id>948</id>
		<title>1.2.22版本，Jdk8DateCodec里面的格式化格式不生效</title>
		<body>fastjson 1.2.22版本 Jdk8DateCodec.java  LocalDateTime dateTime = (LocalDateTime) object;                 if (dateTime.getNano() == 0) {                     String format = serializer.getDateFormatPattern();                     if (format == null) {                         format = JSON.DEFFAULT_DATE_FORMAT;                     }                     write(out, dateTime, format);                 } else {                     out.writeString(object.toString());                 }  看 这里是 dateTime.getNano() == 0 才会进行format处理，LocalDateTime.now()产生的时间，都是不成立的，所以在toString时，即使是这样设置，都不会生效：  @Override     public String toString() {         return JSON.toJSONStringWithDateFormat(this,"yyyy-MM-dd HH:mm:ss:SSS",                 SerializerFeature.DisableCircularReferenceDetect);     }  按理纳秒都要能处理啊。 ![image](https://cloud.githubusercontent.com/assets/563838/21089512/94fd7324-c073-11e6-88d0-e57b25ca1d9f.png) </body>
		<created>2016-12-12 05:58:54</created>
		<closed>2016-12-20 02:07:01</closed>
	</bug>
	<bug>
		<id>942</id>
		<title>fastjson在序列化JDK8的LocalDateTime是,无法设置日期格式.</title>
		<body>使用的是 1.2.21  这个版本.   不管我设不设置 `SerializerFeature.WriteDateUseDateFormat` 或者调用`JSON.toJSONStringWithDateFormat` 都没有其效果. 最后生成的JSON还是 LocalDateTime.toString 的样式.   翻了一下源码. 发现  ``` Jdk8DateCodec#write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType,                       int features) ``` 这个类.  在直接调用 `JSON.toJSONStringWithDateFormat(LocalDateTime.now())`的时候,传入的`fieldType`为null,导致走到 `out.writeString(object.toString());` 去了. 从而生成的json为LocalDateTime.toString的格式.  而如果是在一个JAVABean中有LocalDateTime字段,进行序列化的时候. 传入的fieldType是正常的`LocalDateTime.class` .  但是  `if (dateTime.getNano() == 0) ` 这句过不到,导致还是走到`out.writeString(object.toString());`中去了.从而生成的json为LocalDateTime.toString的格式. 不大理解 `if (dateTime.getNano() == 0) `这句话在这的目的是什么~ 只要我实例化LocalDateTime的时候使用`LocalDateTime.now().withNano(0)` 就可以格式化时间了. 谢谢!</body>
		<created>2016-12-08 03:30:19</created>
		<closed>2016-12-20 02:06:31</closed>
	</bug>
	<bug>
		<id>939</id>
		<title>带注释的json反序列化失败</title>
		<body>```java { "isDebug":true/*调试状态*/ } ``` github星号显示不出来</body>
		<created>2016-12-07 09:52:33</created>
		<closed>2016-12-20 02:06:43</closed>
	</bug>
	<bug>
		<id>918</id>
		<title>使用fastjson1.2.21时，在反序列化泛型对象类型时会报NullPointerException的错误</title>
		<body>环境说明： jdk：1.8 fastjson：1.2.21  能够重现的case程序如下： ### 序列化执行类 ```java public class JsonSerializer {     private static final String NAMESPACE = "teslaSpace";     private static final Charset CHARSET = Charset.forName("UTF-8");      public static &lt;T&gt; void serialize(T obj, OutputStream out) {         setTeslaJson();         JSONWriter writer = null;         try {             writer = new JSONWriter(new OutputStreamWriter(out, CHARSET.newEncoder().onMalformedInput(CodingErrorAction.IGNORE)));             writer.config(SerializerFeature.QuoteFieldNames, true);             writer.config(SerializerFeature.SkipTransientField, true);             writer.config(SerializerFeature.SortField, true);             writer.config(SerializerFeature.WriteEnumUsingToString, false);             writer.config(SerializerFeature.WriteClassName, true);             writer.config(SerializerFeature.DisableCircularReferenceDetect, true);             writer.writeObject(obj);             writer.flush();         } catch (Exception e) {             e.printStackTrace();         } finally {             if (writer != null) {                 try {                     writer.close();                 } catch (Exception e) {                 }             }         }     }      public static &lt;T&gt; T deserialize(byte[] in) {         setTeslaJson();         return (T) JSON.parse(in, 0, in.length, CHARSET.newDecoder(), Feature.AllowArbitraryCommas,                 Feature.IgnoreNotMatch, Feature.SortFeidFastMatch, Feature.DisableCircularReferenceDetect,                 Feature.AutoCloseSource);     }       private static void setTeslaJson() {         if (!JSON.DEFAULT_TYPE_KEY.equals(NAMESPACE)) {             JSON.setDefaultTypeKey(NAMESPACE);         }         if (!SerializeConfig.globalInstance.getTypeKey().equals(NAMESPACE)){             SerializeConfig.globalInstance.setTypeKey(NAMESPACE);         }     }  }  ### 对象类如下： public class Person {     private String name;     private Integer age;      public Person(){}      public Person(String name, Integer age){         this.name = name;         this.age = age;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public Integer getAge() {         return age;     }      public void setAge(Integer age) {         this.age = age;     }      @Override     public String toString() {         return "Person{" +                 "name='" + name + '\'' +                 ", age=" + age +                 '}';     } }  public class Result&lt;&lt;TYPE&gt;&gt; {//假设泛型类型为TYPE, github页面样式错误，不能显示出     private TYPE data;      public Result(){}      public TYPE getData() {         return data;     }      public void setData(TYPE data) {         this.data = data;     } }  public class ApiResponse&lt;&lt;TYPE&gt;&gt; {//假设泛型类型为TYPE, github页面样式错误，不能显示出     private Result&lt;&lt;TYPE&gt;&gt; result; //假设泛型类型为TYPE, github页面样式错误，不能显示出      public ApiResponse(){}      public Result&lt;TYPE&gt; getResult() {         return result;     }      public void setResult(Result&lt;TYPE&gt; result) {         this.result = result;     } }  ### 测试类如下： public class JsonSerialTest {      public static void main(String[] args) {         try{             Person person = new Person("test1", 10);             serialTest(person);              ApiResponse&lt;Object&gt; apiResponse = new ApiResponse&lt;Object&gt;();             Result&lt;Object&gt; result = new Result&lt;Object&gt;();             result.setData(new Object());             apiResponse.setResult(result);              serialTest(apiResponse);          }catch (Throwable e){             e.printStackTrace();         }     }      private static void serialTest(Object object){         ByteArrayOutputStream bos = new ByteArrayOutputStream();         try{             JsonSerializer.serialize(object, bos);              Object desRes = JsonSerializer.deserialize(bos.toByteArray());             System.out.println("反序列化的结果为:" + desRes);         }finally {             try{                 bos.close();             }catch (IOException e){             }         }     } } ```  ##  程序输出结果如下： 反序列化的结果为:Person{name='test1', age=10} java.lang.NullPointerException at com.alibaba.fastjson.parser.deserializer.DefaultFieldDeserializer.parseField(DefaultFieldDeserializer.java:51) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.parseField(JavaBeanDeserializer.java:689) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:570) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:189) at com.alibaba.fastjson.parser.deserializer.DefaultFieldDeserializer.parseField(DefaultFieldDeserializer.java:60) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:549) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:189) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:185) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:355) at com.alibaba.fastjson.parser.DefaultJSONParser.parse(DefaultJSONParser.java:1309) at com.alibaba.fastjson.parser.DefaultJSONParser.parse(DefaultJSONParser.java:1275) at com.alibaba.fastjson.JSON.parse(JSON.java:178) at com.alibaba.fastjson.JSON.parse(JSON.java:162) at tesla.client.test.json.JsonSerializer.deserialize(JsonSerializer.java:49) at tesla.client.test.json.JsonSerialTest.serialTest(JsonSerialTest.java:34) at tesla.client.test.json.JsonSerialTest.main(JsonSerialTest.java:22) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)  请@wenshao 帮忙查看，非常感谢！！</body>
		<created>2016-11-23 11:41:13</created>
		<closed>2016-12-10 07:06:02</closed>
	</bug>
	<bug>
		<id>912</id>
		<title>多层嵌套基本类型数组反序列化时报空指针异常</title>
		<body>数据结构如下： JsonBean下面有一个List&lt;SCFMethod&gt;,  SCFMethod对象中又有一个List&lt;SCFParameter&gt;对象 SCFParameter中有一个Class&lt;?&gt; clazz clazz为一个基本类型数组，如int[], float[], short[],double[],long[],byte[],char[] 反序列化时报错： java.lang.reflect.InvocationTargetException at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at com.wf.mvc.invoke.ActionInvoker.invoke(ActionInvoker.java:76) at com.wf.mvc.MvcDispatcher.service(MvcDispatcher.java:121) at com.wf.mvc.MvcFilter.doFilter(MvcFilter.java:67) at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1482) at org.jasig.cas.client.util.AssertionThreadLocalFilter.doFilter(AssertionThreadLocalFilter.java:50) at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1482) at org.jasig.cas.client.util.HttpServletRequestWrapperFilter.doFilter(HttpServletRequestWrapperFilter.java:71) at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1482) at com.sso.client.AbstractTicketValidationFilter.doFilter(AbstractTicketValidationFilter.java:258) at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1482) at com.sso.client.AuthenticationFilter.doFilter(AuthenticationFilter.java:161) at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1482) at com.sso.client.SingleSignOutFilter.doFilter(SingleSignOutFilter.java:89) at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1482) at com.sso.client.CharacterEncodingFilter.doFilter(CharacterEncodingFilter.java:37) at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1482) at com.sso.session.servlet.filter.session.CacheSessionFilter.doFilter(CacheSessionFilter.java:94) at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1474) at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:499) at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:137) at org.eclipse.jetty.security.SecurityHandler.handle(SecurityHandler.java:557) at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:231) at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1086) at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:428) at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:193) at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1020) at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:135) at org.eclipse.jetty.server.handler.ContextHandlerCollection.handle(ContextHandlerCollection.java:255) at org.eclipse.jetty.server.handler.HandlerCollection.handle(HandlerCollection.java:154) at org.eclipse.jetty.server.handler.HandlerWrapper.handle(HandlerWrapper.java:116) at org.eclipse.jetty.server.Server.handle(Server.java:370) at org.eclipse.jetty.server.AbstractHttpConnection.handleRequest(AbstractHttpConnection.java:489) at org.eclipse.jetty.server.AbstractHttpConnection.content(AbstractHttpConnection.java:960) at org.eclipse.jetty.server.AbstractHttpConnection$RequestHandler.content(AbstractHttpConnection.java:1021) at org.eclipse.jetty.http.HttpParser.parseNext(HttpParser.java:865) at org.eclipse.jetty.http.HttpParser.parseAvailable(HttpParser.java:240) at org.eclipse.jetty.server.AsyncHttpConnection.handle(AsyncHttpConnection.java:82) at org.eclipse.jetty.io.nio.SelectChannelEndPoint.handle(SelectChannelEndPoint.java:668) at org.eclipse.jetty.io.nio.SelectChannelEndPoint$1.run(SelectChannelEndPoint.java:52) at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:608) at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:543) at java.lang.Thread.run(Thread.java:745) Caused by: com.alibaba.fastjson.JSONException at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:625) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:593) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialzeArrayMapping(JavaBeanDeserializer.java:244) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:308) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:189) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:185) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.parseArray(JavaBeanDeserializer.java:895) at com.alibaba.fastjson.parser.deserializer.FastjsonASMDeserializer_2_SCFMethod.deserialzeArrayMapping(Unknown Source) at com.alibaba.fastjson.parser.deserializer.FastjsonASMDeserializer_2_SCFMethod.deserialze(Unknown Source) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:185) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.parseArray(JavaBeanDeserializer.java:895) at com.alibaba.fastjson.parser.deserializer.FastjsonASMDeserializer_1_JsonBean.deserialzeArrayMapping(Unknown Source) at com.alibaba.fastjson.parser.deserializer.FastjsonASMDeserializer_1_JsonBean.deserialze(Unknown Source) at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:185) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:621) at com.alibaba.fastjson.JSON.parseObject(JSON.java:339) at com.alibaba.fastjson.JSON.parseObject(JSON.java:243) at com.tfci.interfaceInfo.GetInterfaceImpl.getJsonData(GetInterfaceImpl.java:378) at com.tfci.controllers.CallJarServiceController.getMethods(CallJarServiceController.java:153) ... 46 more Caused by: java.lang.NullPointerException at java.lang.reflect.Array.newArray(Native Method) at java.lang.reflect.Array.newInstance(Array.java:70) at com.alibaba.fastjson.util.TypeUtils.loadClass(TypeUtils.java:994) at com.alibaba.fastjson.serializer.MiscCodec.deserialze(MiscCodec.java:295) at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:621) ... 64 more  经过分析： 如果是int[]数组，转换成class对象是"[I"，在TypeUtils.java中993行 Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader); 执行完className.substring(1)后为"I", 从而loadClass("I",classLoader)方法时执行到1028行： clazz = Class.forName(className);时由于找不到“I”类而抛了异常，导致反序列化失败； `在源码992行的if中 增加判断if (className.charAt(0) == '[') {         String cls = className.substring(1);         Class&lt;?&gt; componentType;         if(cls.equals("I")){         componentType = loadClass("int", classLoader);         }else if(cls.equals("F")){         componentType = loadClass("float", classLoader);         }else if(cls.equals("S")){         componentType = loadClass("short", classLoader);         }else if(cls.equals("D")){         componentType = loadClass("double", classLoader);         }else if(cls.equals("J")){         componentType = loadClass("long", classLoader);         }else if(cls.equals("B")){         componentType = loadClass("byte", classLoader);         }else if(cls.equals("C")){         componentType = loadClass("char", classLoader);         }else{         componentType = loadClass(className.substring(1), classLoader);         }             return Array.newInstance(componentType, 0).getClass();         }` 反序列化正常通过。 版本：1.2.21 反序列化的字符串为： {"mList":[{"className":"com.qa.scftemplate.contract.ISCFServiceForDyjAction","methodName":"getEntity","parameterSize":1,"parameters":[{"clazz":"java.util.List","clsList":null,"isGenericity":false,"value":""}],"returnType":"com.qa.scftemplate.entity.Entity","url":"tcp://SCFServiceForDyj/SCFServiceForDyjActionService"},{"className":"com.qa.scftemplate.contract.ISCFServiceForDyjAction","methodName":"getMapEntity","parameterSize":2,"parameters":[{"clazz":"java.util.Map","clsList":null,"isGenericity":false,"value":""},{"clazz":"int","clsList":null,"isGenericity":false,"value":""}],"returnType":"java.lang.String","url":"tcp://SCFServiceForDyj/SCFServiceForDyjActionService"},{"className":"com.qa.scftemplate.contract.ISCFServiceForDyjAction","methodName":"getTextString","parameterSize":2,"parameters":[{"clazz":"java.util.List","clsList":null,"isGenericity":false,"value":""},{"clazz":"java.lang.String","clsList":null,"isGenericity":false,"value":""}],"returnType":"java.lang.String","url":"tcp://SCFServiceForDyj/SCFServiceForDyjActionService"},{"className":"com.qa.scftemplate.contract.ISCFServiceForDyjAction","methodName":"getArrayInt","parameterSize":1,"parameters":[{"clazz":"[I","clsList":null,"isGenericity":false,"value":""}],"returnType":"[I","url":"tcp://SCFServiceForDyj/SCFServiceForDyjActionService"},{"className":"com.qa.scftemplate.contract.ISCFServiceForDyjAction","methodName":"getArrayInt","parameterSize":1,"parameters":[{"clazz":"[Ljava.lang.Integer;","clsList":null,"isGenericity":false,"value":""}],"returnType":"[Ljava.lang.Integer;","url":"tcp://SCFServiceForDyj/SCFServiceForDyjActionService"},{"className":"com.qa.scftemplate.contract.ISCFServiceForDyjAction","methodName":"getSetEntity","parameterSize":2,"parameters":[{"clazz":"java.util.Set","clsList":null,"isGenericity":false,"value":""},{"clazz":"int","clsList":null,"isGenericity":false,"value":""}],"returnType":"java.lang.String","url":"tcp://SCFServiceForDyj/SCFServiceForDyjActionService"},{"className":"com.qa.scftemplate.contract.ISCFServiceForDyjAction","methodName":"returnJsonString","parameterSize":1,"parameters":[{"clazz":"com.qa.scftemplate.entity.Entity","clsList":null,"isGenericity":false,"value":""}],"returnType":"java.lang.String","url":"tcp://SCFServiceForDyj/SCFServiceForDyjActionService"},{"className":"com.qa.scftemplate.contract.ISCFServiceForDyjAction","methodName":"getEntityString","parameterSize":1,"parameters":[{"clazz":"java.util.List","clsList":null,"isGenericity":false,"value":""}],"returnType":"java.lang.String","url":"tcp://SCFServiceForDyj/SCFServiceForDyjActionService"},{"className":"com.qa.scftemplate.contract.ISCFServiceForDyjAction","methodName":"getArrayEntity","parameterSize":2,"parameters":[{"clazz":"[Lcom.qa.scftemplate.entity.Entity;","clsList":null,"isGenericity":false,"value":""},{"clazz":"int","clsList":null,"isGenericity":false,"value":""}],"returnType":"[Lcom.qa.scftemplate.entity.Entity;","url":"tcp://SCFServiceForDyj/SCFServiceForDyjActionService"},{"className":"com.qa.scftemplate.contract.ISCFServiceForDyjAction","methodName":"getArrayString","parameterSize":1,"parameters":[{"clazz":"[Ljava.lang.String;","clsList":null,"isGenericity":false,"value":""}],"returnType":"[Ljava.lang.String;","url":"tcp://SCFServiceForDyj/SCFServiceForDyjActionService"},{"className":"com.qa.scftemplate.contract.ISCFServiceForDyjAction","methodName":"getArrayPrimative","parameterSize":7,"parameters":[{"clazz":"[I","clsList":null,"isGenericity":false,"value":""},{"clazz":"[F","clsList":null,"isGenericity":false,"value":""},{"clazz":"[S","clsList":null,"isGenericity":false,"value":""},{"clazz":"[D","clsList":null,"isGenericity":false,"value":""},{"clazz":"[J","clsList":null,"isGenericity":false,"value":""},{"clazz":"[B","clsList":null,"isGenericity":false,"value":""},{"clazz":"[C","clsList":null,"isGenericity":false,"value":""}],"returnType":"[Ljava.lang.String;","url":"tcp://SCFServiceForDyj/SCFServiceForDyjActionService"}]} 请问是不是fastJson中的bug或是我反序列化时需要加什么参数？</body>
		<created>2016-11-21 06:58:19</created>
		<closed>2016-12-10 07:05:00</closed>
	</bug>
	<bug>
		<id>911</id>
		<title>基类的抽象方法的  @JSONField(serialize = false)测试用，作者可以尝试支持一下么。android最新的版本</title>
		<body></body>
		<created>2016-11-19 17:29:41</created>
		<closed>2016-11-20 12:36:51</closed>
	</bug>
	<bug>
		<id>904</id>
		<title>1.2.8以后的BrowserCompatible对丢失精度问题没有彻底解决</title>
		<body>      虽然1.2.8以后可以通过BrowserCompatible来吧长整型序列化成字符串,但是属性类型必须是Long(对象类型),然而我的model中很多都是long基本类型,这样就依然无法用BrowserCompatible转成字符串.        能否给加上基本类型long转为字符串的功能 ? </body>
		<created>2016-11-17 06:39:38</created>
		<closed>2018-05-29 03:17:36</closed>
	</bug>
	<bug>
		<id>887</id>
		<title>JSONField 反序列化Class校验出错</title>
		<body>    public class FooTest {      public static void main(String[] args) {         Foo excepted = new Foo();         excepted.setName("mock");         String json;         System.out.println(json = JSON.toJSONString(excepted, true));         Foo actually = JSON.parseObject(json, Foo.class);         Assert.assertEquals(excepted.getName(), actually.getName());     }      public static class Foo {         @JSONField(name = "foo.name")         private String name;          public String getName() {             return name;         }          public void setName(String name) {             this.name = name;         }     }     }  执行报错，生成反序列化类的时候Class校验出错</body>
		<created>2016-11-08 06:17:23</created>
		<closed>2016-11-10 03:09:23</closed>
	</bug>
	<bug>
		<id>885</id>
		<title>在与eureka同时使用时,导致Jersey无法初始化</title>
		<body>验证了最近几个版本所有的spring-cloud-netflix.   ![screen shot 2016-11-04 at 12 04 41](https://cloud.githubusercontent.com/assets/3760744/19994485/bb6606fa-a289-11e6-85b2-0795d00f01a2.png) </body>
		<created>2016-11-04 04:26:05</created>
		<closed>2016-11-17 12:15:44</closed>
	</bug>
	<bug>
		<id>872</id>
		<title>被代理的ENTITY序列化时，WriteClassName 所序列化的classname不是真实classname</title>
		<body>被代理的ENTITY序列化时，WriteClassName 所序列化的classname不是真实classname； 当下次被反序列化时会报 type not match的错误！  建议在WriteClassName 添加Object的检查，确认是否为被代理的对象。 </body>
		<created>2016-10-25 03:27:31</created>
		<closed>2016-11-12 16:20:24</closed>
	</bug>
	<bug>
		<id>868</id>
		<title>It shall raise exception when value is out of scope</title>
		<body>Given the following program:  ``` java     public static void foo() throws Exception {         String str = String.valueOf(Integer.MAX_VALUE);         short sh = JSON.parseObject(str, short.class);         System.out.println(sh);     } ```  FastJson will return `-1` when the value is out of the scope of `short` type. Suppose it shall raise an exception in such case. </body>
		<created>2016-10-22 07:55:05</created>
		<closed>2016-11-13 05:19:56</closed>
	</bug>
	<bug>
		<id>859</id>
		<title>parse解析超长字符串卡住 但gson不会 </title>
		<body>【字符串太长 无法粘贴 请联系lw89491@alibab.inc.com获取】 </body>
		<created>2016-10-17 02:06:46</created>
		<closed>2016-10-20 06:13:55</closed>
	</bug>
	<bug>
		<id>850</id>
		<title>转义符\出现解析错误</title>
		<body>测试例子  ``` java      @Test     public void test1(){          String b = "^http://m.1688.com/touch/member/login/\\?done=.*";          String c ="{\"a\":\""+b+"\"}";          System.out.println(c);         System.out.println(JSON.parseObject(c));     } ```  抛出异常`unclosed.str.lit`,把\去掉没有问题 </body>
		<created>2016-10-10 02:27:05</created>
		<closed>2016-10-10 05:36:36</closed>
	</bug>
	<bug>
		<id>830</id>
		<title>fastjson序列化异常java.lang.IncompatibleClassChangeError</title>
		<body>在JDK8中，接口MyInterface中有一个default方法，该接口的实现类在被fastjson序列化的时候抛出异常 java.lang.IncompatibleClassChangeError: Found interface com.ins.car.common.dto.ICarInfo, but class was expected </body>
		<created>2016-09-21 09:34:34</created>
		<closed>2016-12-10 06:57:50</closed>
	</bug>
	<bug>
		<id>803</id>
		<title>配合retrofit2使用，泛型解析失败</title>
		<body>{     "code": "200",     "msg": "操作成功",     "token": "",     "data": {         "accept_push": 1,         "items": [             {                 "relation_id": 12462,                 "nickname": "29",                 "gender": 0,                 "grade": 7,                 "signature": "",                 "photo": "http://heixiucrm-test.oss-cn-beijing.aliyuncs.com/robot/1460705770811",                 "accept_push": 1             },             {                 "relation_id": 12463,                 "nickname": "哦1哦1哦1逆袭why",                 "gender": 0,                 "grade": 54,                 "signature": "",                 "photo": "http://heixiu.oss-cn-beijing.aliyuncs.com/1226_head_20160831020021",                 "accept_push": 1             },             {                 "relation_id": 12367,                 "nickname": "去吧🤔",                 "gender": 0,                 "grade": 50,                 "signature": "",                 "photo": "http://heixiu.oss-cn-beijing.aliyuncs.com/test_1269_head_20160824154244",                 "accept_push": 1             },             {                 "relation_id": 12488,                 "nickname": "急急如律令",                 "gender": 0,                 "grade": 52,                 "signature": "",                 "photo": "http://heixiu.oss-cn-beijing.aliyuncs.com/heixiu1396_1471940861545",                 "accept_push": 1             },             {                 "relation_id": 12489,                 "nickname": "每天正能量～誉",                 "gender": 0,                 "grade": 37,                 "signature": "工具了家里",                 "photo": "http://heixiu.oss-cn-beijing.aliyuncs.com/heixiu1628_1471601607282",                 "accept_push": 1             },             {                 "relation_id": 12368,                 "nickname": "拳怕少壮",                 "gender": 0,                 "grade": 56,                 "signature": "无限制",                 "photo": "http://heixiu.oss-cn-beijing.aliyuncs.com/heixiu1914_1472523618816",                 "accept_push": 1             },             {                 "relation_id": 12365,                 "nickname": "666",                 "gender": 0,                 "grade": 58,                 "signature": "",                 "photo": "http://heixiu.oss-cn-beijing.aliyuncs.com/heixiu2440_1471941930217",                 "accept_push": 1             }         ]     } }  这个json格式是合法的。  ``` public class HttpResult&lt;T&gt; {      public String code;     public String msg;     public String token;      public T data; }  public class RecommendBean {     public int accept_push;     public List&lt;ItemsBean&gt; items;      public static class ItemsBean {         public int relation_id;         public int gender;         public int empiric;         public String signature;         public String photo;         public int accept_push;         public int user_id;         public String nickname;//昵称     } } ```  上面那串JSON解析成 `HttpResult&lt;RecommendBean&gt;`，data属性变为了JsonObject，data没有解析成RecommendBean对象  ---  {"code":"200","msg":"","token":"","data":{"liveList":[],"replayList":[]}}  ``` public class LiveAttentionInfo {     public List&lt;LiveList&gt; liveList;     public List&lt;ReplayList&gt; replayList; } ```  这一串JSON的data解析`HttpResult&lt;LiveAttentionInfo&gt;` 同样没有解析成泛型。  ``` compile 'com.alibaba:fastjson:1.1.54.android' ```  解析方法  ``` JSON.parseObject(jsonString, mType, config, featureValues, features != null ? features : EMPTY_SERIALIZER_FEATURES); ```  @wenshao  </body>
		<created>2016-08-31 11:56:58</created>
		<closed>2016-11-20 12:37:58</closed>
	</bug>
	<bug>
		<id>802</id>
		<title>JSONCreator 参数不匹配导致反序列化失败</title>
		<body>服务端返回的JSON当中，有些字段没有返回，导致反序列化失败。以下是构造方法：  ``` java     public CommodityObject(             @JSONField(name = "id") int id,             @JSONField(name = "description") String description,             @JSONField(name = "location") String location,             @JSONField(name = "location_id") int locationId,             @JSONField(name = "park") String park,             @JSONField(name = "park_code") int parkCode,             @JSONField(name = "face_value") int faceValue,             @JSONField(name = "ctime") long createTime,             @JSONField(name = "valid_period") String validPeriod,             @JSONField(name = "title") String title,             @JSONField(name = "type") int type,             @JSONField(name = "ex_type") int exType,             @JSONField(name = "price") int price,             @JSONField(name = "status") int status) { ```  其中`location_id`和`park_code`没有传时会报异常：  ``` Caused by: com.alibaba.fastjson.JSONException: create instance error, public com.parkingwang.sdk.coupon.commodity.CommodityObject(int,java.lang.String,java.lang.String,int,java.lang.String,int,int,long,java.lang.String,java.lang.String,int,int,int,int)     at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:611)     at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:189)     at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:185)     at com.alibaba.fastjson.parser.DefaultJSONParser.parseObject(DefaultJSONParser.java:614)     at com.alibaba.fastjson.JSON.parseObject(JSON.java:339)     at com.alibaba.fastjson.JSON.parseObject(JSON.java:243)     at com.alibaba.fastjson.JSON.parseObject(JSON.java:456)     at com.parkingwang.sdk.coupon.commodity.CommodityObjectParser.parse(CommodityObjectParser.java:13)     at com.parkingwang.sdk.coupon.commodity.CommodityObjectParser.parse(CommodityObjectParser.java:10)     at com.parkingwang.sdk.http.ext.ListResponseConverter.convert(ListResponseConverter.kt:83)     at com.parkingwang.sdk.http.ext.ListResponseConverter.convert(ListResponseConverter.kt:14)     at retrofit2.ServiceMethod.toResponse(ServiceMethod.java:116)     at retrofit2.OkHttpCall.parseResponse(OkHttpCall.java:211)     at retrofit2.OkHttpCall.execute(OkHttpCall.java:174)     at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$CallOnSubscribe.call(RxJavaCallAdapterFactory.java:144)     ... 38 more Caused by: java.lang.IllegalArgumentException     at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)     at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)     at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)     at java.lang.reflect.Constructor.newInstance(Constructor.java:423)     at com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer.deserialze(JavaBeanDeserializer.java:608)     ... 52 more ```  另外，还发现，如果缺少的字段为String时能够正常创建实例，而在上面的例子中为int时创建实例失败。 </body>
		<created>2016-08-31 07:53:21</created>
		<closed>2016-09-05 14:53:03</closed>
	</bug>
	<bug>
		<id>784</id>
		<title>fastjson1.1.52 JSON.parse Exception</title>
		<body>JSON.parse("[{\"args\":[\"150\",\"change\",{\"timeStamp\":1471595047319,\"value\":\"\"},{\"attrs\":{\"value\":\"\"}}],\"method\":\"fireEvent\"}]");  上面这行代码在fastjson1.1.52 抛异常～在第73个字符 </body>
		<created>2016-08-19 10:19:12</created>
		<closed>2016-08-28 11:44:20</closed>
	</bug>
	<bug>
		<id>776</id>
		<title>"{\"v\":[\" \",\"abc\",\"x\",\"abc\"]}" with generic Map&lt;String,char[]&gt; still through parse?</title>
		<body>``` java String str1="{\"v\":[\" \",\"abc\",\"x\",\"abc\"]}"; Map&lt;String, char[]&gt; map = JSON.parseObject(str1, new com.alibaba.fastjson.TypeReference&lt;Map&lt;String, char[]&gt;&gt;() { }); System.out.println(new String(map.get("v"))); ```  and then,it outpputs-&gt;  [" ","abc","x","abc"] Is it right? Actually If the generic is Map&lt;String,String[]&gt; or Map&lt;String,char[][]&gt;,it will correct. </body>
		<created>2016-08-14 03:28:05</created>
		<closed>2016-09-06 03:55:28</closed>
	</bug>
	<bug>
		<id>771</id>
		<title>SerializeWriter may write invalid JSON output when special character is detected in a string</title>
		<body>**While serializing a list to json, buffer expanding may commit some data to buffer while later the special character detection restarts the list serialization which results in invalid json output.**  Tested with fastjson:1.2.15 (Create 2 SEPARATE files in order to reproduce the bug, (not inner class!)) //JSONSpecialCharTest.java:  ``` import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.serializer.SerializeWriter; import com.alibaba.fastjson.serializer.SerializerFeature;  public class JSONSpecialCharTest {     public static void main(String[] args)     {         SerializeWriter writer = new SerializeWriter(null, JSON.DEFAULT_GENERATE_FEATURE, new SerializerFeature[0]);         int defaultBufferSize = writer.getBufferLength();         System.out.println("default buffer size:" + defaultBufferSize);         String encoded = JSON.toJSONString(new FooBar(defaultBufferSize));         try         {             Object decoded = JSON.parse(encoded);             System.out.println("Decoded:\n" + decoded);         } catch (Exception e) {             System.err.println("Unable to decode encoded content _(o.O)_");             e.printStackTrace();         }     } }  ```  //FooBar.java:  ``` import java.util.ArrayList; import java.util.List;  public class FooBar {         private List&lt;String&gt; dataToEncode;         protected FooBar(int buffLen){             dataToEncode = new ArrayList&lt;&gt;();             dataToEncode.add("foo");             dataToEncode.add("bar");             dataToEncode.add(new String(new char[buffLen]).replace('\0','a')); //create some texts to fill up &amp; expand the buffer             dataToEncode.add("a wild special character appears: áőű"); //this will restart the list encoding (while the count is committed at expand)             dataToEncode.add("foobar");         }          public List&lt;String&gt; getDataToEncode()         {             return dataToEncode;         }  }  ```  Output:  ``` default buffer size:2048 Unable to decode encoded content _(o.O)_ com.alibaba.fastjson.JSONException: syntax error, pos 2141, json ...etc ```  This line seems to be the problem for me: https://github.com/alibaba/fastjson/blob/master/src/main/java/com/alibaba/fastjson/serializer/SerializeWriter.java#L1142 </body>
		<created>2016-08-11 23:58:47</created>
		<closed>2016-08-14 17:06:26</closed>
	</bug>
	<bug>
		<id>757</id>
		<title>FastJsonHttpMessageConverter 默认contenttype与老版本不兼容</title>
		<body>请保持兼容  super(new MediaType("application", "json", DEFAULT_CHARSET), new MediaType("application", "*+json", DEFAULT_CHARSET)); 否则返回的content-type有可能在升级后变成非application/json导致前端识别有问题 </body>
		<created>2016-08-05 08:06:54</created>
		<closed>2016-08-14 17:06:08</closed>
	</bug>
	<bug>
		<id>735</id>
		<title>json的key值为字符串类型，但是当只含有数字和.的时候处理有问题</title>
		<body>``` java String a = "{\"key\":\"value\",\"10.0.1.1\":\"haha\"}";          Object x = JSON.parse(a);         JSONPath.set(x, "$.test" , "abc");         Object o = JSONPath.eval(x, "$.10\\.0\\.1\\.1"); ```  异常: Exception in thread "main" java.lang.NumberFormatException: For input string: "10.0.1.1" </body>
		<created>2016-07-21 08:54:53</created>
		<closed>2016-07-31 07:41:10</closed>
	</bug>
	<bug>
		<id>685</id>
		<title>A JSONField format Exception occurs in parsing "yyyy-MM-dd'T'HH:mm:ss.SSS"</title>
		<body>- fastjson version：   1.1.52.android - java code：  ``` java @JSONField(format= "yyyy-MM-dd'T'HH:mm:ss.SSS") public Date publishTime; ``` - JSONString：   "publishTime": "2016-06-14T20:59:05.963" - Exception：   com.alibaba.fastjson.JSONException: Unknown pattern character 'T' </body>
		<created>2016-06-22 07:04:34</created>
		<closed>2016-08-28 11:50:39</closed>
	</bug>
	<bug>
		<id>676</id>
		<title>对于enum 类型，ASMDeserializer 的 parse 部分问题</title>
		<body>问题复现： 代码：  ```                String jsonStr = "{\"modelType\":\"\"}";          MenuExpend menuExpend = JSON.parseObject(jsonStr, MenuExpend.class);         System.out.println(menuExpend); ```  中modelType 为 MenuExpend  的field，一个customer 的enum。  这样立即报错。 exception is ：java.lang.IllegalArgumentException: No enum constant   解决思路： 本以为是 EnumDeserializer 的deserialze 方法，经过追踪，却是使用的ASMDeserializer。  `MenuExpend menuExpend = JSON.parseObject(jsonStr, MenuExpend.class,Feature.DisableASM);`  使用如上的代码，并没有禁用掉ASM。  最后在debug 的时候，尝试把ParseConfig 的asmEnable 改为false，使用EnumDeserializer 进行反序列化。反序列话后的 modelType 为null，无异常。  ```  if (token == JSONToken.LITERAL_INT) {                 int intValue = lexer.intValue();                 lexer.nextToken(JSONToken.COMMA);                  if (intValue &lt; 0 || intValue &gt; values.length) {                     throw new JSONException("parse enum " + enumClass.getName() + " error, value : " + intValue);                 }                  return (T) values[intValue];             } else if (token == JSONToken.LITERAL_STRING) {                 String strVal = lexer.stringVal();                 lexer.nextToken(JSONToken.COMMA);                  if (strVal.length() == 0) {                     return (T) null;                 }                  return (T) Enum.valueOf((Class&lt;Enum&gt;) enumClass, strVal);             } else if (token == JSONToken.NULL) {                 value = null;                 lexer.nextToken(JSONToken.COMMA);                  return null;             } else {                 value = parser.parse();             } ```  其中有判断   ``` if (strVal.length() == 0) {                     return (T) null;  } ```  。 那为什么ASM 中无法判断呢。看到ASMDeserializerFactory 中有写 isEnun() 的方法。不过我没看到具体生成的代码是什么。。。。 求作者修正改问题。 </body>
		<created>2016-06-14 04:35:39</created>
		<closed>2016-06-21 14:34:46</closed>
	</bug>
	<bug>
		<id>621</id>
		<title>1.2.11 泛型子类序列化出错</title>
		<body>Caused by: java.lang.VerifyError: (class: com/alibaba/fastjson/serializer/ASMSerializer_3_StringResult, method: writeAsArrayNonContext signature: (Lcom/alibaba/fastjson/serializer/JSONSerializer;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/reflect/Type;I)V) Incompatible argument to function  ``` class StringResult extends Result&lt;String&gt;   StringResult result = new StringResult();         result.setRequestId(requestId);         result.setCode(code);         result.setMessage(message);         return JSONObject.toJSONString(result, SerializerFeature.WriteMapNullValue); ```  at java.lang.Class.getDeclaredConstructors0(Native Method) ~[?:1.7.0_80]     at java.lang.Class.privateGetDeclaredConstructors(Class.java:2595) ~[?:1.7.0_80]     at java.lang.Class.getConstructor0(Class.java:2895) ~[?:1.7.0_80]     at java.lang.Class.newInstance(Class.java:354) ~[?:1.7.0_80]     at com.alibaba.fastjson.serializer.ASMSerializerFactory.createJavaBeanSerializer(ASMSerializerFactory.java:438) ~[fastjson-1.2.11.jar:?]     at com.alibaba.fastjson.serializer.SerializeConfig.createASMSerializer(SerializeConfig.java:99) ~[fastjson-1.2.11.jar:?]     at com.alibaba.fastjson.serializer.SerializeConfig.createJavaBeanSerializer(SerializeConfig.java:137) ~[fastjson-1.2.11.jar:?]     ... 55 more </body>
		<created>2016-05-10 01:10:19</created>
		<closed>2016-05-21 16:03:40</closed>
	</bug>
	<bug>
		<id>429</id>
		<title>feature request: JSON.setCustomTypeKey(String typeKey); additional to JSON.DEFAULT_TYPE_KEY="@type"</title>
		<body>I'd kindly ask you to provide a way to set a custom DEFAULT_TYPE_KEY, in case the backend delivers "class":"com.foo.FooModel"  JSON.setCustomTypeKey(String typeKey);  Also I'd suggest a way to add a "class" (or "@type") mapping. e.g. the backend delivers a generic type like "class":"article" (or "@type":"article") so I need a mapping for "article" =&gt; "com.foo.ArticleModel", "song" =&gt; "com.foo.SongModel", ...  (the background is that namespaces could be different on multiplatform solutions) </body>
		<created>2015-10-18 19:18:52</created>
		<closed>2016-05-21 15:21:00</closed>
	</bug>
</bugs>
