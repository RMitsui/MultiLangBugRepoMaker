<?xml version="1.0" encoding="ISO-8859-1"?>

<bugs>
	<bug>
		<id>1467</id>
		<title>Excel导入解析，JavaBen中属性为tMallxxxxx，则会无法解析到</title>
		<body>JavaBean中 ` @ExcelProperty("天猫卡券抵扣") private String tMallaaa; `  Excel正常，结果无法将值解析到tMallaaa，但是将属性名改为private String tm;  就正常了。  请问这是啥情况?   **多次尝试后发现   只要属性第一个是小写字母，第二个是大写字母就不行了   比如  tCxxx**  发现ModelBuildEventListener.buildUserModel()方法中BeanMap.create()转化这一步，会把属性tCallBaa转化成TCallBaa</body>
		<created>2020-07-14 09:18:27</created>
		<closed>2020-07-14 11:25:13</closed>
	</bug>
	<bug>
		<id>1461</id>
		<title>Excel导入中，对于字符串null的处理不一致</title>
		<body>Excel中好多列填写值为字符串null，对应的JavaBean的属性也是String。 导入时，用@ExcelProperty注解，对应title名称。 Listener中invoke方法读取到的Bean，有的属性为null，有的属性为"null"。 </body>
		<created>2020-07-10 06:38:41</created>
		<closed>2020-07-14 09:15:50</closed>
	</bug>
	<bug>
		<id>1455</id>
		<title>加了headRowNumber报错</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述**  **触发Bug的代码** ```java     EasyExcel.read(is, listener).headRowNumber(1).sheet(sheetNo).doRead(); ``` **提示的异常或者没有达到的效果** ```java java.lang.NoSuchMethodError: com.alibaba.excel.read.builder.ExcelReaderBuilder.headRowNumber(Ljava/lang/Integer;)Lcom/alibaba/excel/read/builder/AbstractExcelReaderParameterBuilder;  ```` </body>
		<created>2020-07-09 02:30:18</created>
		<closed>2020-07-09 02:41:55</closed>
	</bug>
	<bug>
		<id>1451</id>
		<title>Javassist 动态 写入 @ExcelProperty 并赋值时候，报异常【Incorrectly typed data found for annotation element public abstract java.lang.String[] com.alibaba.excel.annotation.ExcelProperty.value() (Found data of type class java.lang.String[添加的属性---])】</title>
		<body>**触发场景描述**  **触发Bug的代码** ```java     public static void main(String[] args) throws Exception {          // Returns the default class pool.         ClassPool classPool = ClassPool.getDefault();          //Reads a class file from the source and returns a reference to the &lt;code&gt;CtClass&lt;/code&gt;         CtClass testDataClassOfCtClass = classPool.get("com.javapractice.reflection.DynamicModifyClassMyJavassist.TestData");         // Returns a class file for this class.         ClassFile testDataClassFile = testDataClassOfCtClass.getClassFile();         // Returns a constant pool table.         ConstPool constPool = testDataClassFile.getConstPool();          // 需要添加的属性和值         String fieldName = "dynamicAddedFiled", fieldValue = "这个是动态添加的属性值";          // 增加属性，这里仅仅是增加属性字段         String fieldType = fieldValue.getClass().getName (); // 返回值的类型         CtField ctField = new CtField(classPool.get(fieldType),fieldName, testDataClassOfCtClass);         ctField.setModifiers(Modifier.PRIVATE); // 设置字段的编码修饰符         //ctClassOfTestData.addField(ctField);          // 首先创建注解         AnnotationsAttribute annotationsAttribute = new AnnotationsAttribute(constPool, AnnotationsAttribute.visibleTag);         Annotation annotation = new Annotation("com.alibaba.excel.annotation.ExcelProperty", constPool);         annotation.addMemberValue("value", new StringMemberValue("添加的属性---", constPool));         annotationsAttribute.addAnnotation(annotation);          // 在属性上添加注解         ctField.getFieldInfo().addAttribute(annotationsAttribute);          // 将字段添加到class中         testDataClassOfCtClass.addField(ctField);          // 添加方法         CtMethod mthdGet = CtNewMethod.make("public String getDynamicAddedFiled() { return this.dynamicAddedFiled; }", testDataClassOfCtClass);         CtMethod mthdSet = CtNewMethod.make("public void setDynamicAddedFiled(String dynamicAddedFiled) { this.dynamicAddedFiled = dynamicAddedFiled; }", testDataClassOfCtClass);         testDataClassOfCtClass.addMethod(mthdGet);         testDataClassOfCtClass.addMethod(mthdSet);          testDataClassOfCtClass.writeFile();          // 为创建java对象         Class&lt;?&gt; testDataClass = testDataClassOfCtClass.toClass();         testDataClass.getAnnotations();          TestData testData = (TestData)testDataClass.newInstance();         // 给原有属性和动态添加的属性赋值         testData.setStaticField("原有属性的值");         // 给动态添加的属性赋值         //testDataClass.getMethod("setDynamicAddedFiled").invoke(testData,"testestet");         setFieldValue(testData,fieldName,fieldValue);          // 导出excel         List&lt;TestData&gt; list = new ArrayList&lt;TestData&gt;();         list.add(testData);         String fileName = "C:\\Users\\shihui6\\Downloads\\" + System.currentTimeMillis() + "++++++" + ".xlsx";         EasyExcel.write(fileName, testData.getClass()).sheet("动态添加属性").doWrite(list);     }     private static Object setFieldValue(Object object, String fieldName, String val) throws Exception {         Object result = null;         Field fu = object.getClass().getDeclaredField(fieldName); // 获取对象的属性域         // 设置对象属性域的访问属性         fu.setAccessible(true);         // 设置对象属性域的属性值         fu.set(object,val);         // 获取对象属性域的属性值         result = fu.get(object);         return result;     }  ``` **提示的异常或者没有达到的效果** ![image](https://user-images.githubusercontent.com/22722321/86870919-dde82100-c10b-11ea-849f-014fd485d4c2.png) </body>
		<created>2020-07-08 06:19:05</created>
		<closed>2020-07-09 02:01:03</closed>
	</bug>
	<bug>
		<id>1432</id>
		<title>mybatis(plus)注入mapper为空</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** mybatis(plus)注入mapper为空 **触发Bug的代码** ```java public class NoModelDataListener extends AnalysisEventListener&lt;Map&lt;Integer, String&gt;&gt; {     @Autowired     StudentMapper mapper;     private static final int BATCH_COUNT = 3000; ``` **提示的异常或者没有达到的效果** mybatis(plus)注入mapper为空，无法正常使用存取操作</body>
		<created>2020-06-28 10:10:12</created>
		<closed>2020-06-28 13:16:52</closed>
	</bug>
	<bug>
		<id>1422</id>
		<title> 头有空列时，写入Excel报空指针</title>
		<body> **触发场景描述** 头有空列时，合并头报NPE  **触发Bug的代码** ```java package test;  import com.alibaba.excel.EasyExcel; import com.alibaba.excel.ExcelWriter; import org.junit.Test;  import java.util.ArrayList; import java.util.Date; import java.util.List; import java.util.stream.IntStream;  public class TestEasyEcel {      @Test     public void dynamicHeadWrite() {         String fileName = "/Users/feng/temp/dynamicHeadWrite" + System.currentTimeMillis() + ".xlsx";          ExcelWriter excelWriter = EasyExcel.write(fileName).autoCloseStream(Boolean.FALSE).build();         excelWriter.write(dataList(), EasyExcel.writerSheet("模版1").head(headA()).build());         excelWriter.write(dataList(), EasyExcel.writerSheet("模版2").head(headB()).build());         excelWriter.finish();     }      private List&lt;List&lt;String&gt;&gt; headA() {         return head("A");     }      private List&lt;List&lt;String&gt;&gt; headB() {         return head("B");     }      private List&lt;List&lt;String&gt;&gt; head(String name) {         List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;();         IntStream.range(1, 3).forEach(i -&gt; {             List&lt;String&gt; headi = new ArrayList&lt;&gt;();             headi.add(name + i + "字符串");             headi.add(name + i + "数字");             headi.add(name + i + "日期");             headi.add(null);             list.add(headi);         });          /*          * EasyExcel 的设计缺陷          * 行和列的顺序是反的          *          * 所以此处将行和列的顺序互换一下          */         List&lt;List&lt;String&gt;&gt; list2 = new ArrayList&lt;&gt;();         for (int i = 0; i &lt; list.size(); i++) {             List&lt;String&gt; strings = list.get(i);              for (int j = 0; j &lt; strings.size(); j++) {                 String s = strings.get(j);                  if (list2.size() &gt; j &amp;&amp; null != list2.get(j)) {                     List&lt;String&gt; list2arr = list2.get(j);                     list2arr.add(s);                     list2.set(j, list2arr);                 } else {                     List&lt;String&gt; list2arr = new ArrayList&lt;&gt;(list.size());                     list2arr.add(s);                     list2.add(j, list2arr);                 }             }         }          return list2;     }      private List&lt;List&lt;Object&gt;&gt; dataList() {         List&lt;List&lt;Object&gt;&gt; list = new ArrayList&lt;&gt;();         for (int i = 0; i &lt; 10; i++) {             List&lt;Object&gt; data = new ArrayList&lt;&gt;();             data.add("字符串" + i);             data.add(0.56);             data.add(new Date());             data.add(null);             list.add(data);         }         return list;     } }  ``` **提示的异常** ``` java.lang.NullPointerException at com.alibaba.excel.write.property.ExcelWriteHeadProperty.headCellRangeList(ExcelWriteHeadProperty.java:161) at com.alibaba.excel.context.WriteContextImpl.addMergedRegionToCurrentSheet(WriteContextImpl.java:231) at com.alibaba.excel.context.WriteContextImpl.initHead(WriteContextImpl.java:218) at com.alibaba.excel.context.WriteContextImpl.initSheet(WriteContextImpl.java:191) at com.alibaba.excel.context.WriteContextImpl.currentSheet(WriteContextImpl.java:122) at com.alibaba.excel.write.ExcelBuilderImpl.addContent(ExcelBuilderImpl.java:53) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:161) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:146) at test.TestEasyEcel.dynamicHeadWrite(TestEasyEcel.java:19) ```</body>
		<created>2020-06-23 10:22:38</created>
		<closed>2020-06-23 10:43:33</closed>
	</bug>
	<bug>
		<id>1419</id>
		<title>Can not find 'Converter' support class LocalDate</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** LocalDate类型的转换不支持  **触发Bug的代码** ```java @Data @Builder @NoArgsConstructor @AllArgsConstructor public class CatSerialize implements Serializable {     private static final long serialVersionUID = 12345L;     private Integer id;     private String name;     private String kind;     private LocalDate birthday; } List&lt;CatSerialize&gt; cats = new ArrayList(); cats.add(CatSerialize.builder().id(64).kind("橘猫").name("lili").birthday(LocalDate.now()).build()); cats.add(CatSerialize.builder().id(65).kind("橘猫").name("lili").birthday(LocalDate.now()).build()); cats.add(CatSerialize.builder().id(66).kind("橘猫").name("lili").birthday(LocalDate.now()).build());  EasyExcel.write(fileName, CatSerialize.class).sheet("mycat").doWrite(cats()); ``` **提示的异常或者没有达到的效果** Can not find 'Converter' support class LocalDate</body>
		<created>2020-06-23 08:12:29</created>
		<closed>2020-06-23 10:45:35</closed>
	</bug>
	<bug>
		<id>1416</id>
		<title>多表头读取属性为null</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 读取的excel有多表头时 .sheet().head(Test2Model.class) 读取出来属性都是null, .head(Test2Model.class).sheet()  正常读取  **触发Bug的代码** [测试代码](https://github.com/bozer666/easyexcel-test/blob/master/src/test/java/easyexcel/MultipleHeaderTest.java)  **提示的异常或者没有达到的效果** </body>
		<created>2020-06-22 06:42:55</created>
		<closed>2020-06-23 11:43:24</closed>
	</bug>
	<bug>
		<id>1414</id>
		<title>导出时 集合data为空时可以导出 但是文件已经损坏</title>
		<body> **触发场景描述**   导出时 没有查到数据 但还是能够导出 不过导出的文件显示已经损坏 **触发Bug的代码** ```java    这里写代码 ![Uploading image.png…]()  ``` **提示的异常或者没有达到的效果** </body>
		<created>2020-06-20 09:07:00</created>
		<closed>2020-06-23 11:42:28</closed>
	</bug>
	<bug>
		<id>1411</id>
		<title>使用模板写入表格问题</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 本地测试没有问题； 一发布到生产环境就报错； 希望能给看看；  报的错太底层，不知道是哪里引起的； 版本是最新的 2.2.5 **触发Bug的代码** ```java   URLDataSource dataSource = new URLDataSource(new URL(templatePath)); ExcelWriter excelWriter = EasyExcel.write(outputStream).withTemplate(dataSource.getInputStream())                     .registerWriteHandler(new ExcelMergeCellStrategy(info.getExtraList()))                     .excelType(ExcelTypeEnum.XLSX).build(); ``` **提示的异常或者没有达到的效果** 2020-06-18 20:05:39.940 ERROR 1 --- [p-nio-80-exec-4] com.alibaba.excel.util.WorkBookUtil      : null java.lang.NullPointerException: null at sun.awt.FontConfiguration.getVersion(FontConfiguration.java:1264) ~[na:1.8.0_212] at sun.awt.FontConfiguration.readFontConfigFile(FontConfiguration.java:219) ~[na:1.8.0_212] at sun.awt.FontConfiguration.init(FontConfiguration.java:107) ~[na:1.8.0_212] at sun.awt.X11FontManager.createFontConfiguration(X11FontManager.java:774) ~[na:1.8.0_212] at sun.font.SunFontManager$2.run(SunFontManager.java:431) ~[na:1.8.0_212] at java.security.AccessController.doPrivileged(Native Method) ~[na:1.8.0_212] at sun.font.SunFontManager.&lt;init&gt;(SunFontManager.java:376) ~[na:1.8.0_212] at sun.awt.FcFontManager.&lt;init&gt;(FcFontManager.java:35) ~[na:1.8.0_212] at sun.awt.X11FontManager.&lt;init&gt;(X11FontManager.java:57) ~[na:1.8.0_212] at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[na:1.8.0_212] at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) ~[na:1.8.0_212] at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[na:1.8.0_212] at java.lang.reflect.Constructor.newInstance(Constructor.java:423) ~[na:1.8.0_212] at java.lang.Class.newInstance(Class.java:442) ~[na:1.8.0_212] at sun.font.FontManagerFactory$1.run(FontManagerFactory.java:83) ~[na:1.8.0_212] at java.security.AccessController.doPrivileged(Native Method) ~[na:1.8.0_212] at sun.font.FontManagerFactory.getInstance(FontManagerFactory.java:74) ~[na:1.8.0_212] at java.awt.Font.getFont2D(Font.java:491) ~[na:1.8.0_212] at java.awt.Font.canDisplayUpTo(Font.java:2060) ~[na:1.8.0_212] at java.awt.font.TextLayout.singleFont(TextLayout.java:470) ~[na:1.8.0_212] at java.awt.font.TextLayout.&lt;init&gt;(TextLayout.java:531) ~[na:1.8.0_212] at org.apache.poi.ss.util.SheetUtil.getDefaultCharWidth(SheetUtil.java:275) ~[poi-3.17.jar!/:3.17] at org.apache.poi.xssf.streaming.AutoSizeColumnTracker.&lt;init&gt;(AutoSizeColumnTracker.java:117) ~[poi-ooxml-3.17.jar!/:3.17] at org.apache.poi.xssf.streaming.SXSSFSheet.&lt;init&gt;(SXSSFSheet.java:82) ~[poi-ooxml-3.17.jar!/:3.17] at org.apache.poi.xssf.streaming.SXSSFWorkbook.createAndRegisterSXSSFSheet(SXSSFWorkbook.java:658) ~[poi-ooxml-3.17.jar!/:3.17] at org.apache.poi.xssf.streaming.SXSSFWorkbook.&lt;init&gt;(SXSSFWorkbook.java:247) ~[poi-ooxml-3.17.jar!/:3.17] at org.apache.poi.xssf.streaming.SXSSFWorkbook.&lt;init&gt;(SXSSFWorkbook.java:211) ~[poi-ooxml-3.17.jar!/:3.17] at org.apache.poi.xssf.streaming.SXSSFWorkbook.&lt;init&gt;(SXSSFWorkbook.java:186) ~[poi-ooxml-3.17.jar!/:3.17] at com.alibaba.excel.util.WorkBookUtil.createWorkBook(WorkBookUtil.java:44) ~[easyexcel-2.2.8.jar!/:na] at com.alibaba.excel.context.WriteContextImpl.&lt;init&gt;(WriteContextImpl.java:85) [easyexcel-2.2.8.jar!/:na] at com.alibaba.excel.write.ExcelBuilderImpl.&lt;init&gt;(ExcelBuilderImpl.java:35) [easyexcel-2.2.8.jar!/:na] at com.alibaba.excel.ExcelWriter.&lt;init&gt;(ExcelWriter.java:47) [easyexcel-2.2.8.jar!/:na] at com.alibaba.excel.write.builder.ExcelWriterBuilder.build(ExcelWriterBuilder.java:130) [easyexcel-2.2.8.jar!/:na] at cn.com.dxpcloud.edu.resources.service.impl.ResExamPaperServiceImpl.writeTemplate(ResExamPaperServiceImpl.java:594) [classes!/:0.0.1-SNAPSHOT] at cn.com.dxpcloud.edu.resources.service.impl.ResExamPaperServiceImpl.save(ResExamPaperServiceImpl.java:111) [classes!/:0.0.1-SNAPSHOT] at cn.com.dxpcloud.edu.resources.service.impl.ResExamPaperServiceImpl$$FastClassBySpringCGLIB$$20cbbc99.invoke(&lt;generated&gt;) [classes!/:0.0.1-SNAPSHOT] at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) [spring-core-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749) [spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) [spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:295) ~[spring-tx-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:98) ~[spring-tx-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) [spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) ~[spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at cn.com.dxpcloud.edu.resources.service.impl.ResExamPaperServiceImpl$$EnhancerBySpringCGLIB$$c416b253.save(&lt;generated&gt;) ~[classes!/:0.0.1-SNAPSHOT] at cn.com.dxpcloud.edu.resources.controllers.ResExamPaperController.save(ResExamPaperController.java:72) ~[classes!/:0.0.1-SNAPSHOT] at cn.com.dxpcloud.edu.resources.controllers.ResExamPaperController$$FastClassBySpringCGLIB$$2a939a26.invoke(&lt;generated&gt;) ~[classes!/:0.0.1-SNAPSHOT] at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) [spring-core-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749) [spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) [spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88) ~[spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at cn.com.dxpcloud.edu.resources.aop.GlobalLogAspect.around(GlobalLogAspect.java:47) ~[classes!/:0.0.1-SNAPSHOT] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_212] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_212] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_212] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_212] at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644) ~[spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633) ~[spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70) ~[spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) [spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:93) ~[spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) [spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) ~[spring-aop-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at cn.com.dxpcloud.edu.resources.controllers.ResExamPaperController$$EnhancerBySpringCGLIB$$8b084376.save(&lt;generated&gt;) ~[classes!/:0.0.1-SNAPSHOT] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_212] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_212] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_212] at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_212] at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) ~[spring-web-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104) ~[spring-webmvc-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:892) ~[spring-webmvc-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797) ~[spring-webmvc-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1039) ~[spring-webmvc-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) ~[spring-webmvc-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:908) ~[spring-webmvc-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:665) ~[javax.servlet-api-4.0.1.jar!/:4.0.1] at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) ~[spring-webmvc-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at javax.servlet.http.HttpServlet.service(HttpServlet.java:750) ~[javax.servlet-api-4.0.1.jar!/:4.0.1] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.19.jar!/:9.0.19] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at cn.com.dxpcloud.edu.resources.filter.AuthFilter.doFilter(AuthFilter.java:31) ~[classes!/:0.0.1-SNAPSHOT] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.springframework.boot.actuate.web.trace.servlet.HttpTraceFilter.doFilterInternal(HttpTraceFilter.java:90) ~[spring-boot-actuator-2.1.5.RELEASE.jar!/:2.1.5.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.filterAndRecordMetrics(WebMvcMetricsFilter.java:117) ~[spring-boot-actuator-2.1.5.RELEASE.jar!/:2.1.5.RELEASE] at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:106) ~[spring-boot-actuator-2.1.5.RELEASE.jar!/:2.1.5.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.7.RELEASE.jar!/:5.1.7.RELEASE] at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:200) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:836) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1747) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) ~[na:1.8.0_212] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) ~[na:1.8.0_212] at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.19.jar!/:9.0.19] at java.lang.Thread.run(Thread.java:748) ~[na:1.8.0_212]</body>
		<created>2020-06-18 12:33:50</created>
		<closed>2020-06-18 14:53:49</closed>
	</bug>
	<bug>
		<id>1408</id>
		<title>使用填充Excel的功能，当模板单元格存在变量和字符串时，比如“{test} abc”，填充出来只剩下 abc</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 使用填充Excel的功能，当模板单元格存在变量和字符串时，比如“{test} abc”，填充出来只剩下“ abc”。 模板单元格的内容是 {test} abc 填充的值是test=123  **触发Bug的代码** ```java Map&lt;String, Object&gt; data1 = new HashMap&lt;&gt;(16); data1.put("test", "123"); Map&lt;String, Object&gt; data2 = new HashMap&lt;&gt;(16); data2.put("test2", "456");  ExcelWriter excelWriter = EasyExcel.write("test.xlsx").withTemplate("template.xlsx").build(); WriteSheet writeSheet = EasyExcel.writerSheet().build(); excelWriter.fill(data1, writeSheet); excelWriter.fill(data2, writeSheet); excelWriter.finish(); ``` **提示的异常或者没有达到的效果** 正常单元格的内容应该被填充成 123 abc 实际单元格的内容是  abc 填充的内容丢失了？</body>
		<created>2020-06-16 11:03:09</created>
		<closed>2020-06-23 12:17:43</closed>
	</bug>
	<bug>
		<id>1406</id>
		<title>[写入]注解形式自定义样式没有效果</title>
		<body>**触发场景描述** 版本2.2.4 **触发Bug的代码** 映射类和配置 ![image](https://user-images.githubusercontent.com/7867412/84729040-4a687800-afc5-11ea-9e6d-220708790fa8.png) 写入代码 ![image](https://user-images.githubusercontent.com/7867412/84729126-869bd880-afc5-11ea-91d8-b8df48db91dd.png) 结果 ![image](https://user-images.githubusercontent.com/7867412/84729077-5bb18480-afc5-11ea-8c90-15a57c1c676b.png)  **提示的异常或者没有达到的效果** [写入]注解形式自定义样式没有效果 </body>
		<created>2020-06-16 03:46:24</created>
		<closed>2020-06-16 03:48:00</closed>
	</bug>
	<bug>
		<id>1401</id>
		<title>填充表格问题</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述**  我用来填充表格的模板是用easyexcel生成的；然后用生成的模板填充数据后，模板那行数据还在占用了第一行数据；   **触发Bug的代码** ```java     String templatePath = "https://*****/pactera/res/template_score.xlsx";                 String tempPath = FileUtil.mkdirs(CommonInfo.RES_EXAM_PAPER_TEMP_UPLOAD_PATH);                 String fileName = paper.getSubjectCode() + "_template_score" + System.currentTimeMillis() + ".xlsx";                 String path = tempPath + File.separator + fileName;                 URLDataSource dataSource = new URLDataSource(new URL(templatePath));                 log.info("the path value is: {}", path);  //生成模板 EasyExcel.write(path).autoCloseStream(true).withTemplate(dataSource.getInputStream()).registerWriteHandler(new ExcelColumnWidthStyleStrategy()).sheet().doWrite(infoTemplate.getDataList());                  ExcelMergeCellStrategy mergeCellStrategy = new ExcelMergeCellStrategy(info.getExtraList());                 String fileName2 =paper.getSubjectCode() + "_template_score" + System.currentTimeMillis() + ".xlsx";                 String path2 = tempPath + File.separator + fileName2;                  log.info("the path value is: {}", path2);                 log.info(JSON.toJSONString(info.getDataList())); //填充模板                 ExcelWriter excelWriter = EasyExcel.write(path2).withTemplate(path).registerWriteHandler(new ExcelColumnWidthStyleStrategy()).registerWriteHandler(mergeCellStrategy).needHead(false).build();                 WriteSheet writeSheet = EasyExcel.writerSheet().build();                 excelWriter.fill(new FillWrapper("data", info.getDataList()), writeSheet);                 excelWriter.finish();  ``` **提示的异常或者没有达到的效果**  生成的模板如下： ![image](https://user-images.githubusercontent.com/8871373/84560969-3f220c00-ad7b-11ea-95d3-9e3fda33afad.png)  填充完的表格如下： ![image](https://user-images.githubusercontent.com/8871373/84560989-6082f800-ad7b-11ea-9c1a-b37764d66922.png)  麻烦作者有空看看；</body>
		<created>2020-06-13 05:40:05</created>
		<closed>2020-06-23 12:15:20</closed>
	</bug>
	<bug>
		<id>1394</id>
		<title>2.2.4 本地没问题，linux上就报错</title>
		<body>导入导出都报错 java.lang.ClassNotFoundException: org.apache.poi.poifs.filesystem.FileMagic 但是poi版本就一个，没有冲突</body>
		<created>2020-06-10 09:49:49</created>
		<closed>2020-06-16 11:12:49</closed>
	</bug>
	<bug>
		<id>1392</id>
		<title>在windows 环境下导出没问题 linux 下导出回报错的问题</title>
		<body>我在本地windows 下导出是没有问题的，但是运行到生产环境就出现了问题。这个问题以前是没有遇到的，在我的系统里发布了新的版本就在 linux 环境下出现了问题，但该部分的代码没有做过修改  ```java     EasyExcel.write(savePath).head(heads).sheet("模板").doWrite(dataList); ``` org.springframework.web.util.NestedServletException: Handler dispatch failed; nested exception is java.lang.NoSuchMethodError: com.alibaba.excel.write.builder.ExcelWriterBuilder.head(Ljava/util/List;)Lcom/alibaba/excel/metadata/AbstractParameterBuilder;  </body>
		<created>2020-06-10 04:59:20</created>
		<closed>2020-06-16 11:14:06</closed>
	</bug>
	<bug>
		<id>1389</id>
		<title>一行数据全为空的情况下还会被检测到</title>
		<body>一行数据全为空的情况下还会被invoke函数监听到。 例如：实际只有3条数据，但下面的x行空白也会被监听到，最后变成了3+x条</body>
		<created>2020-06-09 10:26:34</created>
		<closed>2020-06-09 14:48:23</closed>
	</bug>
	<bug>
		<id>1383</id>
		<title>No space left on device</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** com.alibaba.excel.exception.ExcelGenerateException: IO error at com.alibaba.excel.write.ExcelBuilderImpl.finish(ExcelBuilderImpl.java:94) at com.alibaba.excel.ExcelWriter.finish(ExcelWriter.java:187) at  **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** </body>
		<created>2020-06-08 02:46:30</created>
		<closed>2020-06-09 07:51:20</closed>
	</bug>
	<bug>
		<id>1380</id>
		<title>2.2.3版按示例导出最后多了一列标题为 “this$0”</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述**  **触发Bug的代码** ```java public class ExcelWriteTest {      @Test     public void writeWithHead() throws IOException {         String fileName = "E:\\aa.xlsx";         // 这里 需要指定写用哪个class去读，然后写到第一个sheet，名字为模板 然后文件流会自动关闭         // 如果这里想使用03 则 传入excelType参数即可         EasyExcel.write(fileName, DemoData.class).sheet("s1").doWrite(data());      }      private List&lt;DemoData&gt; data() {         List&lt;DemoData&gt; list = new ArrayList&lt;DemoData&gt;();         for (int i = 0; i &lt; 10; i++) {             DemoData data = new DemoData();             data.setString("字符串" + i);             data.setDate(new Date());             data.setDoubleData(0.56);             list.add(data);         }         return list;     }      public class DemoData {         @ExcelProperty("字符串标题")         private String string;         @ExcelProperty("日期标题")         private Date date;         @ExcelProperty("数字标题")         private Double doubleData; //        /** //         * 忽略这个字段 //         */ //        @ExcelIgnore //        private String ignore;          public String getString() {             return string;         }          public void setString(String string) {             this.string = string;         }          public Date getDate() {             return date;         }          public void setDate(Date date) {             this.date = date;         }          public Double getDoubleData() {             return doubleData;         }          public void setDoubleData(Double doubleData) {             this.doubleData = doubleData;         }  //        public String getIgnore() { //            return ignore; //        } // //        public void setIgnore(String ignore) { //            this.ignore = ignore; //        }     }  }  ``` **提示的异常或者没有达到的效果** 用Excel2010打开，最后总是有一列 this$0 </body>
		<created>2020-06-06 13:58:27</created>
		<closed>2020-06-06 23:15:25</closed>
	</bug>
	<bug>
		<id>1379</id>
		<title>使用模版填充多个sheet生成文件失败</title>
		<body>```java WriteSheet writeSheet; ExcelWriter excelWriter = EasyExcel.write(newFileName).withTemplate(templateFileName).build();  // 使用 map 模式填充 sheet0 writeSheet = EasyExcel.writerSheet(0).build(); excelWriter.fill(getDataMap0(), writeSheet);  // 使用 map 模式填充 sheet1 writeSheet = EasyExcel.writerSheet(1).build(); excelWriter.fill(getDataMap1(), writeSheet);  excelWriter.finish(); ``` 文件能生成，但是文件大小为0，不会抛出异常。 只填充sheet0，生成的文件是正常的。</body>
		<created>2020-06-06 09:52:58</created>
		<closed>2020-06-16 11:14:51</closed>
	</bug>
	<bug>
		<id>1378</id>
		<title>从2.1.7 升级到2.2.3后 导入03的 xls 文档NPE 2.1.7正常</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) 在2.1.7代码是正常导入运行的.. 但多sheet填充模板有问题发现有新版本尝试升级到2.2.3后发现解决 但导致了03的xls导入NPE RT **触发Bug的代码** ```java            EasyExcel.read(excelDataModel.getFile().getInputStream(), excelClass, listener)                 .sheet(sheetNum)                 .headRowNumber(headNumber) //                NOT WORKING //                .registerConverter(new LocalDateConverter())                 .doRead(); ``` 麻烦大神们看看 ```java java.lang.NullPointerException at com.alibaba.excel.analysis.v03.handlers.BofRecordHandler.processRecord(BofRecordHandler.java:49) at com.alibaba.excel.analysis.v03.XlsSaxAnalyser.processRecord(XlsSaxAnalyser.java:158) at org.apache.poi.hssf.eventusermodel.MissingRecordAwareHSSFListener.processRecord(MissingRecordAwareHSSFListener.java:201) at org.apache.poi.hssf.eventusermodel.FormatTrackingHSSFListener.processRecord(FormatTrackingHSSFListener.java:92) at org.apache.poi.hssf.eventusermodel.HSSFRequest.processRecord(HSSFRequest.java:106) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.genericProcessEvents(HSSFEventFactory.java:172) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.processEvents(HSSFEventFactory.java:129) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.processWorkbookEvents(HSSFEventFactory.java:80) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.processWorkbookEvents(HSSFEventFactory.java:53) at com.alibaba.excel.analysis.v03.XlsSaxAnalyser.execute(XlsSaxAnalyser.java:137) at com.alibaba.excel.analysis.ExcelAnalyserImpl.analysis(ExcelAnalyserImpl.java:115) at com.alibaba.excel.ExcelReader.read(ExcelReader.java:182) at com.alibaba.excel.ExcelReader.read(ExcelReader.java:172) at com.alibaba.excel.read.builder.ExcelReaderSheetBuilder.doRead(ExcelReaderSheetBuilder.java:65) at com.storlead.sc.web.service.impl.BaseServiceImpl.readToDb(BaseServiceImpl.java:93) at com.storlead.sc.web.service.impl.BaseServiceImpl$$FastClassBySpringCGLIB$$70287e86.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:366) at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:118) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) at com.alibaba.druid.support.spring.stat.DruidStatInterceptor.invoke(DruidStatInterceptor.java:73) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691) at com.storlead.sc.web.service.impl.SysUserServiceImpl$$EnhancerBySpringCGLIB$$36e122cc.readToDb(&lt;generated&gt;) at com.storlead.sc.web.controller.SysUserController.readSocialSecurityToDb(SysUserController.java:126) at com.storlead.sc.web.controller.SysUserController$$FastClassBySpringCGLIB$$25b4fdf9.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88) at com.storlead.sc.web.aspect.LogAspect.logAround(LogAspect.java:56) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:566) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633) at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) at org.springframework.aop.aspectj.AspectJAfterThrowingAdvice.invoke(AspectJAfterThrowingAdvice.java:62) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88) at com.storlead.sc.web.aspect.CheckIfCanModifyAspect.logAround(CheckIfCanModifyAspect.java:139) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:566) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633) at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) at com.alibaba.druid.support.spring.stat.DruidStatInterceptor.invoke(DruidStatInterceptor.java:73) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691) at com.storlead.sc.web.controller.SysUserController$$EnhancerBySpringCGLIB$$e63e7365.readSocialSecurityToDb(&lt;generated&gt;) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:566) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:113) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320) at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126) at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at com.storlead.sc.web.security.TokenFilter.doFilter(TokenFilter.java:67) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:92) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92) at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215) at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:93) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1590) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.base/java.lang.Thread.run(Thread.java:834) ```</body>
		<created>2020-06-05 07:49:15</created>
		<closed>2020-06-09 14:44:35</closed>
	</bug>
	<bug>
		<id>1365</id>
		<title>用Tomcat导出找不到net.sf.cglib.beans.BeanMap类</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** springboot启动项目导出Excel没有问题，用Tomcat导出找不到net.sf.cglib.beans.BeanMap类 **触发Bug的代码**  public static void writeExcel(HttpServletResponse response, List data, String fileName, String sheetName, Class clazz) throws Exception {         //表头样式         WriteCellStyle headWriteCellStyle = new WriteCellStyle();         //设置表头居中对齐         headWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);         //内容样式         WriteCellStyle contentWriteCellStyle = new WriteCellStyle();         //设置内容靠左对齐         contentWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.LEFT);         HorizontalCellStyleStrategy horizontalCellStyleStrategy = new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle);         EasyExcel.write(getOutputStream(fileName, response), clazz).sheet(sheetName).registerWriteHandler(horizontalCellStyleStrategy).doWrite(data);     } **提示的异常或者没有达到的效果** net.sf.cglib.core.CodeGenerationException: java.lang.reflect.InvocationTargetException--&gt;null at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:237) at net.sf.cglib.beans.BeanMap$Generator.create(BeanMap.java:122) at net.sf.cglib.beans.BeanMap.create(BeanMap.java:58) at com.alibaba.excel.write.executor.ExcelWriteAddExecutor.addJavaObjectToExcel(ExcelWriteAddExecutor.java:114) at com.alibaba.excel.write.executor.ExcelWriteAddExecutor.addOneRowOfDataToExcel(ExcelWriteAddExecutor.java:65) at com.alibaba.excel.write.executor.ExcelWriteAddExecutor.add(ExcelWriteAddExecutor.java:51) at com.alibaba.excel.write.ExcelBuilderImpl.addContent(ExcelBuilderImpl.java:61) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:161) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:146) at com.alibaba.excel.write.builder.ExcelWriterSheetBuilder.doWrite(ExcelWriterSheetBuilder.java:190) at com.jiewen.modules.sys.utils.EasyExcelUtil.writeExcel(EasyExcelUtil.java:281) at com.jiewen.modules.sys.web.ReportSearchController.exportAllExcel(ReportSearchController.java:198) at com.jiewen.modules.sys.web.ReportSearchController$$FastClassBySpringCGLIB$$19bee3e1.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:738) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157) at org.apache.shiro.spring.security.interceptor.AopAllianceAnnotationsAuthorizingMethodInterceptor$1.proceed(AopAllianceAnnotationsAuthorizingMethodInterceptor.java:82) at org.apache.shiro.authz.aop.AuthorizingMethodInterceptor.invoke(AuthorizingMethodInterceptor.java:39) at org.apache.shiro.spring.security.interceptor.AopAllianceAnnotationsAuthorizingMethodInterceptor.invoke(AopAllianceAnnotationsAuthorizingMethodInterceptor.java:115) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:673) at com.jiewen.modules.sys.web.ReportSearchController$$EnhancerBySpringCGLIB$$d785bde2.exportAllExcel(&lt;generated&gt;) at com.jiewen.modules.sys.web.ReportSearchController$$FastClassBySpringCGLIB$$19bee3e1.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:738) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157) at org.apache.shiro.spring.security.interceptor.AopAllianceAnnotationsAuthorizingMethodInterceptor$1.proceed(AopAllianceAnnotationsAuthorizingMethodInterceptor.java:82) at org.apache.shiro.authz.aop.AuthorizingMethodInterceptor.invoke(AuthorizingMethodInterceptor.java:39) at org.apache.shiro.spring.security.interceptor.AopAllianceAnnotationsAuthorizingMethodInterceptor.invoke(AopAllianceAnnotationsAuthorizingMethodInterceptor.java:115) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:673) at com.jiewen.modules.sys.web.ReportSearchController$$EnhancerBySpringCGLIB$$53bf8036.exportAllExcel(&lt;generated&gt;) at com.jiewen.modules.sys.web.ReportSearchController$$FastClassBySpringCGLIB$$19bee3e1.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:738) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157) at org.apache.shiro.spring.security.interceptor.AopAllianceAnnotationsAuthorizingMethodInterceptor$1.proceed(AopAllianceAnnotationsAuthorizingMethodInterceptor.java:82) at org.apache.shiro.authz.aop.AuthorizingMethodInterceptor.invoke(AuthorizingMethodInterceptor.java:39) at org.apache.shiro.spring.security.interceptor.AopAllianceAnnotationsAuthorizingMethodInterceptor.invoke(AopAllianceAnnotationsAuthorizingMethodInterceptor.java:115) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:673) at com.jiewen.modules.sys.web.ReportSearchController$$EnhancerBySpringCGLIB$$53bf8036.exportAllExcel(&lt;generated&gt;) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:133) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:861) at javax.servlet.http.HttpServlet.service(HttpServlet.java:624) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) at javax.servlet.http.HttpServlet.service(HttpServlet.java:731) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) at com.jiewen.jwp.base.config.SystemFilter.doFilter(SystemFilter.java:46) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) at org.springframework.web.servlet.resource.ResourceUrlEncodingFilter.doFilter(ResourceUrlEncodingFilter.java:59) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:112) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:61) at org.apache.shiro.web.servlet.AdviceFilter.executeChain(AdviceFilter.java:108) at org.apache.shiro.web.servlet.AdviceFilter.doFilterInternal(AdviceFilter.java:137) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125) at org.apache.shiro.web.servlet.ProxiedFilterChain.doFilter(ProxiedFilterChain.java:66) at org.apache.shiro.web.servlet.AbstractShiroFilter.executeChain(AbstractShiroFilter.java:449) at org.apache.shiro.web.servlet.AbstractShiroFilter$1.call(AbstractShiroFilter.java:365) at org.apache.shiro.subject.support.SubjectCallable.doCall(SubjectCallable.java:90) at org.apache.shiro.subject.support.SubjectCallable.call(SubjectCallable.java:83) at org.apache.shiro.subject.support.DelegatingSubject.execute(DelegatingSubject.java:383) at org.apache.shiro.web.servlet.AbstractShiroFilter.doFilterInternal(AbstractShiroFilter.java:362) at org.apache.shiro.web.servlet.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:125) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:347) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:263) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:108) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) at org.springframework.boot.web.support.ErrorPageFilter.doFilter(ErrorPageFilter.java:115) at org.springframework.boot.web.support.ErrorPageFilter.access$000(ErrorPageFilter.java:59) at org.springframework.boot.web.support.ErrorPageFilter$1.doFilterInternal(ErrorPageFilter.java:90) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.springframework.boot.web.support.ErrorPageFilter.doFilter(ErrorPageFilter.java:108) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:218) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:122) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:505) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:169) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103) at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:956) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:442) at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1082) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:623) at org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.doRun(AprEndpoint.java:2517) at org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:2506) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:722) Caused by: java.lang.reflect.InvocationTargetException: null at sun.reflect.GeneratedMethodAccessor39.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at net.sf.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:384) at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:219) ... 130 common frames omitted Caused by: java.lang.NoClassDefFoundError: net/sf/cglib/beans/BeanMap at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:791) ... 135 common frames omitted Caused by: java.lang.ClassNotFoundException: net.sf.cglib.beans.BeanMap at java.lang.ClassLoader.findClass(ClassLoader.java:522) at java.lang.ClassLoader.loadClass(ClassLoader.java:423) at java.lang.ClassLoader.loadClass(ClassLoader.java:356) ... 137 common frames omitted </body>
		<created>2020-06-02 09:43:39</created>
		<closed>2020-06-09 08:05:55</closed>
	</bug>
	<bug>
		<id>1363</id>
		<title>读excel下的子目录点击查看excel示例，都会回到“最简单的读”的示例</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述**  **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** </body>
		<created>2020-06-01 10:02:24</created>
		<closed>2020-06-09 08:10:21</closed>
	</bug>
	<bug>
		<id>1362</id>
		<title>填充excel用xlsx报错</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 填充excel，模板用xlsx报错，用xls是好的 **触发Bug的代码** ExcelWriter excelWriter = EasyExcel.write(out).withTemplate(templateFileName).build(); **提示的异常或者没有达到的效果** Caused by: org.apache.poi.openxml4j.exceptions.OLE2NotOfficeXmlFileException: The supplied data appears to be in the OLE2 Format. You are calling the part of POI that deals with OOXML (Office Open XML) Documents. You need to call a different part of POI to process this data (eg HSSF instead of XSSF)</body>
		<created>2020-06-01 09:48:44</created>
		<closed>2020-06-02 03:34:24</closed>
	</bug>
	<bug>
		<id>1360</id>
		<title>lombok同时采用data注解和Accessors，easyexcel读取设置无效</title>
		<body>**触发场景描述** 昨日初步第一次使用easyExcel，使用lombok注解，发现会导致读取发生问题。希望解决。 **基本的pojo类** ```java @Data @Builder @NoArgsConstructor @AllArgsConstructor @Accessors(chain = true) public class User {  //    @ExcelProperty(index = 0)     private String userName; //    @ExcelProperty(index = 1)     private String userAddress; //    @ExcelProperty(index = 2)     private int age; //    @ExcelProperty(index = 3)     private String city; } ``` **提示的异常或者没有达到的效果** 当去掉@Accessors(chain = true)的注解时，读取User列表和设置是正常的，加上后就会失效。即，得到的User列表数量是正确的，相应的user字段都是默认值，并没有进行设值操作。 例如，我采用下面代码进行读取，是能够发现，每行相应的index的值是什么值。 ```java List&lt;Map&lt;Integer, String&gt;&gt; listMap = EasyExcel.read(new ByteArrayInputStream(userdata)).sheet().doReadSync() ```  即使我在上面加上了@ExcelProperty(index = 0)注解，读取成User列表，相应的对象也是没有进行设值操作。 </body>
		<created>2020-06-01 01:38:49</created>
		<closed>2020-06-09 07:49:34</closed>
	</bug>
	<bug>
		<id>1359</id>
		<title>java.lang.UnsatisfiedLinkError: 找不到指 定的模块。</title>
		<body>在windows下出现异常 com.alibaba.excel.exception.ExcelAnalysisException: java.lang.UnsatisfiedLinkError: 找不到指 定的模块。  代码在mac下写的,并没有出现问题</body>
		<created>2020-05-31 15:04:17</created>
		<closed>2020-05-31 16:02:00</closed>
	</bug>
	<bug>
		<id>1358</id>
		<title>同时使用合并单元格和模板填充导出文件后, 打开导出的文件Excel会触发自动修复</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 使用 OnceAbsoluteMergeStrategy 为 ExcelWriter 指定合并策略后, 再使用 excelWriter.fill(); 进行多次填充, 即执行多个 ExcelWriter.fill(); 后, 生成的 Excel 文件会触发 MS Office 的自动修复, 点击修复后看到的修复记录如下: 已删除的记录: /xl/worksheets/sheet1.xml 部分的 合并单元格. 将生成的.xlsx 文件改为.zip 解压后查看/xl/worksheets/sheet1.xml 文件发现使用 OnceAbsoluteMergeStrategy 指定的合并单元格策略被执行了多遍, 即有几次 excelWriter.fill();方法调用就执行了几遍.  **触发Bug的代码** ```java    OnceAbsoluteMergeStrategy mergeStrategy = new OnceAbsoluteMergeStrategy(3, 3, 0, 0);             ExcelWriter excelWriter = EasyExcel.write(response.getOutputStream())                 .withTemplate(templateFileName)                 .registerWriteHandler(mergeStrategy)                 .build(); ``` ```java   excelWriter.fill(map, writeSheet);             excelWriter.fill(new FillWrapper("list1", title), writeSheet); ``` **提示的异常或者没有达到的效果** 如场景描述所提及</body>
		<created>2020-05-31 08:49:45</created>
		<closed>2020-06-23 11:28:53</closed>
	</bug>
	<bug>
		<id>1357</id>
		<title>springboot使用了easyExcel的模版填充功能，打成jar包报文件找不到</title>
		<body>springboot使用了easyExcel的模版填充功能，在本地可以正常使用； 打成jar包后，报模版文件找不到</body>
		<created>2020-05-31 00:58:37</created>
		<closed>2020-06-09 07:58:28</closed>
	</bug>
	<bug>
		<id>1352</id>
		<title>文件导出时，单元格内容长度过长时，抛出The maximum length of cell contents (text) is 32,767 characters</title>
		<body>文件导出时，字段长度过长时，抛出The maximum length of cell contents (text) is 32,767 characters  `java.lang.IllegalArgumentException: The maximum length of cell contents (text) is 32,767 characters at org.apache.poi.xssf.streaming.SXSSFCell.setCellValue(SXSSFCell.java:325) at com.alibaba.excel.util.WorkBookUtil.createCell(WorkBookUtil.java:69) at com.alibaba.excel.write.ExcelBuilderImpl.addBasicTypeToExcel(ExcelBuilderImpl.java:102) at com.alibaba.excel.write.ExcelBuilderImpl.addOneRowOfDataToExcel(ExcelBuilderImpl.java:125) at com.alibaba.excel.write.ExcelBuilderImpl.addContent(ExcelBuilderImpl.java:63) at com.alibaba.excel.write.ExcelBuilderImpl.addContent(ExcelBuilderImpl.java:70) at com.alibaba.excel.ExcelWriter.write1(ExcelWriter.java:106)`</body>
		<created>2020-05-28 01:13:28</created>
		<closed>2020-06-09 08:05:10</closed>
	</bug>
	<bug>
		<id>1345</id>
		<title>Converter not found, convert STRING to String</title>
		<body>**触发场景描述**  **触发Bug的代码** ```java File file = null;         try {             if (fileName.endsWith(".xls")) {                 file = new File(System.currentTimeMillis() + "_" + MD5.md5String(noskey) + ".xls");             } else {                 file = new File(System.currentTimeMillis() + "_" + MD5.md5String(noskey) + ".xlsx");             }             nosAdapterService.download(bucketName, noskey, file);             allData = EasyExcel.read(file, ExcelSongData.class, new DefaultListener()).sheet().doReadSync();         } finally {             if (file != null) {                 file.deleteOnExit();             }         }  ``` **提示的异常或者没有达到的效果** ``` exception in search com.alibaba.excel.exception.ExcelAnalysisException: com.alibaba.excel.exception.ExcelDataConvertException: Converter not found, convert STRING to String at com.alibaba.excel.analysis.v07.XlsxSaxAnalyser.parseXmlSource(XlsxSaxAnalyser.java:170) ~[easyexcel-2.1.6.jar:?] at com.alibaba.excel.analysis.v07.XlsxSaxAnalyser.execute(XlsxSaxAnalyser.java:189) ~[easyexcel-2.1.6.jar:?] at com.alibaba.excel.analysis.ExcelAnalyserImpl.analysis(ExcelAnalyserImpl.java:105) ~[easyexcel-2.1.6.jar:?] at com.alibaba.excel.ExcelReader.read(ExcelReader.java:180) ~[easyexcel-2.1.6.jar:?] at com.alibaba.excel.ExcelReader.read(ExcelReader.java:170) ~[easyexcel-2.1.6.jar:?] at com.alibaba.excel.read.builder.ExcelReaderSheetBuilder.doReadSync(ExcelReaderSheetBuilder.java:175) ~[easyexcel-2.1.6.jar:?] ``` </body>
		<created>2020-05-25 07:43:18</created>
		<closed>2020-06-16 11:15:33</closed>
	</bug>
	<bug>
		<id>1339</id>
		<title>head是List时，内容单元格的样式不生效</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** head是List时，内容单元格的样式不生效 **触发Bug的代码** com.alibaba.excel.write.style.AbstractCellStyleStrategy#afterCellDispose ```java     @Override     public void afterCellDispose(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder,         List&lt;CellData&gt; cellDataList, Cell cell, Head head, Integer relativeRowIndex, Boolean isHead) {         if (isHead == null || head == null) { // isHead为false，head == null为true时直接返回了。不能执行setContentCellStyle(cell, head, relativeRowIndex)             return;         }         if (isHead) {             setHeadCellStyle(cell, head, relativeRowIndex);         } else {             setContentCellStyle(cell, head, relativeRowIndex);         }     } ``` **提示的异常或者没有达到的效果** head是List时，内容单元格的样式不生效</body>
		<created>2020-05-22 12:03:07</created>
		<closed>2020-06-09 14:45:22</closed>
	</bug>
	<bug>
		<id>1338</id>
		<title>读取文件时出现Zip bomb detected</title>
		<body>com.alibaba.excel.exception.ExcelAnalysisException: java.io.IOException: Zip bomb detected! The file would exceed the max. ratio of compressed file size to the size of the expanded data. This may indicate that the file is used to inflate memory usage and thus could pose a security risk. You can adjust this limit via ZipSecureFile.setMinInflateRatio() if you need to work with files which exceed this limit. Uncompressed size: 820250, Raw/compressed size: 8192, ratio: 0.009987 Limits: MIN_INFLATE_RATIO: 0.010000, Entry: xl/styles.xml </body>
		<created>2020-05-22 09:29:26</created>
		<closed>2020-05-22 09:33:56</closed>
	</bug>
	<bug>
		<id>1337</id>
		<title>Lombok的@Accessors注解会使属性赋值过程中变的无效</title>
		<body>**触发场景描述** 当我在尝试使用easyexcel上传时，在数据库对应的实体上添加了@Accessors注解，导致在下面方法的最后一行代码：BeanMap.create(resultModel).putAll(map)时，excel读取到的map值并没有存入到entity的属性map中！  **触发Bug的代码** ```java     public static void main(String[] args) {         BeanMap beanMap = BeanMap.create(new entity());         Map map = new HashMap();         map.put("area", "111");         beanMap.putAll(map);         System.out.println(beanMap);     }      @Data     @Accessors(chain = true)     private static class entity{         private String area;     }  源码：     private Object buildUserModel(Map&lt;Integer, CellData&gt; cellDataMap, ReadHolder currentReadHolder,         AnalysisContext context) {         ExcelReadHeadProperty excelReadHeadProperty = currentReadHolder.excelReadHeadProperty();         Object resultModel;         try {             resultModel = excelReadHeadProperty.getHeadClazz().newInstance();         } catch (Exception e) {             throw new ExcelDataConvertException(context.readRowHolder().getRowIndex(), 0,                 new CellData(CellDataTypeEnum.EMPTY), null,                 "Can not instance class: " + excelReadHeadProperty.getHeadClazz().getName(), e);         }         Map&lt;Integer, Head&gt; headMap = excelReadHeadProperty.getHeadMap();         Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(headMap.size() * 4 / 3 + 1);         Map&lt;Integer, ExcelContentProperty&gt; contentPropertyMap = excelReadHeadProperty.getContentPropertyMap();         for (Map.Entry&lt;Integer, Head&gt; entry : headMap.entrySet()) {             Integer index = entry.getKey();             if (!cellDataMap.containsKey(index)) {                 continue;             }             CellData cellData = cellDataMap.get(index);             if (cellData.getType() == CellDataTypeEnum.EMPTY) {                 continue;             }             ExcelContentProperty excelContentProperty = contentPropertyMap.get(index);             Object value = ConverterUtils.convertToJavaObject(cellData, excelContentProperty.getField(),                 excelContentProperty, currentReadHolder.converterMap(), currentReadHolder.globalConfiguration(),                 context.readRowHolder().getRowIndex(), index);             if (value != null) {                 map.put(excelContentProperty.getField().getName(), value);             }         }         BeanMap.create(resultModel).putAll(map);         return resultModel;     } ```   </body>
		<created>2020-05-22 08:49:56</created>
		<closed>2020-05-22 09:26:31</closed>
	</bug>
	<bug>
		<id>1333</id>
		<title>动态header，多列报空指针</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** header的List&lt;List&lt;String&gt;&gt; 其中的List&lt;String&gt;只要出现多个，就报空指针异常。版本2.2.3 **触发Bug的代码** ```java     if (response != null) {             response.setContentType("application/vnd.ms-excel");             response.setCharacterEncoding("utf-8");             String fileName = URLEncoder.encode(getFilename(), "UTF-8");             response.setHeader("Content-disposition", "attachment;filename=" + fileName + ".xlsx");             EasyExcel.write(response.getOutputStream(), setClass()).head(getHeaders()).sheet().doWrite(list);         }      private List&lt;List&lt;String&gt;&gt; getHeaders() {         List&lt;List&lt;String&gt;&gt; customHeaders = new ArrayList&lt;&gt;();         customHeaders.addAll(setHeaders());         customHeaders.addAll(initHeaders());         for (var list : customHeaders) {             list.add(0, formatHeader());         }         return customHeaders;     }      private List&lt;List&lt;String&gt;&gt; initHeaders() {         List&lt;List&lt;String&gt;&gt; list = new ArrayList&lt;&gt;();         List&lt;String&gt; head0 = new ArrayList&lt;&gt;();         head0.add("待办任务量");         List&lt;String&gt; head1 = new ArrayList&lt;&gt;();         head1.add("待办处理量");         List&lt;String&gt; head2 = new ArrayList&lt;&gt;();         head2.add("待办随行处理量");         List&lt;String&gt; head3 = new ArrayList&lt;&gt;();         head3.add("待办随行处理占比");         List&lt;String&gt; head4 = new ArrayList&lt;&gt;();         head4.add("待阅任务量");         List&lt;String&gt; head5 = new ArrayList&lt;&gt;();         head5.add("待阅处理量");         List&lt;String&gt; head6 = new ArrayList&lt;&gt;();         head6.add("待阅随行处理量");         List&lt;String&gt; head7 = new ArrayList&lt;&gt;();         head7.add("待阅随行处理占比");         list.add(head0);         list.add(head1);         list.add(head2);         list.add(head3);         list.add(head4);         list.add(head5);         list.add(head6);         list.add(head7);         return list;     }      protected List&lt;List&lt;String&gt;&gt; setHeaders() {         return new ArrayList&lt;List&lt;String&gt;&gt;() {{             add(new ArrayList&lt;String&gt;() {{                 add("分类名称");             }});         }};     } ``` **提示的异常或者没有达到的效果** </body>
		<created>2020-05-21 01:39:18</created>
		<closed>2020-05-25 07:53:33</closed>
	</bug>
	<bug>
		<id>1329</id>
		<title>com.alibaba.excel.exception.ExcelAnalysisException: java.lang.NoSuchFieldError: RAW_XML_FILE_HEADER</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述**  **触发Bug的代码** ```java    EasyExcel.read(file.getInputStream(), OrderDeliveryExcel.class, analysisEventListener).sheet().doRead(); ``` **提示的异常或者没有达到的效果** com.alibaba.excel.exception.ExcelAnalysisException: java.lang.NoSuchFieldError: RAW_XML_FILE_HEADER at com.alibaba.excel.analysis.ExcelAnalyserImpl.&lt;init&gt;(ExcelAnalyserImpl.java:57) at com.alibaba.excel.ExcelReader.&lt;init&gt;(ExcelReader.java:145) at com.alibaba.excel.read.builder.ExcelReaderBuilder.build(ExcelReaderBuilder.java:193) at com.alibaba.excel.read.builder.ExcelReaderBuilder.sheet(ExcelReaderBuilder.java:229) at com.alibaba.excel.read.builder.ExcelReaderBuilder.sheet(ExcelReaderBuilder.java:217) at xx.order.controller.OrderTaskController.save(OrderTaskController.java:116) at xxorder.controller.OrderTaskController$$FastClassBySpringCGLIB$$8376c44d.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:746) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88) at xxxx .common.security.component.WoSecurityInnerAspect.around(WoSecurityInnerAspect.java:37) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633) at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:174) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) at xxx.controller.OrderTaskController$$EnhancerBySpringCGLIB$$197a23e6.save(&lt;generated&gt;) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:209) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:136) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:891) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:991) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:925) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:981) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:884) at javax.servlet.http.HttpServlet.service(HttpServlet.java:707) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:858) at javax.servlet.http.HttpServlet.service(HttpServlet.java:790) at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:74) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:129) at xxx.core.filter.RequestStreamFilter.doFilterInternal(RequestStreamFilter.java:20) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.boot.actuate.web.trace.servlet.HttpTraceFilter.doFilterInternal(HttpTraceFilter.java:90) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320) at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:127) at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:91) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:170) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.oauth2.provider.authentication.OAuth2AuthenticationProcessingFilter.doFilter(OAuth2AuthenticationProcessingFilter.java:176) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:74) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215) at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:357) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:270) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:109) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.filterAndRecordMetrics(WebMvcMetricsFilter.java:117) at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:106) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at xxxcommon.data.tenant.TenantContextHolderFilter.doFilter(TenantContextHolderFilter.java:43) at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61) at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131) at io.undertow.servlet.handlers.FilterHandler.handleRequest(FilterHandler.java:84) at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62) at io.undertow.servlet.handlers.ServletChain$1.handleRequest(ServletChain.java:65) at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36) at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:132) at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:57) at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:46) at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:64) at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:60) at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandler.java:77) at io.undertow.security.handlers.AbstractSecurityContextAssociationHandler.handleRequest(AbstractSecurityContextAssociationHandler.java:43) at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43) at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:292) at io.undertow.servlet.handlers.ServletInitialHandler.access$100(ServletInitialHandler.java:81) at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:138) at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:135) at io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:48) at io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43) at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:272) at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:81) at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:104) at io.undertow.server.Connectors.executeRootHandler(Connectors.java:336) at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:830) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.NoSuchFieldError: RAW_XML_FILE_HEADER at org.apache.poi.poifs.filesystem.FileMagic.&lt;clinit&gt;(FileMagic.java:42) at com.alibaba.excel.support.ExcelTypeEnum.recognitionExcelType(ExcelTypeEnum.java:90) at com.alibaba.excel.support.ExcelTypeEnum.valueOf(ExcelTypeEnum.java:78) at com.alibaba.excel.analysis.ExcelAnalyserImpl.choiceExcelExecutor(ExcelAnalyserImpl.java:62) at com.alibaba.excel.analysis.ExcelAnalyserImpl.&lt;init&gt;(ExcelAnalyserImpl.java:51) ... 134 more</body>
		<created>2020-05-20 01:45:57</created>
		<closed>2020-05-22 06:24:55</closed>
	</bug>
	<bug>
		<id>1327</id>
		<title>could not initialize class ExcelBuilderImpl</title>
		<body>web导出   出现 could not initialize class ExcelBuilderImpl </body>
		<created>2020-05-19 14:18:20</created>
		<closed>2020-05-22 06:24:36</closed>
	</bug>
	<bug>
		<id>1324</id>
		<title>xls公式的值获取在同一行前序所有单元格无其他内容时无法获取</title>
		<body> xls公式的值获取在同一行前序所有单元格无其他内容时无法获取  xls数据  ![image](https://user-images.githubusercontent.com/7499201/82303662-d64eaa80-99ed-11ea-831e-c4499b81052f.png) 这种情况下无法获取红框标志的公式的值  {0=null, 1=null, 2=null, 3=null, 4=null, 5=3} {0=null, 1=null, 2=null, 3=2} {0=null, 1=21, 2=1, 3=null, 4=3} {0=null, 1=null, 2=null, 3=null, 4=null, 5=4} {0=null, 1=12, 2=2} {0=null, 1=12}  如果前序增加任何一个值 ![image](https://user-images.githubusercontent.com/7499201/82303772-fda57780-99ed-11ea-8c02-8e6ebd2efeb0.png) 此时读取正常  {0=null, 1=12, 2=1} {0=null, 1=null, 2=null, 3=null, 4=null, 5=3} {0=null, 1=null, 2=null, 3=2} {0=null, 1=21, 2=1, 3=null, 4=3} {0=null, 1=null, 2=null, 3=null, 4=null, 5=4} {0=null, 1=12, 2=2} {0=null, 1=12} {0=str, 1=57, 2=4, 3=2, 4=3, 5=7}  </body>
		<created>2020-05-19 08:32:15</created>
		<closed>2020-06-09 14:46:40</closed>
	</bug>
	<bug>
		<id>1322</id>
		<title>复杂表头未按预期跨行显示</title>
		<body>**触发场景描述** - 复杂表头导出，我无意的设置了ExcelProperty的index从1开始 例如：         @ColumnWidth(25)     @ExcelProperty(value = {"订单统计", "年月"}, index = 1)     private String yearMonth;      @ColumnWidth(25)     @ExcelProperty(value = {"订单统计", "订单数量"}, index = 2)     private Integer orderNum; ![错误格式](https://user-images.githubusercontent.com/30773069/82231630-fd5e9b00-995f-11ea-9e85-6545e0d6c7bd.png) ![正确格式](https://user-images.githubusercontent.com/30773069/82231680-11a29800-9960-11ea-8f26-c1638244047a.png)  导致复杂表头没有跨列显示，只显示在最后一列，将index改为0开始后恢复正常  **提示的异常或者没有达到的效果** -  即便不从excel的第一列开始填充数据也应该保持复杂表头跨行显示 </body>
		<created>2020-05-18 15:35:44</created>
		<closed>2020-06-09 14:46:55</closed>
	</bug>
	<bug>
		<id>1321</id>
		<title>docker 运行报空指针</title>
		<body>**触发场景描述** 本地测试正常导出，部署到测试docker上就报错，版本2.1.6 **触发Bug的代码** ```java     EasyExcel.write(response.getOutputStream(), ExportStatisticalRsp.class).sheet("导出结果").doWrite(exportStatisticalRsps); ``` **提示的异常或者没有达到的效果** java.lang.NullPointerException: null at sun.awt.FontConfiguration.getVersion(FontConfiguration.java:1264) at sun.awt.FontConfiguration.readFontConfigFile(FontConfiguration.java:219) at sun.awt.FontConfiguration.init(FontConfiguration.java:107) at sun.awt.X11FontManager.createFontConfiguration(X11FontManager.java:774) at sun.font.SunFontManager$2.run(SunFontManager.java:431) at java.security.AccessController.doPrivileged(Native Method) at sun.font.SunFontManager.&lt;init&gt;(SunFontManager.java:376) at sun.awt.FcFontManager.&lt;init&gt;(FcFontManager.java:35) at sun.awt.X11FontManager.&lt;init&gt;(X11FontManager.java:57) at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:423) at java.lang.Class.newInstance(Class.java:442) at sun.font.FontManagerFactory$1.run(FontManagerFactory.java:83) at java.security.AccessController.doPrivileged(Native Method) at sun.font.FontManagerFactory.getInstance(FontManagerFactory.java:74) at java.awt.Font.getFont2D(Font.java:491) at java.awt.Font.canDisplayUpTo(Font.java:2060) at java.awt.font.TextLayout.singleFont(TextLayout.java:470) at java.awt.font.TextLayout.&lt;init&gt;(TextLayout.java:531) at org.apache.poi.ss.util.SheetUtil.getDefaultCharWidth(SheetUtil.java:275) at org.apache.poi.xssf.streaming.AutoSizeColumnTracker.&lt;init&gt;(AutoSizeColumnTracker.java:117) at org.apache.poi.xssf.streaming.SXSSFSheet.&lt;init&gt;(SXSSFSheet.java:82) at org.apache.poi.xssf.streaming.SXSSFWorkbook.createAndRegisterSXSSFSheet(SXSSFWorkbook.java:658) at org.apache.poi.xssf.streaming.SXSSFWorkbook.createSheet(SXSSFWorkbook.java:679) at org.apache.poi.xssf.streaming.SXSSFWorkbook.createSheet(SXSSFWorkbook.java:90) at com.alibaba.excel.util.WorkBookUtil.createSheet(WorkBookUtil.java:66) at com.alibaba.excel.context.WriteContextImpl.createSheet(WriteContextImpl.java:187) at com.alibaba.excel.context.WriteContextImpl.initSheet(WriteContextImpl.java:167) at com.alibaba.excel.context.WriteContextImpl.currentSheet(WriteContextImpl.java:114) at com.alibaba.excel.write.ExcelBuilderImpl.addContent(ExcelBuilderImpl.java:56) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:161) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:146) at com.alibaba.excel.write.builder.ExcelWriterSheetBuilder.doWrite(ExcelWriterSheetBuilder.java:190) at com.xxx.service.impl.StatisticalServiceImpl.editorExport(StatisticalServiceImpl.java:145) at com.xxx.service.impl.StatisticalServiceImpl$$FastClassBySpringCGLIB$$1d113e74.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:687) at com.xxx.service.impl.StatisticalServiceImpl$$EnhancerBySpringCGLIB$$a59b94a8.editorExport(&lt;generated&gt;) at com.xxx..controller.StatisticsController.editorExport(StatisticsController.java:61) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:109) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) at org.apache.catalina.valves.RemoteIpValve.invoke(RemoteIpValve.java:747) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748)</body>
		<created>2020-05-18 10:24:10</created>
		<closed>2020-05-18 10:39:08</closed>
	</bug>
	<bug>
		<id>1319</id>
		<title>使用2.2.1版本 使用OnceAbsoluteMergeStrategy合并单元格失效</title>
		<body> ExcelWriterBuilder excelWriterBuilder = EasyExcel.write(newFilesPath).withTemplate(resource.getInputStream());             for (OnceAbsoluteMergeStrategy onceAbsoluteMergeStrategy : onceAbsoluteMergeStrategies) {                 excelWriterBuilder = excelWriterBuilder.registerWriteHandler(onceAbsoluteMergeStrategy);             }             ExcelWriter excelWriter = null;             FillConfig fillConfig = FillConfig.builder().forceNewRow(Boolean.TRUE).direction(WriteDirectionEnum.HORIZONTAL).build();             try {                 Map&lt;String,String&gt; stringMap = Maps.newHashMapWithExpectedSize(1);                 stringMap.put("year","{.year}");                 excelWriter = excelWriterBuilder.build();                 WriteSheet writeSheet = EasyExcel.writerSheet().build();                 excelWriter.fill(exportHeadDataVos, fillConfig, writeSheet);                 excelWriter.fill(stringMap, writeSheet);              }finally {                 if (excelWriter != null) {                     excelWriter.finish();                 }             }  </body>
		<created>2020-05-18 08:13:30</created>
		<closed>2020-05-22 06:29:23</closed>
	</bug>
	<bug>
		<id>1315</id>
		<title>StringNumberConverter对于不创建对象读的场景，没有使用CellData里的dataFormatString转换时间字段</title>
		<body>**触发场景描述** StringNumberConverter对于不创建对象读的场景，没有使用CellData里的dataFormatString转换时间字段，而是直接用了com.alibaba.excel.util.DateUtils#format(java.util.Date)，这样所有的时间类型读取出来都是yyyy-MM-dd HH:mm:ss格式。  **触发Bug的代码** StringNumberConverter.java 48 行 ```java if (DateUtil.isADateFormat(cellData.getDataFormat(), cellData.getDataFormatString())) {     return DateUtils.format(DateUtil.getJavaDate(cellData.getNumberValue().doubleValue(),         globalConfiguration.getUse1904windowing(), null)); } ``` </body>
		<created>2020-05-15 07:42:41</created>
		<closed>2020-05-22 06:32:50</closed>
	</bug>
	<bug>
		<id>1314</id>
		<title>使用jdk11.5 ，调用ExcelWriter.writeSheet方法时有时会出现InnvocationTargetException异常</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** ExcelWriter.writeSheet()方法写多个sheet **触发Bug的代码** ```java     final ExcelWriter excelWriter = EasyExcel.write(response.getOutputStream()).build();             final List&lt;SheetExportTableConfig&gt; sheetExportTableConfigs = commonService                     .querySheetExportTableConfigs(“test”);              final int size = sheetExportTableConfigs.size();             List&lt;Future&lt;Pair&lt;WriteSheet, List&lt;List&lt;Object&gt;&gt;&gt;&gt;&gt; futures = new ArrayList&lt;&gt;(size);             for (SheetExportTableConfig sheetExportTableConfig : sheetExportTableConfigs) {                 final Future&lt;Pair&lt;WriteSheet, List&lt;List&lt;Object&gt;&gt;&gt;&gt; future = threadPoolExecutor                         .submit(new WriteSheetDataTask(sheetExportTableConfig, downloadReqDTO,                                 clickhouseJdbcTemplate));                 futures.add(future);             }              List&lt;Pair&lt;WriteSheet, List&lt;List&lt;Object&gt;&gt;&gt;&gt; pairList = new ArrayList&lt;&gt;(size);             for (Future&lt;Pair&lt;WriteSheet, List&lt;List&lt;Object&gt;&gt;&gt;&gt; future : futures) {                 final Pair&lt;WriteSheet, List&lt;List&lt;Object&gt;&gt;&gt; writeSheetListPair = future.get();                 pairList.add(writeSheetListPair);             }              // EasyExcel不支持并发写多个sheet             for (Pair&lt;WriteSheet, List&lt;List&lt;Object&gt;&gt;&gt; pair : pairList) {                 excelWriter.write(pair.getRight(), pair.getLeft());             } ``` **提示的异常或者没有达到的效果** 2020-05-15t04:15:30.064025351z 2020-05-15 12:15:30|http-nio-80-exec-7|[dispatcherservlet]|servlet.service() for servlet [dispatcherservlet] in context with path [] threw exception [request processing failed; nested exception is com.alibaba.excel.exception.excelgenerateexception: java.lang.internalerror: java.lang.reflect.invocationtargetexception] with root cause</body>
		<created>2020-05-15 05:38:58</created>
		<closed>2020-05-22 06:30:46</closed>
	</bug>
	<bug>
		<id>1312</id>
		<title>2.2.3版本 通过WriteSheet对象 设置 sheet 别名不成功</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 简单的多sheet写入方式，我这边写了简单的demo **触发Bug的代码** ```java    String templateIn = "C:\\Users\\Administrator\\Desktop\\bugA.xlsx"; String fileName = "C:\\"+System.currentTimeMillis()+".xlsx"; ExcelWriter excelWriter = EasyExcel.write(fileName).withTemplate(templateIn).build(); WriteSheet writeSheet = EasyExcel.writerSheet(0, "模板").sheetName("模板").build(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(8); map.put("data", "hello"); excelWriter.fill(map, writeSheet); excelWriter.write(null, writeSheet); excelWriter.finish(); ``` **提示的异常或者没有达到的效果** sheet 别名没有变更</body>
		<created>2020-05-14 14:19:29</created>
		<closed>2020-05-22 06:28:49</closed>
	</bug>
	<bug>
		<id>1311</id>
		<title>导入wps新建的Excel文件报错</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 导入wps新建的Excel文件报错 **触发Bug的代码** ```List&lt;Object&gt; excelReaderBuilder = EasyExcel.read(inputStream).doReadAllSync();    这里写代码 ``` **提示的异常或者没有达到的效果** java.lang.NoClassDefFoundError: org/openxmlformats/schemas/spreadsheetml/x2006/main/impl/CTSheetsImpl$1SheetList</body>
		<created>2020-05-14 02:25:48</created>
		<closed>2020-05-14 06:53:58</closed>
	</bug>
	<bug>
		<id>1306</id>
		<title>@NumberFormat注解转换double时可能会丢失精度</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 用@NumberFormat注解转换double类型 **触发Bug的代码** ```java //表格映射对象double属性   /**    * 格式化百分比    */   @NumberFormat("#.##%")   @ExcelProperty("百分比")   private Double num;  //读取excel的Listener   @Override   public void invoke(DemoData demoData, AnalysisContext analysisContext) {     int row = analysisContext.readRowHolder().getRowIndex();     int sheetNo = analysisContext.readSheetHolder().getSheetNo();     String sheetName = analysisContext.readSheetHolder().getSheetName();     log.info("读取到[{}]的第{}行记录：{}", sheetName, row, JSONObject.toJSONString(demoData));   } ``` **提示的异常或者没有达到的效果** ![image](https://user-images.githubusercontent.com/24472662/81635983-3a4cfe00-9445-11ea-8dca-d19ab0123b4d.png)   11:37:01.360 [main] INFO com.spring.component.easyexcel.listener.DemoDataListener - 读取到[Demo]的第9行记录：{"date":1589202943000,"no":"WEEK_3","num":0.6520999999999999,"zan":"点赞8"} 11:37:01.361 [main] INFO com.spring.component.easyexcel.listener.DemoDataListener - 读取到[Demo]的第10行记录：{"date":1589202943000,"no":"WEEK_4","num":0.74,"zan":"点赞9"}   **建议** com.alibaba.excel.util.NumberUtils#parse 方法返回Number为BigDecimal对象，避免double、float等类型出现精度丢失的情况。    decimalFormat.setParseBigDecimal(true); </body>
		<created>2020-05-12 03:45:34</created>
		<closed>2020-06-09 14:45:42</closed>
	</bug>
	<bug>
		<id>1303</id>
		<title>自适应列宽只有第一次生效的bug</title>
		<body>public class LongestMatchColumnWidthStyleStrategy extends AbstractColumnWidthStyleStrategy {     private static final int MAX_COLUMN_WIDTH = 255;     private static final Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; CACHE = new HashMap(8);  自适应列宽的这个类当中用来缓存每一行的单元的最大字段长度,这边用了私有静态最终的Map,导致了每次导出的自适应列宽都用第一次导出的宽度 我改为 private  Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; CACHE = new HashMap(8); 之后就正常了, 版本是     &lt;dependency&gt;             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;             &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;             &lt;version&gt;2.1.4&lt;/version&gt;         &lt;/dependency&gt; 注:才疏学浅,若有错误请见谅</body>
		<created>2020-05-11 03:43:01</created>
		<closed>2020-05-14 07:05:20</closed>
	</bug>
	<bug>
		<id>1301</id>
		<title>19位长度数字用String接收，读到的值和实际不一致</title>
		<body>easyexcel 版本 2.2.3  通过String接收如下数值  3101011021236150000  最终显示为  3101011021236149800 </body>
		<created>2020-05-08 01:34:51</created>
		<closed>2020-05-11 10:49:30</closed>
	</bug>
	<bug>
		<id>1298</id>
		<title>指定sheet名 报错NPE</title>
		<body>EasyExcel.write(response.getOutputStream())                     .registerWriteHandler(horizontalCellStyleStrategy)                     .head(head(dtos))                     .autoCloseStream(Boolean.FALSE)                     .sheet(sheetName)                     .doWrite(data(dtos)); 指定sheet的时候报NPE异常。java.lang.NullPointerException  response.getWriter().println(toJSONString(map)); 此处报错getWriter() has already been called for this response</body>
		<created>2020-05-07 02:36:21</created>
		<closed>2020-05-07 02:50:22</closed>
	</bug>
	<bug>
		<id>1297</id>
		<title>导出Excel时抛出空指针异常</title>
		<body>java.lang.NullPointerException: null at sun.awt.FontConfiguration.getVersion(FontConfiguration.java:1264) ~[?:1.8.0_151],</body>
		<created>2020-05-06 13:40:11</created>
		<closed>2020-05-14 07:16:49</closed>
	</bug>
	<bug>
		<id>1292</id>
		<title>Stream Closed 异常</title>
		<body>**触发场景描述** 写入本地excel文件报错  **触发Bug的代码** 源码不方便贴，贴了简要过程代码，版本2.1.6 com.alibaba.excel.EasyExcelFactory#write(java.lang.String, java.lang.Class)  创建ExcelWriter对象 com.alibaba.excel.EasyExcelFactory#writerSheet(java.lang.String)  创建WriteSheet对象 com.alibaba.excel.ExcelWriter#write(java.util.List, com.alibaba.excel.write.metadata.WriteSheet)  写入数据  **提示的异常或者没有达到的效果** 写入数据报错了，本地文件为空，异常信息如下   Destroy object failed com.alibaba.excel.exception.ExcelGenerateException: Can not close IO. at com.alibaba.excel.context.WriteContextImpl.finish(WriteContextImpl.java:358) at com.alibaba.excel.write.ExcelBuilderImpl.finish(ExcelBuilderImpl.java:101) at com.alibaba.excel.ExcelWriter.finish(ExcelWriter.java:328) at com.alibaba.excel.ExcelWriter.finalize(ExcelWriter.java:338) at java.lang.System$2.invokeFinalize(System.java:1270) at java.lang.ref.Finalizer.runFinalizer(Finalizer.java:98) at java.lang.ref.Finalizer.access$100(Finalizer.java:34) at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:210) Caused by: java.io.IOException: Stream Closed at java.io.FileOutputStream.writeBytes(Native Method) at java.io.FileOutputStream.write(FileOutputStream.java:326) at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221) at sun.nio.cs.StreamEncoder.implWrite(StreamEncoder.java:282) at sun.nio.cs.StreamEncoder.write(StreamEncoder.java:125) at java.io.OutputStreamWriter.write(OutputStreamWriter.java:207) at java.io.BufferedWriter.flushBuffer(BufferedWriter.java:129) at java.io.BufferedWriter.write(BufferedWriter.java:230) at java.io.Writer.write(Writer.java:157) at org.apache.poi.xssf.streaming.SheetDataWriter.writeCell(SheetDataWriter.java:238) at org.apache.poi.xssf.streaming.SheetDataWriter.writeRow(SheetDataWriter.java:159) at org.apache.poi.xssf.streaming.SXSSFSheet.flushOneRow(SXSSFSheet.java:1893) at org.apache.poi.xssf.streaming.SXSSFSheet.flushRows(SXSSFSheet.java:1871) at org.apache.poi.xssf.streaming.SXSSFSheet.flushRows(SXSSFSheet.java:1882) at org.apache.poi.xssf.streaming.SXSSFWorkbook.write(SXSSFWorkbook.java:931) at com.alibaba.excel.context.WriteContextImpl.finish(WriteContextImpl.java:314) </body>
		<created>2020-05-04 13:03:18</created>
		<closed>2020-05-13 12:57:41</closed>
	</bug>
	<bug>
		<id>1280</id>
		<title>跳跃读取sheet页出现npe，不确定是不是bug</title>
		<body>**触发场景描述** 有3个sheet，我想读第2个，触发npe **触发Bug的代码** ```java    String fileName = "打码******圣光******圣光******马赛克";         ArrayList&lt;KGResource&gt; resources = new ArrayList&lt;&gt;(1000);         ExcelReader excelReader = EasyExcel.read(fileName, KGResource.class, new AnalysisEventListener&lt;KGResource&gt;() {             @Override             public void invoke(KGResource data, AnalysisContext context) {                 resources.add(data);             }              @Override             public void doAfterAllAnalysed(AnalysisContext context) {              }         }).build();         ReadSheet readSheet = EasyExcel.readSheet(1).headRowNumber(2).build();         excelReader.read(readSheet);         excelReader.finish(); ``` </body>
		<created>2020-04-28 07:35:09</created>
		<closed>2020-06-09 14:45:51</closed>
	</bug>
	<bug>
		<id>1277</id>
		<title>使用自动调整列宽方法不稳定</title>
		<body>EasyExcel.write(outputStream, HttpFloorMsgExpand.class).sheet("数据")         .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy())         .doWrite(dataList);  列宽首次可以自动调整宽度，之后就不能调整了</body>
		<created>2020-04-28 02:25:55</created>
		<closed>2020-04-30 10:39:36</closed>
	</bug>
	<bug>
		<id>1274</id>
		<title>当数据列表里面有值为空的时候使用会触发空指针异常</title>
		<body>**触发场景描述** 当数据列表里面有值为空的时候使用会触发空指针异常 版本2.2.2  **触发Bug的代码** 将[com.alibaba.easyexcel.test.demo.fill.FillTest#data中的`// fillData.setName("张三");`](https://github.com/alibaba/easyexcel/blob/master/src/test/java/com/alibaba/easyexcel/test/demo/fill/FillTest.java#220)注释掉 单元测试[com.alibaba.easyexcel.test.demo.fill.FillTest#compositeFill](https://github.com/alibaba/easyexcel/blob/master/src/test/java/com/alibaba/easyexcel/test/demo/fill/FillTest.java#189)会触发bug,下面是我使用时触发的代码  ``` BiConsumer&lt;ExcelWriter, WriteSheet&gt; doFill = (writer, sheet) -&gt; {             FillConfig fillConfig = FillConfig.builder().forceNewRow(Boolean.TRUE).build();             writer.fill(new FillWrapper("a", register.getUnRegisterList()), sheet);             writer.finish();         }; ```  **提示的异常或者没有达到的效果** ``` java.lang.NullPointerException at com.alibaba.excel.converters.ConverterKeyBuild.buildKey(ConverterKeyBuild.java:29) at com.alibaba.excel.write.executor.AbstractExcelWriteExecutor.doConvert(AbstractExcelWriteExecutor.java:103) at com.alibaba.excel.write.executor.AbstractExcelWriteExecutor.convert(AbstractExcelWriteExecutor.java:93) at com.alibaba.excel.write.executor.AbstractExcelWriteExecutor.converterAndSet(AbstractExcelWriteExecutor.java:41) at com.alibaba.excel.write.executor.ExcelWriteFillExecutor.doFill(ExcelWriteFillExecutor.java:202) at com.alibaba.excel.write.executor.ExcelWriteFillExecutor.fill(ExcelWriteFillExecutor.java:118) at com.alibaba.excel.write.ExcelBuilderImpl.fill(ExcelBuilderImpl.java:78) at com.alibaba.excel.ExcelWriter.fill(ExcelWriter.java:185) at com.alibaba.easyexcel.test.demo.fill.FillTest.compositeFill(FillTest.java:200) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230) at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58) ``` 将com.alibaba.excel.write.executor.AbstractExcelWriteExecutor#doConvert的 ``` if (value == null &amp;&amp; !(converter instanceof NullableObjectConverter)) {             return new CellData(CellDataTypeEnum.EMPTY); ```         }提到最前放面做判断不会触发错误 ``` private CellData doConvert(WriteHolder currentWriteHolder, Class clazz, Cell cell, Object value,         ExcelContentProperty excelContentProperty) {         Converter converter = null;         if (excelContentProperty != null) {             converter = excelContentProperty.getConverter();         }         if (value == null &amp;&amp; !(converter instanceof NullableObjectConverter)) {             return new CellData(CellDataTypeEnum.EMPTY);         }         if (converter == null) {             converter = currentWriteHolder.converterMap().get(ConverterKeyBuild.buildKey(clazz));         }         if (converter == null) {             throw new ExcelDataConvertException(cell.getRow().getRowNum(), cell.getColumnIndex(),                 new CellData(CellDataTypeEnum.EMPTY), excelContentProperty,                 "Can not find 'Converter' support class " + clazz.getSimpleName() + ".");         }         CellData cellData;         try {             cellData =                 converter.convertToExcelData(value, excelContentProperty, currentWriteHolder.globalConfiguration());         } catch (Exception e) {             throw new ExcelDataConvertException(cell.getRow().getRowNum(), cell.getColumnIndex(),                 new CellData(CellDataTypeEnum.EMPTY), excelContentProperty,                 "Convert data:" + value + " error,at row:" + cell.getRow().getRowNum(), e);         }         if (cellData == null || cellData.getType() == null) {             throw new ExcelDataConvertException(cell.getRow().getRowNum(), cell.getColumnIndex(),                 new CellData(CellDataTypeEnum.EMPTY), excelContentProperty,                 "Convert data:" + value + " return null,at row:" + cell.getRow().getRowNum());         }         return cellData;     } ``` </body>
		<created>2020-04-27 08:13:43</created>
		<closed>2020-04-27 11:24:18</closed>
	</bug>
	<bug>
		<id>1272</id>
		<title>生成导出文件说是找不到类。</title>
		<body>2020-04-27 11:15:12,107 ERROR [SimpleAsyncTaskExecutor-10] org.springframework.aop.interceptor.SimpleAsyncUncaughtExceptionHandler - Unexpected error occurred invoking async method: public void com.pttl.bdrc.core.base.service.impl.ExportExcelServiceImpl.writeDataToFile(java.util.List,java.lang.String,java.lang.String,java.lang.String,java.lang.Class) com.alibaba.excel.exception.ExcelGenerateException: java.lang.NoClassDefFoundError: Could not initialize class sun.awt.X11FontManager at com.alibaba.excel.write.ExcelBuilderImpl.addContent(ExcelBuilderImpl.java:67) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:161) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:146) at com.alibaba.excel.write.builder.ExcelWriterSheetBuilder.doWrite(ExcelWriterSheetBuilder.java:190) at com.pttl.bdrc.core.base.service.impl.ExportExcelServiceImpl.writeDataToFile(ExportExcelServiceImpl.java:51) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:333) at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157) at org.springframework.aop.interceptor.AsyncExecutionInterceptor$1.call(AsyncExecutionInterceptor.java:115) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.NoClassDefFoundError: Could not initialize class sun.awt.X11FontManager at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Class.java:348) at sun.font.FontManagerFactory$1.run(FontManagerFactory.java:82) at java.security.AccessController.doPrivileged(Native Method) at sun.font.FontManagerFactory.getInstance(FontManagerFactory.java:74) at java.awt.Font.getFont2D(Font.java:491) at java.awt.Font.canDisplayUpTo(Font.java:2060) at java.awt.font.TextLayout.singleFont(TextLayout.java:470) at java.awt.font.TextLayout.&amp;lt;init&amp;gt;(TextLayout.java:531) at org.apache.poi.ss.util.SheetUtil.getDefaultCharWidth(SheetUtil.java:275) at org.apache.poi.xssf.streaming.AutoSizeColumnTracker.&amp;lt;init&amp;gt;(AutoSizeColumnTracker.java:117) at org.apache.poi.xssf.streaming.SXSSFSheet.&amp;lt;init&amp;gt;(SXSSFSheet.java:82) at org.apache.poi.xssf.streaming.SXSSFWorkbook.createAndRegisterSXSSFSheet(SXSSFWorkbook.java:658) at org.apache.poi.xssf.streaming.SXSSFWorkbook.createSheet(SXSSFWorkbook.java:679) at org.apache.poi.xssf.streaming.SXSSFWorkbook.createSheet(SXSSFWorkbook.java:90) at com.alibaba.excel.util.WorkBookUtil.createSheet(WorkBookUtil.java:66) at com.alibaba.excel.context.WriteContextImpl.initSheet(WriteContextImpl.java:154) at com.alibaba.excel.context.WriteContextImpl.currentSheet(WriteContextImpl.java:131)</body>
		<created>2020-04-27 03:29:35</created>
		<closed>2020-04-27 07:21:08</closed>
	</bug>
	<bug>
		<id>1264</id>
		<title>映射entity使用lombok的@Accessors(chain = true)注解时,无法映射</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 映射entity使用lombok的@Accessors(chain = true)注解时,无法映射,去掉正常 ![微信截图_20200424120849](https://user-images.githubusercontent.com/34758797/80174144-5e76a580-8624-11ea-87cf-ea6808ab0910.png)  ![微信截图_20200424120800](https://user-images.githubusercontent.com/34758797/80174105-47d04e80-8624-11ea-9929-9d9e10e2f669.png)  **触发Bug的代码** [栗子](https://github.com/bozer666/easyexcel-test) **提示的异常或者没有达到的效果** 映射的entity属性值为null </body>
		<created>2020-04-24 04:10:26</created>
		<closed>2020-04-24 07:36:55</closed>
	</bug>
	<bug>
		<id>1261</id>
		<title>@NumberFormat和@ExcelProperty(converter = BigDecimalNumberConverter.class)冲突，@NumberFormat失效</title>
		<body>**触发场景描述** 在字段上同时注解了 @NumberFormat(",###.##")和@ExcelProperty(converter = BigDecimalNumberConverter.class) 想要的效果是导出的格式类型为数字格式并且带有千位分隔符，但是发现@NumberFormat(",###.##")失效，如果去除converter = BigDecimalNumberConverter.class该注解，导出的带有千位分隔符，但是Excel中保存的为文本类型，不再是数字类型。 **触发Bug的代码** ```java @NumberFormat(",###.##") @ExcelProperty(value ={"测试"}, converter = BigDecimalNumberConverter.class, index=1) private BigDecimal test; ``` **提示的异常或者没有达到的效果** 预期：输出带千位分隔符的数字格式cell 异常：NumberFormat不生效</body>
		<created>2020-04-23 06:23:40</created>
		<closed>2020-04-23 11:02:46</closed>
	</bug>
	<bug>
		<id>1257</id>
		<title>最新的2.2.0-beta2 版本，会出现空行一直读取的问题</title>
		<body>之前的正式版2.1.3 版本没有 </body>
		<created>2020-04-22 02:22:17</created>
		<closed>2020-04-22 11:36:49</closed>
	</bug>
	<bug>
		<id>1255</id>
		<title>动态header导致自动列宽失效</title>
		<body>**触发场景描述**    当存在如下动态header的时候，每一列的列宽默认取title cell的列宽，因为现在是按header的列宽设置data cell的列宽，合并了第一行的header导致后续列宽失效。我认为应该取没有进行过合并的head cell的列宽，而不是默认取一个head cell的列宽。 ![image](https://user-images.githubusercontent.com/22729995/79844957-fb4ffd80-83ee-11ea-97f5-7751bb1e88c4.png)  </body>
		<created>2020-04-21 08:45:59</created>
		<closed>2020-04-27 11:01:16</closed>
	</bug>
	<bug>
		<id>1249</id>
		<title>无法写入行</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 我有一个object  他有一个属性是String eName,最后写入Excel没有显示这一行 **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** </body>
		<created>2020-04-19 13:25:18</created>
		<closed>2020-04-22 09:22:34</closed>
	</bug>
	<bug>
		<id>1246</id>
		<title>在Linux下读取模板出现java.lang.ArrayIndexOutOfBoundsException</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 在Linux下读取模板，会出现com.alibaba.excel.exception.ExcelGenerateException: Create workbook failure错误，在Windows则正常。 EasyExcel版本：2.1.4 POI版本：3.17  这个问题我理解是POI的bug，需要通过修改Linux的字体配置能解决这个问题，建议EasyExcel的开发大大要绕开```SXSSFWorkbook sxss = new SXSSFWorkbook(xssfWorkbook, 500);```这个坑  **触发Bug的代码** ```java    EasyExcel.write(outputStream, XXXX.class).withTemplate(templateInputStream).build(); 或者    try (InputStream templatel = this.getClass().getResourceAsStream("/excel/xxTemplate.xlsx")){ XSSFWorkbook xssfWorkbook = new XSSFWorkbook(templatel); SXSSFWorkbook sxss = new SXSSFWorkbook(xssfWorkbook, 500); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } ``` **提示的异常或者没有达到的效果** com.alibaba.excel.exception.ExcelGenerateException: Create workbook failure         at com.alibaba.excel.context.WriteContextImpl.&lt;init&gt;(WriteContextImpl.java:85)         at com.alibaba.excel.write.ExcelBuilderImpl.&lt;init&gt;(ExcelBuilderImpl.java:35)         at com.alibaba.excel.ExcelWriter.&lt;init&gt;(ExcelWriter.java:47)         at com.alibaba.excel.write.builder.ExcelWriterBuilder.build(ExcelWriterBuilder.java:257) ...... ...... ...... Caused by: java.lang.ArrayIndexOutOfBoundsException: 0         at sun.font.CompositeFont.getSlotFont(CompositeFont.java:375)         at sun.font.CompositeGlyphMapper.initMapper(CompositeGlyphMapper.java:81)         at sun.font.CompositeGlyphMapper.&lt;init&gt;(CompositeGlyphMapper.java:62)         at sun.font.CompositeFont.getMapper(CompositeFont.java:433)         at sun.font.CompositeFont.canDisplay(CompositeFont.java:459)         at java.awt.Font.canDisplayUpTo(Font.java:2063)         at java.awt.font.TextLayout.singleFont(TextLayout.java:470)         at java.awt.font.TextLayout.&lt;init&gt;(TextLayout.java:531)         at org.apache.poi.ss.util.SheetUtil.getDefaultCharWidth(SheetUtil.java:275)         at org.apache.poi.xssf.streaming.AutoSizeColumnTracker.&lt;init&gt;(AutoSizeColumnTracker.java:117)         at org.apache.poi.xssf.streaming.SXSSFSheet.&lt;init&gt;(SXSSFSheet.java:82)         at org.apache.poi.xssf.streaming.SXSSFWorkbook.createAndRegisterSXSSFSheet(SXSSFWorkbook.java:658)         at org.apache.poi.xssf.streaming.SXSSFWorkbook.&lt;init&gt;(SXSSFWorkbook.java:247)         at org.apache.poi.xssf.streaming.SXSSFWorkbook.&lt;init&gt;(SXSSFWorkbook.java:211)         at org.apache.poi.xssf.streaming.SXSSFWorkbook.&lt;init&gt;(SXSSFWorkbook.java:186)         at com.alibaba.excel.util.WorkBookUtil.createWorkBook(WorkBookUtil.java:37)         at com.alibaba.excel.context.WriteContextImpl.&lt;init&gt;(WriteContextImpl.java:83)         ... 56 common frames omitted  **补充说明修改Linux的字体配置的方法** 参考：https://blog.csdn.net/zzzgd_666/article/details/80825545?utm_source=blogxgwz1 在Linux的/etc/fonts/local.conf创建这个文件,然后重启Linux,问题解决! ```xml &lt;?xml version='1.0'?&gt;  &lt;!DOCTYPE fontconfig SYSTEM 'fonts.dtd'&gt;  &lt;fontconfig&gt;  &lt;alias&gt;  &lt;family&gt;serif&lt;/family&gt;  &lt;prefer&gt;&lt;family&gt;Utopia&lt;/family&gt;&lt;/prefer&gt;  &lt;/alias&gt;  &lt;alias&gt; &lt;family&gt;sans-serif&lt;/family&gt;  &lt;prefer&gt;&lt;family&gt;Utopia&lt;/family&gt;&lt;/prefer&gt;  &lt;/alias&gt;  &lt;alias&gt;  &lt;family&gt;monospace&lt;/family&gt; &lt;prefer&gt;&lt;family&gt;Utopia&lt;/family&gt;&lt;/prefer&gt;  &lt;/alias&gt;  &lt;alias&gt;  &lt;family&gt;dialog&lt;/family&gt;  &lt;prefer&gt;&lt;family&gt;Utopia&lt;/family&gt;&lt;/prefer&gt;  &lt;/alias&gt; &lt;alias&gt;  &lt;family&gt;dialoginput&lt;/family&gt;  &lt;prefer&gt;&lt;family&gt;Utopia&lt;/family&gt;&lt;/prefer&gt;  &lt;/alias&gt;  &lt;/fontconfig&gt; ``` </body>
		<created>2020-04-17 10:44:55</created>
		<closed>2020-04-22 10:53:11</closed>
	</bug>
	<bug>
		<id>1244</id>
		<title>本地导出excel没问题，在linux服务器导出的excel文件是损坏的</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 在本地导出excel是正常的，但是在linux服务器导出的excel就是损坏的。  **触发Bug的代码** ```java response.setContentType("application/vnd.ms-excel; charset=utf-8"); response.setCharacterEncoding("utf-8"); String fileName = "汇总报告-" + startDate + "~" + endDate + "数据报表"; response.setHeader("Content-Disposition", "attachment;filename=" + URLEncoder.encode(fileName, "utf-8") + ".xlsx"); EasyExcel.write(response.getOutputStream(), ReportDownloadAllVO.class).autoCloseStream(true).sheet("汇总报告").doWrite(dataListNew); ``` **提示的异常或者没有达到的效果** 没有任何异常，但是导出的excel是损坏的。</body>
		<created>2020-04-17 03:57:58</created>
		<closed>2020-04-22 10:53:41</closed>
	</bug>
	<bug>
		<id>1241</id>
		<title>数据导出单位格为空</title>
		<body>导出excel某个单元格值是空的时候，后面的列也变成空了</body>
		<created>2020-04-16 06:10:22</created>
		<closed>2020-04-17 01:27:30</closed>
	</bug>
	<bug>
		<id>1240</id>
		<title>useDefaultStyle 不创对象的写 不起作用</title>
		<body>**触发场景描述** 不创建对象写 **触发Bug的代码** ```java  try{  List&lt;Map&gt; list = gbxxGbkhService.selectGbkhList(gbxxGbkh); List&lt;SysDictData&gt; dictData = dictDataService.selectDictDataByType("oa_gbxx_khnd");  List&lt;List&lt;String&gt;&gt; head = new ArrayList&lt;&gt;();//execl头 List&lt;List&lt;Object&gt;&gt; body = new ArrayList&lt;&gt;();//execl数据  String mainHeadName = "登记表";  List&lt;String&gt; head_xm = new ArrayList&lt;String&gt;(); head_xm.add(mainHeadName); head_xm.add("姓名"); head.add(head_xm); List&lt;String&gt; head_zw = new ArrayList&lt;String&gt;(); head_zw.add(mainHeadName); head_zw.add("职务"); head.add(head_zw); //生成动态的年份头 for (SysDictData dict:dictData){ List&lt;String&gt; head_temp = new ArrayList&lt;String&gt;(); head_temp.add(mainHeadName); head_temp.add(dict.getDictValue()); head.add(head_temp); } //根据头部顺序生成数据 for (Map map:list){ List&lt;Object&gt; data = new ArrayList&lt;Object&gt;(); //遍历 data.add(map.get("xm")); data.add(map.get("zw")); for (SysDictData dict:dictData){ data.add(map.get(dict.getDictValue())); } body.add(data); }  // 头的样式 WriteCellStyle headWriteCellStyle = new WriteCellStyle();  WriteFont writeFont = new WriteFont(); writeFont.setFontName("宋体");//字体 writeFont.setFontHeightInPoints((short)20);//字体大小 writeFont.setBold(true);//加粗 headWriteCellStyle.setWriteFont(writeFont);  //内容的样式 WriteCellStyle contentWriteCellStyle = new WriteCellStyle(); WriteFont contentWriteFont = new WriteFont(); contentWriteFont.setFontName("宋体");//字体 contentWriteFont.setFontHeightInPoints((short)11);//字体大小 contentWriteCellStyle.setWriteFont(contentWriteFont);    HorizontalCellStyleStrategy horizontalCellStyleStrategy = new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle);  response.setCharacterEncoding("utf-8"); response.setContentType("application/vnd.ms-excel"); response.setHeader("Content-Disposition", "attachment;fileName=" + FileUtils.setFileDownloadHeader(request, "登记表.xlsx"));  EasyExcel.write(response.getOutputStream()) .head(head) .useDefaultStyle(false) .registerWriteHandler(horizontalCellStyleStrategy) .sheet("登记表") .doWrite(body); } catch (Exception e){ e.printStackTrace(); } ``` **提示的异常或者没有达到的效果** 实际效果 ![image](https://user-images.githubusercontent.com/12390935/79420791-38ca1a80-7fec-11ea-8b6f-2235f4f0a232.png)  期望效果 ![image](https://user-images.githubusercontent.com/12390935/79419911-58604380-7fea-11ea-8bec-b24172130807.png)  </body>
		<created>2020-04-16 06:00:04</created>
		<closed>2020-04-16 08:49:47</closed>
	</bug>
	<bug>
		<id>1238</id>
		<title>添加依赖后，mvn启动有错误通过日志无法定位哪里有错误</title>
		<body>**软件的版本** maven  ``` Apache Maven 3.6.2 (40f52333136460af0dc0d7232c0dc0bcf0d9e117; 2019-08-27T23:06:16+08:00) Java version: 1.8.0_221, vendor: Oracle Corporation, runtime: /Library/Java/JavaVirtualMachines/jdk1.8.0_221.jdk/Contents/Home/jre Default locale: zh_CN, platform encoding: UTF-8 OS name: "mac os x", version: "10.15.3", arch: "x86_64", family: "mac" ```  easyexcel  ``` &lt;dependency&gt;             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;             &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;             &lt;version&gt;2.1.6&lt;/version&gt; &lt;/dependency&gt; ```   **触发场景描述** - 添加 easyexcel pom依赖后，`mvn jetty:run` 发生错误，一直有`java.lang.ArrayIndexOutOfBoundsException`, 去掉 easyexcel 依赖后，运行正常。有错误但是能正常启动，功能也正常。很奇怪哪里有问题？  - 刚开始怀疑和pom里面添加的poi 版本引用的jar有冲突，后面尝试 无论是添加还是删除poi的依赖还是有错误。  - 通过依赖树，不确定和哪个类库有冲突。  ```         &lt;dependency&gt;             &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;             &lt;artifactId&gt;poi&lt;/artifactId&gt;             &lt;version&gt;3.17&lt;/version&gt;         &lt;/dependency&gt; ```   这是我 `mvn dependency:tree` 结果  ``` [INFO] [INFO] -----------------------&lt; com.springapp:fdapplus &gt;----------------------- [INFO] Building fdapplus 1.0-SNAPSHOT [INFO] --------------------------------[ jar ]--------------------------------- [INFO] [INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ fdapplus --- [INFO] com.springapp:fdapplus:jar:1.0-SNAPSHOT [INFO] +- org.springframework:spring-core:jar:4.2.3.RELEASE:compile [INFO] |  \- commons-logging:commons-logging:jar:1.2:compile [INFO] +- org.springframework:spring-web:jar:4.2.3.RELEASE:compile [INFO] |  +- org.springframework:spring-aop:jar:4.2.3.RELEASE:compile [INFO] |  |  \- aopalliance:aopalliance:jar:1.0:compile [INFO] |  +- org.springframework:spring-beans:jar:4.2.3.RELEASE:compile [INFO] |  \- org.springframework:spring-context:jar:4.2.3.RELEASE:compile [INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:compile [INFO] +- javax.servlet.jsp:jsp-api:jar:2.1:provided [INFO] +- jstl:jstl:jar:1.2:compile [INFO] +- org.springframework:spring-webmvc:jar:4.2.3.RELEASE:compile [INFO] |  \- org.springframework:spring-expression:jar:4.2.3.RELEASE:compile [INFO] +- org.springframework:spring-jdbc:jar:4.2.3.RELEASE:compile [INFO] |  \- org.springframework:spring-tx:jar:4.2.3.RELEASE:compile [INFO] +- org.springframework:spring-test:jar:4.2.3.RELEASE:test [INFO] +- org.springframework.security:spring-security-crypto:jar:4.2.3.RELEASE:compile [INFO] +- junit:junit:jar:4.9:test [INFO] |  \- org.hamcrest:hamcrest-core:jar:1.1:test [INFO] +- com.microsoft.sqlserver:sqljdbc4:jar:4.0:compile [INFO] +- commons-dbcp:commons-dbcp:jar:1.4:compile [INFO] |  \- commons-pool:commons-pool:jar:1.5.4:compile [INFO] +- com.google.code.gson:gson:jar:1.4:compile [INFO] +- net.sf.json-lib:json-lib:jar:jdk15:2.2.2:compile [INFO] |  +- commons-beanutils:commons-beanutils:jar:1.7.0:compile [INFO] |  +- commons-collections:commons-collections:jar:3.2:compile [INFO] |  +- commons-lang:commons-lang:jar:2.4:compile [INFO] |  \- net.sf.ezmorph:ezmorph:jar:1.0.4:compile [INFO] +- org.slf4j:slf4j-api:jar:1.6.1:compile [INFO] +- org.slf4j:jcl-over-slf4j:jar:1.6.1:runtime [INFO] +- org.slf4j:slf4j-log4j12:jar:1.6.1:runtime [INFO] +- log4j:log4j:jar:1.2.17:compile [INFO] +- org.eclipse.jetty:jetty-servlet:jar:9.0.6.v20130930:compile [INFO] |  \- org.eclipse.jetty:jetty-security:jar:9.0.6.v20130930:compile [INFO] |     \- org.eclipse.jetty:jetty-server:jar:9.0.6.v20130930:compile [INFO] |        +- org.eclipse.jetty:jetty-http:jar:9.0.6.v20130930:compile [INFO] |        \- org.eclipse.jetty:jetty-io:jar:9.0.6.v20130930:compile [INFO] +- org.eclipse.jetty:jetty-webapp:jar:9.0.6.v20130930:compile [INFO] |  \- org.eclipse.jetty:jetty-xml:jar:9.0.6.v20130930:compile [INFO] |     \- org.eclipse.jetty:jetty-util:jar:9.0.6.v20130930:compile [INFO] +- org.eclipse.jetty:jetty-jsp:jar:9.0.6.v20130930:compile [INFO] |  +- org.eclipse.jetty.orbit:javax.servlet.jsp:jar:2.2.0.v201112011158:compile [INFO] |  |  \- org.eclipse.jetty.orbit:javax.servlet:jar:3.0.0.v201112011016:compile [INFO] |  +- org.eclipse.jetty.orbit:org.apache.jasper.glassfish:jar:2.2.2.v201112011158:compile [INFO] |  +- org.eclipse.jetty.orbit:javax.servlet.jsp.jstl:jar:1.2.0.v201105211821:compile [INFO] |  +- org.eclipse.jetty.orbit:org.apache.taglibs.standard.glassfish:jar:1.2.0.v201112081803:compile [INFO] |  +- org.eclipse.jetty.orbit:javax.el:jar:2.2.0.v201303151357:compile [INFO] |  +- org.eclipse.jetty.orbit:com.sun.el:jar:2.2.0.v201303151357:compile [INFO] |  \- org.eclipse.jetty.orbit:org.eclipse.jdt.core:jar:3.8.2.v20130121:compile [INFO] +- commons-io:commons-io:jar:2.4:compile [INFO] +- commons-fileupload:commons-fileupload:jar:1.3:compile [INFO] +- com.itextpdf:itextpdf:jar:5.1.2:compile [INFO] +- com.itextpdf:itext-asian:jar:5.1.1:compile [INFO] +- org.apache.poi:poi:jar:3.17:compile [INFO] |  +- commons-codec:commons-codec:jar:1.10:compile [INFO] |  \- org.apache.commons:commons-collections4:jar:4.1:compile [INFO] +- com.fasterxml.jackson.core:jackson-core:jar:2.2.3:compile [INFO] +- com.fasterxml.jackson.core:jackson-databind:jar:2.2.3:compile [INFO] +- com.fasterxml.jackson.core:jackson-annotations:jar:2.2.3:compile [INFO] +- com.squareup.okhttp3:okhttp:jar:3.4.1:compile [INFO] |  \- com.squareup.okio:okio:jar:1.9.0:compile [INFO] +- com.alibaba:fastjson:jar:1.2.47:compile [INFO] +- dom4j:dom4j:jar:1.6.1:compile [INFO] +- net.lingala.zip4j:zip4j:jar:1.3.2:compile [INFO] +- org.apache.ant:ant:jar:1.8.1:compile [INFO] |  \- org.apache.ant:ant-launcher:jar:1.8.1:compile [INFO] +- com.alibaba:easyexcel:jar:2.1.6:compile [INFO] |  +- org.apache.poi:poi-ooxml:jar:3.17:compile [INFO] |  |  \- com.github.virtuald:curvesapi:jar:1.04:compile [INFO] |  +- cglib:cglib:jar:3.1:compile [INFO] |  |  \- org.ow2.asm:asm:jar:4.2:compile [INFO] |  \- org.ehcache:ehcache:jar:3.7.1:compile [INFO] |     \- org.glassfish.jaxb:jaxb-runtime:jar:2.3.1:compile [INFO] |        +- org.glassfish.jaxb:txw2:jar:2.3.1:compile [INFO] |        +- com.sun.istack:istack-commons-runtime:jar:3.0.7:compile [INFO] |        +- org.jvnet.staxex:stax-ex:jar:1.8:compile [INFO] |        \- com.sun.xml.fastinfoset:FastInfoset:jar:1.2.15:compile [INFO] +- xml-apis:xml-apis:jar:1.4.01:compile [INFO] +- javax.xml.bind:jaxb-api:jar:2.3.1:compile [INFO] |  \- javax.activation:javax.activation-api:jar:1.2.0:compile [INFO] \- org.apache.poi:poi-ooxml-schemas:jar:3.17:compile [INFO]    \- org.apache.xmlbeans:xmlbeans:jar:2.6.0:compile [INFO]       \- stax:stax-api:jar:1.0.1:compile [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ ```  **这是错误的代码** ```bash  [WARNING] Problem processing jar entry org/ehcache/config/Eviction.class java.lang.ArrayIndexOutOfBoundsException: 15931     at org.objectweb.asm.ClassReader.readClass (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.eclipse.jetty.annotations.AnnotationParser.scanClass (AnnotationParser.java:658)     at org.eclipse.jetty.annotations.AnnotationParser$2.processEntry (AnnotationParser.java:630)     at org.eclipse.jetty.webapp.JarScanner.matched (JarScanner.java:155)     at org.eclipse.jetty.util.PatternMatcher.matchPatterns (PatternMatcher.java:82)     at org.eclipse.jetty.util.PatternMatcher.match (PatternMatcher.java:64)     at org.eclipse.jetty.webapp.JarScanner.scan (JarScanner.java:78)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:642)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:651)     at org.eclipse.jetty.annotations.AnnotationConfiguration.parseWebInfLib (AnnotationConfiguration.java:341)     at org.eclipse.jetty.annotations.AnnotationConfiguration.configure (AnnotationConfiguration.java:99)     at org.eclipse.jetty.webapp.WebAppContext.configure (WebAppContext.java:428)     at org.eclipse.jetty.webapp.WebAppContext.startContext (WebAppContext.java:1216)     at org.eclipse.jetty.server.handler.ContextHandler.doStart (ContextHandler.java:699)     at org.eclipse.jetty.webapp.WebAppContext.doStart (WebAppContext.java:454)     at org.mortbay.jetty.plugin.JettyWebAppContext.doStart (JettyWebAppContext.java:256)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart (ContextHandlerCollection.java:167)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerWrapper.doStart (HandlerWrapper.java:90)     at org.eclipse.jetty.server.Server.doStart (Server.java:262)     at org.mortbay.jetty.plugin.JettyServer.doStart (JettyServer.java:65)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty (AbstractJettyMojo.java:511)     at org.mortbay.jetty.plugin.AbstractJettyMojo.execute (AbstractJettyMojo.java:364)     at org.mortbay.jetty.plugin.JettyRunMojo.execute (JettyRunMojo.java:516)     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:498)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347) [WARNING] Problem processing jar entry org/ehcache/config/builders/CacheConfigurationBuilder.class java.lang.ArrayIndexOutOfBoundsException: 61411     at org.objectweb.asm.ClassReader.&lt;init&gt; (Unknown Source)     at org.objectweb.asm.ClassReader.&lt;init&gt; (Unknown Source)     at org.objectweb.asm.ClassReader.&lt;init&gt; (Unknown Source)     at org.eclipse.jetty.annotations.AnnotationParser.scanClass (AnnotationParser.java:657)     at org.eclipse.jetty.annotations.AnnotationParser$2.processEntry (AnnotationParser.java:630)     at org.eclipse.jetty.webapp.JarScanner.matched (JarScanner.java:155)     at org.eclipse.jetty.util.PatternMatcher.matchPatterns (PatternMatcher.java:82)     at org.eclipse.jetty.util.PatternMatcher.match (PatternMatcher.java:64)     at org.eclipse.jetty.webapp.JarScanner.scan (JarScanner.java:78)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:642)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:651)     at org.eclipse.jetty.annotations.AnnotationConfiguration.parseWebInfLib (AnnotationConfiguration.java:341)     at org.eclipse.jetty.annotations.AnnotationConfiguration.configure (AnnotationConfiguration.java:99)     at org.eclipse.jetty.webapp.WebAppContext.configure (WebAppContext.java:428)     at org.eclipse.jetty.webapp.WebAppContext.startContext (WebAppContext.java:1216)     at org.eclipse.jetty.server.handler.ContextHandler.doStart (ContextHandler.java:699)     at org.eclipse.jetty.webapp.WebAppContext.doStart (WebAppContext.java:454)     at org.mortbay.jetty.plugin.JettyWebAppContext.doStart (JettyWebAppContext.java:256)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart (ContextHandlerCollection.java:167)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerWrapper.doStart (HandlerWrapper.java:90)     at org.eclipse.jetty.server.Server.doStart (Server.java:262)     at org.mortbay.jetty.plugin.JettyServer.doStart (JettyServer.java:65)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty (AbstractJettyMojo.java:511)     at org.mortbay.jetty.plugin.AbstractJettyMojo.execute (AbstractJettyMojo.java:364)     at org.mortbay.jetty.plugin.JettyRunMojo.execute (JettyRunMojo.java:516)     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:498)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347) [WARNING] Problem processing jar entry org/ehcache/config/builders/ExpiryPolicyBuilder$TimeToIdleExpiryPolicy.class java.lang.ArrayIndexOutOfBoundsException: 1612     at org.objectweb.asm.ClassReader.readClass (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.eclipse.jetty.annotations.AnnotationParser.scanClass (AnnotationParser.java:658)     at org.eclipse.jetty.annotations.AnnotationParser$2.processEntry (AnnotationParser.java:630)     at org.eclipse.jetty.webapp.JarScanner.matched (JarScanner.java:155)     at org.eclipse.jetty.util.PatternMatcher.matchPatterns (PatternMatcher.java:82)     at org.eclipse.jetty.util.PatternMatcher.match (PatternMatcher.java:64)     at org.eclipse.jetty.webapp.JarScanner.scan (JarScanner.java:78)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:642)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:651)     at org.eclipse.jetty.annotations.AnnotationConfiguration.parseWebInfLib (AnnotationConfiguration.java:341)     at org.eclipse.jetty.annotations.AnnotationConfiguration.configure (AnnotationConfiguration.java:99)     at org.eclipse.jetty.webapp.WebAppContext.configure (WebAppContext.java:428)     at org.eclipse.jetty.webapp.WebAppContext.startContext (WebAppContext.java:1216)     at org.eclipse.jetty.server.handler.ContextHandler.doStart (ContextHandler.java:699)     at org.eclipse.jetty.webapp.WebAppContext.doStart (WebAppContext.java:454)     at org.mortbay.jetty.plugin.JettyWebAppContext.doStart (JettyWebAppContext.java:256)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart (ContextHandlerCollection.java:167)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerWrapper.doStart (HandlerWrapper.java:90)     at org.eclipse.jetty.server.Server.doStart (Server.java:262)     at org.mortbay.jetty.plugin.JettyServer.doStart (JettyServer.java:65)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty (AbstractJettyMojo.java:511)     at org.mortbay.jetty.plugin.AbstractJettyMojo.execute (AbstractJettyMojo.java:364)     at org.mortbay.jetty.plugin.JettyRunMojo.execute (JettyRunMojo.java:516)     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:498)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347) [WARNING] Problem processing jar entry org/ehcache/config/builders/ExpiryPolicyBuilder$TimeToLiveExpiryPolicy.class java.lang.ArrayIndexOutOfBoundsException: 28417     at org.objectweb.asm.ClassReader.readClass (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.eclipse.jetty.annotations.AnnotationParser.scanClass (AnnotationParser.java:658)     at org.eclipse.jetty.annotations.AnnotationParser$2.processEntry (AnnotationParser.java:630)     at org.eclipse.jetty.webapp.JarScanner.matched (JarScanner.java:155)     at org.eclipse.jetty.util.PatternMatcher.matchPatterns (PatternMatcher.java:82)     at org.eclipse.jetty.util.PatternMatcher.match (PatternMatcher.java:64)     at org.eclipse.jetty.webapp.JarScanner.scan (JarScanner.java:78)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:642)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:651)     at org.eclipse.jetty.annotations.AnnotationConfiguration.parseWebInfLib (AnnotationConfiguration.java:341)     at org.eclipse.jetty.annotations.AnnotationConfiguration.configure (AnnotationConfiguration.java:99)     at org.eclipse.jetty.webapp.WebAppContext.configure (WebAppContext.java:428)     at org.eclipse.jetty.webapp.WebAppContext.startContext (WebAppContext.java:1216)     at org.eclipse.jetty.server.handler.ContextHandler.doStart (ContextHandler.java:699)     at org.eclipse.jetty.webapp.WebAppContext.doStart (WebAppContext.java:454)     at org.mortbay.jetty.plugin.JettyWebAppContext.doStart (JettyWebAppContext.java:256)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart (ContextHandlerCollection.java:167)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerWrapper.doStart (HandlerWrapper.java:90)     at org.eclipse.jetty.server.Server.doStart (Server.java:262)     at org.mortbay.jetty.plugin.JettyServer.doStart (JettyServer.java:65)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty (AbstractJettyMojo.java:511)     at org.mortbay.jetty.plugin.AbstractJettyMojo.execute (AbstractJettyMojo.java:364)     at org.mortbay.jetty.plugin.JettyRunMojo.execute (JettyRunMojo.java:516)     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:498)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347) [WARNING] Problem processing jar entry org/ehcache/config/builders/ExpiryPolicyBuilder.class java.lang.ArrayIndexOutOfBoundsException: 28416     at org.objectweb.asm.ClassReader.readClass (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.eclipse.jetty.annotations.AnnotationParser.scanClass (AnnotationParser.java:658)     at org.eclipse.jetty.annotations.AnnotationParser$2.processEntry (AnnotationParser.java:630)     at org.eclipse.jetty.webapp.JarScanner.matched (JarScanner.java:155)     at org.eclipse.jetty.util.PatternMatcher.matchPatterns (PatternMatcher.java:82)     at org.eclipse.jetty.util.PatternMatcher.match (PatternMatcher.java:64)     at org.eclipse.jetty.webapp.JarScanner.scan (JarScanner.java:78)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:642)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:651)     at org.eclipse.jetty.annotations.AnnotationConfiguration.parseWebInfLib (AnnotationConfiguration.java:341)     at org.eclipse.jetty.annotations.AnnotationConfiguration.configure (AnnotationConfiguration.java:99)     at org.eclipse.jetty.webapp.WebAppContext.configure (WebAppContext.java:428)     at org.eclipse.jetty.webapp.WebAppContext.startContext (WebAppContext.java:1216)     at org.eclipse.jetty.server.handler.ContextHandler.doStart (ContextHandler.java:699)     at org.eclipse.jetty.webapp.WebAppContext.doStart (WebAppContext.java:454)     at org.mortbay.jetty.plugin.JettyWebAppContext.doStart (JettyWebAppContext.java:256)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart (ContextHandlerCollection.java:167)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerWrapper.doStart (HandlerWrapper.java:90)     at org.eclipse.jetty.server.Server.doStart (Server.java:262)     at org.mortbay.jetty.plugin.JettyServer.doStart (JettyServer.java:65)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty (AbstractJettyMojo.java:511)     at org.mortbay.jetty.plugin.AbstractJettyMojo.execute (AbstractJettyMojo.java:364)     at org.mortbay.jetty.plugin.JettyRunMojo.execute (JettyRunMojo.java:516)     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:498)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347) [WARNING] Problem processing jar entry org/ehcache/core/Ehcache$Jsr107CacheImpl.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/core/EhcacheBase$Jsr107CacheBase.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/core/EhcacheBase.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/core/EhcacheManager.class java.lang.ArrayIndexOutOfBoundsException: 37883     at org.objectweb.asm.ClassReader.&lt;init&gt; (Unknown Source)     at org.objectweb.asm.ClassReader.&lt;init&gt; (Unknown Source)     at org.objectweb.asm.ClassReader.&lt;init&gt; (Unknown Source)     at org.eclipse.jetty.annotations.AnnotationParser.scanClass (AnnotationParser.java:657)     at org.eclipse.jetty.annotations.AnnotationParser$2.processEntry (AnnotationParser.java:630)     at org.eclipse.jetty.webapp.JarScanner.matched (JarScanner.java:155)     at org.eclipse.jetty.util.PatternMatcher.matchPatterns (PatternMatcher.java:82)     at org.eclipse.jetty.util.PatternMatcher.match (PatternMatcher.java:64)     at org.eclipse.jetty.webapp.JarScanner.scan (JarScanner.java:78)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:642)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:651)     at org.eclipse.jetty.annotations.AnnotationConfiguration.parseWebInfLib (AnnotationConfiguration.java:341)     at org.eclipse.jetty.annotations.AnnotationConfiguration.configure (AnnotationConfiguration.java:99)     at org.eclipse.jetty.webapp.WebAppContext.configure (WebAppContext.java:428)     at org.eclipse.jetty.webapp.WebAppContext.startContext (WebAppContext.java:1216)     at org.eclipse.jetty.server.handler.ContextHandler.doStart (ContextHandler.java:699)     at org.eclipse.jetty.webapp.WebAppContext.doStart (WebAppContext.java:454)     at org.mortbay.jetty.plugin.JettyWebAppContext.doStart (JettyWebAppContext.java:256)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart (ContextHandlerCollection.java:167)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerWrapper.doStart (HandlerWrapper.java:90)     at org.eclipse.jetty.server.Server.doStart (Server.java:262)     at org.mortbay.jetty.plugin.JettyServer.doStart (JettyServer.java:65)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty (AbstractJettyMojo.java:511)     at org.mortbay.jetty.plugin.AbstractJettyMojo.execute (AbstractJettyMojo.java:364)     at org.mortbay.jetty.plugin.JettyRunMojo.execute (JettyRunMojo.java:516)     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:498)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347) [WARNING] Problem processing jar entry org/ehcache/core/config/ExpiryUtils$1.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/core/config/ExpiryUtils$2.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/core/config/ResourcePoolsImpl.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/core/internal/util/ValueSuppliers.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/core/osgi/EhcacheActivator.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/core/osgi/OsgiServiceLoader.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/core/spi/ServiceLocator$DependencySet.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/core/spi/service/ServiceUtils.class java.lang.ArrayIndexOutOfBoundsException: 45312     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.eclipse.jetty.annotations.AnnotationParser.scanClass (AnnotationParser.java:658)     at org.eclipse.jetty.annotations.AnnotationParser$2.processEntry (AnnotationParser.java:630)     at org.eclipse.jetty.webapp.JarScanner.matched (JarScanner.java:155)     at org.eclipse.jetty.util.PatternMatcher.matchPatterns (PatternMatcher.java:82)     at org.eclipse.jetty.util.PatternMatcher.match (PatternMatcher.java:64)     at org.eclipse.jetty.webapp.JarScanner.scan (JarScanner.java:78)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:642)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:651)     at org.eclipse.jetty.annotations.AnnotationConfiguration.parseWebInfLib (AnnotationConfiguration.java:341)     at org.eclipse.jetty.annotations.AnnotationConfiguration.configure (AnnotationConfiguration.java:99)     at org.eclipse.jetty.webapp.WebAppContext.configure (WebAppContext.java:428)     at org.eclipse.jetty.webapp.WebAppContext.startContext (WebAppContext.java:1216)     at org.eclipse.jetty.server.handler.ContextHandler.doStart (ContextHandler.java:699)     at org.eclipse.jetty.webapp.WebAppContext.doStart (WebAppContext.java:454)     at org.mortbay.jetty.plugin.JettyWebAppContext.doStart (JettyWebAppContext.java:256)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart (ContextHandlerCollection.java:167)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerWrapper.doStart (HandlerWrapper.java:90)     at org.eclipse.jetty.server.Server.doStart (Server.java:262)     at org.mortbay.jetty.plugin.JettyServer.doStart (JettyServer.java:65)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty (AbstractJettyMojo.java:511)     at org.mortbay.jetty.plugin.AbstractJettyMojo.execute (AbstractJettyMojo.java:364)     at org.mortbay.jetty.plugin.JettyRunMojo.execute (JettyRunMojo.java:516)     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:498)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347) [WARNING] Problem processing jar entry org/ehcache/core/store/StoreSupport.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/core/util/ClassLoading.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/core/util/CollectionUtil.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/events/CacheEventDispatcherImpl.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/concurrent/ThreadLocalRandomUtil.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/executor/OnDemandExecutionService.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/executor/PartitionedScheduledExecutor.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/loaderwriter/writebehind/BatchingLocalHeapWriteBehindQueue$Batch.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/loaderwriter/writebehind/NonBatchingLocalHeapWriteBehindQueue.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/resilience/AbstractResilienceStrategy.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/statistics/DefaultCacheStatistics.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/statistics/DefaultTierStatistics.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/store/disk/EhcachePersistentConcurrentOffHeapClockCache.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/store/disk/OffHeapDiskStore.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/store/heap/KeyCopyBackend.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/store/heap/OnHeapStore$Provider.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/store/heap/OnHeapStore.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/store/loaderwriter/LocalLoaderWriterStore.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/store/offheap/AbstractOffHeapStore.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/store/offheap/EhcacheConcurrentOffHeapClockCache.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/store/tiering/CompoundCachingTier.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/store/tiering/TieredStore$2.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/internal/store/tiering/TieredStore.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/persistence/FileBasedStateRepository.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/impl/serialization/CompactJavaSerializer.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/jsr107/CloseUtil.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/jsr107/Eh107Cache.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/jsr107/Eh107CacheManager.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/jsr107/Eh107CompleteConfiguration.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/jsr107/EhcacheCachingProvider.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/jsr107/ListenerResources.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/jsr107/Unwrap.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/spi/loaderwriter/BulkCacheWritingException.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/spi/persistence/StateRepository.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/ConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/CoreCacheConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/ResourceConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/ServiceConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/ServiceCreationConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/XmlConfiguration$PrettyClassFormat.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/XmlConfiguration.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/model/CacheSpec.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/multi/XmlMultiConfiguration$VariantConfig.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/multi/XmlMultiConfiguration.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/provider/CacheEventDispatcherFactoryConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/provider/CacheManagerPersistenceConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/provider/DefaultCopyProviderConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/provider/DefaultSerializationProviderConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/provider/DefaultSizeOfEngineProviderConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/provider/OffHeapDiskStoreProviderConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/provider/PooledExecutionServiceConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/provider/SimpleCoreServiceCreationConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/provider/ThreadPoolServiceCreationConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/provider/WriteBehindProviderConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/service/DefaultCacheEventDispatcherConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/service/DefaultCacheEventListenerConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/service/DefaultCacheLoaderWriterConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/service/DefaultResilienceStrategyConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/service/DefaultSizeOfEngineConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/service/DefaultWriteBehindConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/service/OffHeapDiskStoreConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/ehcache/xml/service/SimpleCoreServiceConfigurationParser.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/context/query/Filter.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/offheapstore/OffHeapHashMap.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/offheapstore/buffersource/TimingBufferSource.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/offheapstore/concurrent/AbstractConcurrentOffHeapCache.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/offheapstore/disk/paging/MappedPageSource.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/offheapstore/disk/storage/FileBackedStorageEngine.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/offheapstore/disk/storage/PersistentIntegerStorageEngine.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/offheapstore/disk/storage/PersistentSplitStorageEngine.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/offheapstore/eviction/EvictionListeningReadWriteLockedOffHeapClockCache.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/offheapstore/eviction/EvictionListeningWriteLockedOffHeapClockCache.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/offheapstore/paging/UpfrontAllocatingPageSource.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/offheapstore/storage/IntegerStorageEngine.class java.lang.ArrayIndexOutOfBoundsException: 29556     at org.objectweb.asm.ClassReader.readUTF8 (Unknown Source)     at org.objectweb.asm.ClassReader.readClass (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.eclipse.jetty.annotations.AnnotationParser.scanClass (AnnotationParser.java:658)     at org.eclipse.jetty.annotations.AnnotationParser$2.processEntry (AnnotationParser.java:630)     at org.eclipse.jetty.webapp.JarScanner.matched (JarScanner.java:155)     at org.eclipse.jetty.util.PatternMatcher.matchPatterns (PatternMatcher.java:82)     at org.eclipse.jetty.util.PatternMatcher.match (PatternMatcher.java:64)     at org.eclipse.jetty.webapp.JarScanner.scan (JarScanner.java:78)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:642)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:651)     at org.eclipse.jetty.annotations.AnnotationConfiguration.parseWebInfLib (AnnotationConfiguration.java:341)     at org.eclipse.jetty.annotations.AnnotationConfiguration.configure (AnnotationConfiguration.java:99)     at org.eclipse.jetty.webapp.WebAppContext.configure (WebAppContext.java:428)     at org.eclipse.jetty.webapp.WebAppContext.startContext (WebAppContext.java:1216)     at org.eclipse.jetty.server.handler.ContextHandler.doStart (ContextHandler.java:699)     at org.eclipse.jetty.webapp.WebAppContext.doStart (WebAppContext.java:454)     at org.mortbay.jetty.plugin.JettyWebAppContext.doStart (JettyWebAppContext.java:256)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart (ContextHandlerCollection.java:167)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerWrapper.doStart (HandlerWrapper.java:90)     at org.eclipse.jetty.server.Server.doStart (Server.java:262)     at org.mortbay.jetty.plugin.JettyServer.doStart (JettyServer.java:65)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty (AbstractJettyMojo.java:511)     at org.mortbay.jetty.plugin.AbstractJettyMojo.execute (AbstractJettyMojo.java:364)     at org.mortbay.jetty.plugin.JettyRunMojo.execute (JettyRunMojo.java:516)     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:498)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347) [WARNING] Problem processing jar entry org/terracotta/offheapstore/storage/LongStorageEngine.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/offheapstore/storage/OffHeapBufferHalfStorageEngine.class java.lang.ArrayIndexOutOfBoundsException: 262     at org.objectweb.asm.ClassReader.a (Unknown Source)     at org.objectweb.asm.ClassReader.readUTF8 (Unknown Source)     at org.objectweb.asm.ClassReader.readClass (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.eclipse.jetty.annotations.AnnotationParser.scanClass (AnnotationParser.java:658)     at org.eclipse.jetty.annotations.AnnotationParser$2.processEntry (AnnotationParser.java:630)     at org.eclipse.jetty.webapp.JarScanner.matched (JarScanner.java:155)     at org.eclipse.jetty.util.PatternMatcher.matchPatterns (PatternMatcher.java:82)     at org.eclipse.jetty.util.PatternMatcher.match (PatternMatcher.java:64)     at org.eclipse.jetty.webapp.JarScanner.scan (JarScanner.java:78)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:642)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:651)     at org.eclipse.jetty.annotations.AnnotationConfiguration.parseWebInfLib (AnnotationConfiguration.java:341)     at org.eclipse.jetty.annotations.AnnotationConfiguration.configure (AnnotationConfiguration.java:99)     at org.eclipse.jetty.webapp.WebAppContext.configure (WebAppContext.java:428)     at org.eclipse.jetty.webapp.WebAppContext.startContext (WebAppContext.java:1216)     at org.eclipse.jetty.server.handler.ContextHandler.doStart (ContextHandler.java:699)     at org.eclipse.jetty.webapp.WebAppContext.doStart (WebAppContext.java:454)     at org.mortbay.jetty.plugin.JettyWebAppContext.doStart (JettyWebAppContext.java:256)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart (ContextHandlerCollection.java:167)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerWrapper.doStart (HandlerWrapper.java:90)     at org.eclipse.jetty.server.Server.doStart (Server.java:262)     at org.mortbay.jetty.plugin.JettyServer.doStart (JettyServer.java:65)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty (AbstractJettyMojo.java:511)     at org.mortbay.jetty.plugin.AbstractJettyMojo.execute (AbstractJettyMojo.java:364)     at org.mortbay.jetty.plugin.JettyRunMojo.execute (JettyRunMojo.java:516)     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:498)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347) [WARNING] Problem processing jar entry org/terracotta/offheapstore/storage/OffHeapBufferStorageEngine.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/offheapstore/storage/SerializableStorageEngine.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/offheapstore/storage/SplitStorageEngine.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/offheapstore/storage/StringStorageEngine.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/offheapstore/util/Retryer.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/GeneralOperationStatistic.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/OperationStatistic.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/StatisticsManager.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/Table$Builder.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/TableValueStatistic$Builder.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/TableValueStatistic.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/archive/StatisticArchive.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/derived/histogram/BarSplittingBiasedHistogram.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/derived/histogram/Striped.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/derived/histogram/StripedHistogram.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/derived/latency/DefaultLatencyHistogramStatistic.class java.lang.ArrayIndexOutOfBoundsException: 51966     at org.objectweb.asm.ClassReader.readUTF8 (Unknown Source)     at org.objectweb.asm.ClassReader.readClass (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.eclipse.jetty.annotations.AnnotationParser.scanClass (AnnotationParser.java:658)     at org.eclipse.jetty.annotations.AnnotationParser$2.processEntry (AnnotationParser.java:630)     at org.eclipse.jetty.webapp.JarScanner.matched (JarScanner.java:155)     at org.eclipse.jetty.util.PatternMatcher.matchPatterns (PatternMatcher.java:82)     at org.eclipse.jetty.util.PatternMatcher.match (PatternMatcher.java:64)     at org.eclipse.jetty.webapp.JarScanner.scan (JarScanner.java:78)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:642)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:651)     at org.eclipse.jetty.annotations.AnnotationConfiguration.parseWebInfLib (AnnotationConfiguration.java:341)     at org.eclipse.jetty.annotations.AnnotationConfiguration.configure (AnnotationConfiguration.java:99)     at org.eclipse.jetty.webapp.WebAppContext.configure (WebAppContext.java:428)     at org.eclipse.jetty.webapp.WebAppContext.startContext (WebAppContext.java:1216)     at org.eclipse.jetty.server.handler.ContextHandler.doStart (ContextHandler.java:699)     at org.eclipse.jetty.webapp.WebAppContext.doStart (WebAppContext.java:454)     at org.mortbay.jetty.plugin.JettyWebAppContext.doStart (JettyWebAppContext.java:256)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart (ContextHandlerCollection.java:167)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerWrapper.doStart (HandlerWrapper.java:90)     at org.eclipse.jetty.server.Server.doStart (Server.java:262)     at org.mortbay.jetty.plugin.JettyServer.doStart (JettyServer.java:65)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty (AbstractJettyMojo.java:511)     at org.mortbay.jetty.plugin.AbstractJettyMojo.execute (AbstractJettyMojo.java:364)     at org.mortbay.jetty.plugin.JettyRunMojo.execute (JettyRunMojo.java:516)     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:498)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347) [WARNING] Problem processing jar entry org/terracotta/statistics/derived/latency/Jsr107LatencyMonitor.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/derived/latency/LatencyAccumulator.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/derived/latency/LatencyHistogramStatistic.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/derived/latency/LatencyStatistic.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/derived/latency/MaximumLatencyHistory.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/registry/Statistic.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry org/terracotta/statistics/registry/StatisticRegistry.class java.lang.ArrayIndexOutOfBoundsException [WARNING] Problem processing jar entry META-INF/versions/9/javax/xml/bind/ModuleUtil.class java.lang.ArrayIndexOutOfBoundsException: 58369     at org.objectweb.asm.ClassReader.readClass (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.objectweb.asm.ClassReader.accept (Unknown Source)     at org.eclipse.jetty.annotations.AnnotationParser.scanClass (AnnotationParser.java:658)     at org.eclipse.jetty.annotations.AnnotationParser$2.processEntry (AnnotationParser.java:630)     at org.eclipse.jetty.webapp.JarScanner.matched (JarScanner.java:155)     at org.eclipse.jetty.util.PatternMatcher.matchPatterns (PatternMatcher.java:82)     at org.eclipse.jetty.util.PatternMatcher.match (PatternMatcher.java:64)     at org.eclipse.jetty.webapp.JarScanner.scan (JarScanner.java:78)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:642)     at org.eclipse.jetty.annotations.AnnotationParser.parse (AnnotationParser.java:651)     at org.eclipse.jetty.annotations.AnnotationConfiguration.parseWebInfLib (AnnotationConfiguration.java:341)     at org.eclipse.jetty.annotations.AnnotationConfiguration.configure (AnnotationConfiguration.java:99)     at org.eclipse.jetty.webapp.WebAppContext.configure (WebAppContext.java:428)     at org.eclipse.jetty.webapp.WebAppContext.startContext (WebAppContext.java:1216)     at org.eclipse.jetty.server.handler.ContextHandler.doStart (ContextHandler.java:699)     at org.eclipse.jetty.webapp.WebAppContext.doStart (WebAppContext.java:454)     at org.mortbay.jetty.plugin.JettyWebAppContext.doStart (JettyWebAppContext.java:256)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.server.handler.ContextHandlerCollection.doStart (ContextHandlerCollection.java:167)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerCollection.doStart (HandlerCollection.java:224)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.eclipse.jetty.server.handler.HandlerWrapper.doStart (HandlerWrapper.java:90)     at org.eclipse.jetty.server.Server.doStart (Server.java:262)     at org.mortbay.jetty.plugin.JettyServer.doStart (JettyServer.java:65)     at org.eclipse.jetty.util.component.AbstractLifeCycle.start (AbstractLifeCycle.java:59)     at org.mortbay.jetty.plugin.AbstractJettyMojo.startJetty (AbstractJettyMojo.java:511)     at org.mortbay.jetty.plugin.AbstractJettyMojo.execute (AbstractJettyMojo.java:364)     at org.mortbay.jetty.plugin.JettyRunMojo.execute (JettyRunMojo.java:516)     at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo (DefaultBuildPluginManager.java:137)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:210)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:156)     at org.apache.maven.lifecycle.internal.MojoExecutor.execute (MojoExecutor.java:148)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:117)     at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject (LifecycleModuleBuilder.java:81)     at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build (SingleThreadedBuilder.java:56)     at org.apache.maven.lifecycle.internal.LifecycleStarter.execute (LifecycleStarter.java:128)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:305)     at org.apache.maven.DefaultMaven.doExecute (DefaultMaven.java:192)     at org.apache.maven.DefaultMaven.execute (DefaultMaven.java:105)     at org.apache.maven.cli.MavenCli.execute (MavenCli.java:956)     at org.apache.maven.cli.MavenCli.doMain (MavenCli.java:288)     at org.apache.maven.cli.MavenCli.main (MavenCli.java:192)     at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke (Method.java:498)     at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced (Launcher.java:282)     at org.codehaus.plexus.classworlds.launcher.Launcher.launch (Launcher.java:225)     at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode (Launcher.java:406)     at org.codehaus.plexus.classworlds.launcher.Launcher.main (Launcher.java:347) [INFO] No Spring WebApplicationInitializer types detected on classpath ``` </body>
		<created>2020-04-15 13:56:32</created>
		<closed>2020-04-30 10:41:25</closed>
	</bug>
	<bug>
		<id>1234</id>
		<title>导入精准度问题</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** listener这样接受 invoke(Map&lt;Integer, String&gt; prop, AnalysisContext analysisContext)  excel中是11.111，prop中会变成11.111000000001 excel中是2020/9/14，prop中会变成44088 ![image](https://user-images.githubusercontent.com/42863611/79115232-e4d6f000-7db7-11ea-9a2d-a455835ab2a0.png) ![image](https://user-images.githubusercontent.com/42863611/79115251-f7512980-7db7-11ea-962c-0d41845cbe62.png)    **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** </body>
		<created>2020-04-13 10:52:59</created>
		<closed>2020-04-22 10:50:27</closed>
	</bug>
	<bug>
		<id>1232</id>
		<title>如果表格后面一列为空，前一列过长，前一列就会把后面的列占据</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 如题 **触发Bug的代码** ```java    // 长数据格式    .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy()) ``` **提示的异常或者没有达到的效果** 没有达到想要的效果，由于模板是动态的，所以不可能事先指定列宽。不知道能否支持自动拉宽列</body>
		<created>2020-04-13 07:48:38</created>
		<closed>2020-04-22 10:59:46</closed>
	</bug>
	<bug>
		<id>1231</id>
		<title>EasyExcel.writeTable方法里含有registerWriteHandler，却不生效</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 只能在EasyExcel.write或者EasyExcel.writerSheet中注册writeHandler，如果我想实现一个sheet两个表头，不同风格我想用两个table弄进去，并且设置为两个表头样式，目前是不支持吗？ **触发Bug的代码** ```java    WriteTable writeTable0 = EasyExcel.writerTable(0)                 .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy())                 .needHead(Boolean.TRUE)                 .head(head)                 .build(); ``` **提示的异常或者没有达到的效果** registerWriteHandler不生效</body>
		<created>2020-04-13 07:34:24</created>
		<closed>2020-04-15 07:57:44</closed>
	</bug>
	<bug>
		<id>1230</id>
		<title>表头和内容同时设置垂直居中，内容设置失效</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 两个同时设置垂直居中，内容部分设置失效，只能设置为水平居中，达成居中的效果 **触发Bug的代码** ```java   // 垂直居中   headWriteCellStyle.setVerticalAlignment(VerticalAlignment.CENTER);   // 垂直居中   contentWriteCellStyle.setVerticalAlignment(VerticalAlignment.CENTER);   // 水平居中   // contentWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER); ``` **提示的异常或者没有达到的效果** 存在使用上bug</body>
		<created>2020-04-13 06:22:38</created>
		<closed>2020-04-15 07:57:01</closed>
	</bug>
	<bug>
		<id>1229</id>
		<title>自定义样式设置颜色代码不起作用</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 最新beat版头部设置，很多都不起作用，包括我前面提的setHidden **触发Bug的代码** ```java    WriteCellStyle headWriteCellStyle = new WriteCellStyle();    headWriteCellStyle.setFillBackgroundColor(IndexedColors.RED.getIndex()); ``` **提示的异常或者没有达到的效果** 没有效果</body>
		<created>2020-04-13 06:05:35</created>
		<closed>2020-04-13 06:38:42</closed>
	</bug>
	<bug>
		<id>1228</id>
		<title>easyexcel使用中关于jar依赖的一个疑问</title>
		<body>**触发场景描述** ```java // 代码： public static void main(String[] args) throws Exception {         InputStream is = new FileInputStream("/dev_test/aa.xlsx");         EasyExcel.read(is, ImportData.class, new ReadExcelUtils&lt;Object&gt;()).sheet().doRead();     } ``` // jar 依赖： ```xml &lt;dependency&gt;             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;             &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;             &lt;version&gt;2.1.6&lt;/version&gt; &lt;/dependency&gt; ``` // 异常错误： ```java Exception in thread "main" com.alibaba.excel.exception.ExcelAnalysisException: java.lang.NoSuchMethodError: org.apache.poi.util.POILogger.log(ILjava/lang/Object;Ljava/lang/Throwable;)V  Caused by: java.lang.NoSuchMethodError: org.apache.poi.util.POILogger.log(ILjava/lang/Object;Ljava/lang/Throwable;)V ``` // 加上了 poi jar依赖就好了： ```xml         &lt;dependency&gt;             &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;             &lt;artifactId&gt;poi&lt;/artifactId&gt;             &lt;version&gt;3.17&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;             &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt;             &lt;version&gt;3.17&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;org.apache.poi&lt;/groupId&gt;             &lt;artifactId&gt;poi-ooxml-schemas&lt;/artifactId&gt;             &lt;version&gt;3.17&lt;/version&gt;         &lt;/dependency&gt;         &lt;dependency&gt;             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;             &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;             &lt;version&gt;2.1.6&lt;/version&gt;         &lt;/dependency&gt; ``` **疑问** 内部已经依赖了 poi jar，为什么我们使用还得加一下。 </body>
		<created>2020-04-13 03:40:27</created>
		<closed>2020-04-22 11:00:21</closed>
	</bug>
	<bug>
		<id>1227</id>
		<title>setHidden无效</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 使用自定义样式配置Hidden，无法隐藏行 **触发Bug的代码** ```java    WriteCellStyle headWriteCellStyle= new WriteCellStyle();         headWriteCellStyle.setHidden(true); ``` **提示的异常或者没有达到的效果** 设置Hidden没有效果</body>
		<created>2020-04-13 03:19:10</created>
		<closed>2020-04-15 07:56:50</closed>
	</bug>
	<bug>
		<id>1218</id>
		<title>头部的标题对应的index不是读取的注解ExcelProperty中的index</title>
		<body>如题</body>
		<created>2020-04-08 05:37:45</created>
		<closed>2020-04-22 11:04:45</closed>
	</bug>
	<bug>
		<id>1217</id>
		<title>web 下载的时候，数据量超过10000条，使用多次写入的方式，文件下载成功，但是文件打开的时候报部分内容有问题</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述**  **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** </body>
		<created>2020-04-08 02:55:04</created>
		<closed>2020-04-09 10:06:23</closed>
	</bug>
	<bug>
		<id>1213</id>
		<title>类的成员变量名是类似aBc这样的单个小写字母后面跟一个大写字母的情况，导出excel会没有值</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 类的成员变量名是类似aBc这样的单个小写字母后面跟一个大写字母的情况，导出excel会没有值 **触发Bug的代码** ```java     @Test     public void simpleWrite() {         String fileName = TestFileUtil.getPath() + "write" + System.currentTimeMillis() + ".xlsx";         EasyExcel.write(fileName, DemoData.class).sheet("模板").doWrite(data());     }  @Data class DemoData {         @ExcelProperty("aB)         private String aB; } ``` **提示的异常或者没有达到的效果** 导出的excel aB这列没有数据填充</body>
		<created>2020-04-02 11:07:37</created>
		<closed>2020-04-02 11:36:46</closed>
	</bug>
	<bug>
		<id>1210</id>
		<title>NumberFormatException 报错，并未被onException捕获</title>
		<body>**触发场景描述** 版本2.1.6，导入时报错 **触发Bug的代码** ```java EasyExcel.read(file.getInputStream(), dataClass, readListener).sheet().doRead(); ``` 正常的读取，invoke正常的数据会进，但一到有问题的那行就会报错，并且不会被onException捕获 **提示的异常或者没有达到的效果** 经过反复debug，发现问题数据，excel中有个字段为 `#NUM!`，我不知道这个是否触发什么关键字或者变量，一解析到那行就出现上述问题，把这个字符改掉后正常</body>
		<created>2020-04-01 08:41:59</created>
		<closed>2020-05-14 07:22:00</closed>
	</bug>
	<bug>
		<id>1207</id>
		<title>解析数据抛异常</title>
		<body>  java.lang.IllegalArgumentException: Unquoted special character ';' in pattern "#,##0;-#,##0;-??;@" at java.text.DecimalFormat.applyPattern(DecimalFormat.java:3256) at java.text.DecimalFormat.&lt;init&gt;(DecimalFormat.java:464) at com.alibaba.excel.metadata.DataFormatter$InternalDecimalFormatWithScale.&lt;init&gt;(DataFormatter.java:457) at com.alibaba.excel.metadata.DataFormatter.createNumberFormat(DataFormatter.java:520) at com.alibaba.excel.metadata.DataFormatter.createFormat(DataFormatter.java:253) at com.alibaba.excel.metadata.DataFormatter.getFormat(DataFormatter.java:174) at com.alibaba.excel.metadata.DataFormatter.getFormattedNumberString(DataFormatter.java:585) at com.alibaba.excel.metadata.DataFormatter.format(DataFormatter.java:602) at com.alibaba.excel.util.NumberDataFormatterUtils.format(NumberDataFormatterUtils.java:39) at com.alibaba.excel.converters.string.StringNumberConverter.convertToJavaData(StringNumberConverter.java:50) at com.alibaba.excel.converters.string.StringNumberConverter.convertToJavaData(StringNumberConverter.java:22) at com.alibaba.excel.util.ConverterUtils.doConvertToJavaObject(ConverterUtils.java:133) at com.alibaba.excel.util.ConverterUtils.convertToJavaObject(ConverterUtils.java:103) at com.alibaba.excel.read.listener.ModelBuildEventListener.buildStringList(ModelBuildEventListener.java:62) at com.alibaba.excel.read.listener.ModelBuildEventListener.invoke(ModelBuildEventListener.java:41) at com.alibaba.excel.read.listener.ModelBuildEventListener.invoke(ModelBuildEventListener.java:28) at com.alibaba.excel.read.processor.DefaultAnalysisEventProcessor.dealData(DefaultAnalysisEventProcessor.java:100) at com.alibaba.excel.read.processor.DefaultAnalysisEventProcessor.endRow(DefaultAnalysisEventProcessor.java:47) at com.alibaba.excel.analysis.v07.handlers.RowTagHandler.endElement(RowTagHandler.java:46) at com.alibaba.excel.analysis.v07.handlers.sax.XlsxRowHandler.endElement(XlsxRowHandler.java:89) at org.apache.xerces.parsers.AbstractSAXParser.endElement(Unknown Source)</body>
		<created>2020-03-31 09:53:21</created>
		<closed>2020-04-24 10:50:35</closed>
	</bug>
	<bug>
		<id>1202</id>
		<title>tableWrite写入多个table，每个table对应不同的实例，实例中添加样式注解，报错</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 版本 2.2.0-beta2 使用tableWrite方式写入，两个table对应两个类DemoData1，DemoData2。DemoData1和DemoData2中有添加样式@HeadStyle(fillPatternType = FillPatternType.SOLID_FOREGROUND, fillForegroundColor = 42) java.lang.NullPointerException: null at com.alibaba.excel.util.StyleUtil.buildDefaultCellStyle(StyleUtil.java:27) at com.alibaba.excel.util.StyleUtil.buildHeadCellStyle(StyleUtil.java:49) at com.alibaba.excel.write.style.AbstractVerticalCellStyleStrategy.setHeadCellStyle(AbstractVerticalCellStyleStrategy.java:45) at com.alibaba.excel.write.style.AbstractCellStyleStrategy.afterCellDispose(AbstractCellStyleStrategy.java:56) at com.alibaba.excel.util.WriteHandlerUtils.afterCellDispose(WriteHandlerUtils.java:159)  **触发Bug的代码** ```java    @Test     public void tableWrite() {         String fileName = TestFileUtil.getPath() + "tableWrite" + System.currentTimeMillis() + ".xlsx";         // 这里直接写多个table的案例了，如果只有一个 也可以直一行代码搞定，参照其他案例         // 这里 需要指定写用哪个class去写         ExcelWriter excelWriter = EasyExcel.write(fileName).build();         // 把sheet设置为不需要头 不然会输出sheet的头 这样看起来第一个table 就有2个头了         WriteSheet writeSheet = EasyExcel.writerSheet("模板").needHead(Boolean.FALSE).build();         // 这里必须指定需要头，table 会继承sheet的配置，sheet配置了不需要，table 默认也是不需要         WriteTable writeTable0 = EasyExcel.writerTable(0).head(, DemoData1.class).needHead(Boolean.TRUE).build();         WriteTable writeTable1 = EasyExcel.writerTable(1).head(, DemoData2.class).needHead(Boolean.TRUE).build();         // 第一次写入会创建头         excelWriter.write(data(), writeSheet, writeTable0);         // 第二次写如也会创建头，然后在第一次的后面写入数据         excelWriter.write(data(), writeSheet, writeTable1);         /// 千万别忘记finish 会帮忙关闭流         excelWriter.finish();     } ``` **提示的异常或者没有达到的效果** </body>
		<created>2020-03-30 05:48:17</created>
		<closed>2020-04-24 11:38:39</closed>
	</bug>
	<bug>
		<id>1196</id>
		<title>实体类不支持Lombok @Accessors(chain = true)链式编程,有这个注解那么全部就读取为null</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述**  **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** ![image](https://user-images.githubusercontent.com/43667484/77813206-b41d6800-70e1-11ea-847f-b858036d44bd.png)  ![image](https://user-images.githubusercontent.com/43667484/77813211-bb447600-70e1-11ea-8887-6fa319121dc5.png) ![Uploading image.png…]()  </body>
		<created>2020-03-28 02:49:04</created>
		<closed>2020-04-22 11:10:57</closed>
	</bug>
	<bug>
		<id>1195</id>
		<title>列宽设置并不精确</title>
		<body> x为设置列宽 y为实际结果 x | y -- | -- 54 | 49.5 50 | 45.79 55 | 50.43 20 | 17.93 30 | 27.21 40 | 36.5 10 | 8.64 60 | 55.07 70 | 64.36 80 | 73.64 27 | 24.43 25 | 22.57 101 | 93.14 18 | 16.07 25 | 22.57 17 | 15.14 </body>
		<created>2020-03-27 08:31:46</created>
		<closed>2020-04-22 11:24:35</closed>
	</bug>
	<bug>
		<id>1186</id>
		<title>多次导出后会白屏</title>
		<body>不刷新页面多次连续导出会白屏，报错： com.alibaba.excel.exception.ExcelGenerateException: Can not close IO.         at com.alibaba.excel.context.WriteContextImpl.finish(WriteContextImpl.java:331)         at com.alibaba.excel.write.ExcelBuilderImpl.finish(ExcelBuilderImpl.java:101)         at com.alibaba.excel.ExcelWriter.finish(ExcelWriter.java:328)         at com.alibaba.excel.write.builder.ExcelWriterSheetBuilder.doWrite(ExcelWriterSheetBuilder.java:191)</body>
		<created>2020-03-25 09:53:17</created>
		<closed>2020-05-14 07:21:44</closed>
	</bug>
	<bug>
		<id>1185</id>
		<title>这个错误怎么解决呢？com.alibaba.excel.exception.ExcelAnalysisException: java.lang.NoClassDefFoundError: org/ehcache/config/ResourceUnit</title>
		<body>在使用的时候后台报错。这个怎么解决呢。。错误如下 com.alibaba.excel.exception.ExcelAnalysisException: java.lang.NoClassDefFoundError: org/ehcache/config/ResourceUnit at com.alibaba.excel.analysis.ExcelAnalyserImpl.&lt;init&gt;(ExcelAnalyserImpl.java:51) at com.alibaba.excel.ExcelReader.&lt;init&gt;(ExcelReader.java:143) at com.alibaba.excel.read.builder.ExcelReaderBuilder.build(ExcelReaderBuilder.java:270) at com.jyd.serviceModule.taskinfo.controller.TaskInfoController.uploadExcelNew(TaskInfoController.java:294) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.jfinal.aop.Invocation.invoke(Invocation.java:75) at com.jfinal.ext.interceptor.SessionInViewInterceptor.intercept(SessionInViewInterceptor.java:44) at com.jfinal.aop.Invocation.invoke(Invocation.java:69) at com.jyd.interceptors.LoginInterceptor.intercept(LoginInterceptor.java:63) at com.jfinal.aop.Invocation.invoke(Invocation.java:69) at com.jfinal.core.ActionHandler.handle(ActionHandler.java:81) at com.jfinal.core.JFinalFilter.doFilter(JFinalFilter.java:89) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:137) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:660) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:798) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:808) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1498) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.NoClassDefFoundError: org/ehcache/config/ResourceUnit at com.alibaba.excel.cache.selector.SimpleReadCacheSelector.readCache(SimpleReadCacheSelector.java:80) at com.alibaba.excel.analysis.v07.XlsxSaxAnalyser.defaultReadCache(XlsxSaxAnalyser.java:93) at com.alibaba.excel.analysis.v07.XlsxSaxAnalyser.&lt;init&gt;(XlsxSaxAnalyser.java:67) at com.alibaba.excel.analysis.ExcelAnalyserImpl.choiceExcelExecutor(ExcelAnalyserImpl.java:92) at com.alibaba.excel.analysis.ExcelAnalyserImpl.&lt;init&gt;(ExcelAnalyserImpl.java:45) ... 33 more Caused by: java.lang.ClassNotFoundException: org.ehcache.config.ResourceUnit at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1364) at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1185) ... 38 more</body>
		<created>2020-03-25 09:27:29</created>
		<closed>2020-04-22 11:31:05</closed>
	</bug>
	<bug>
		<id>1183</id>
		<title>写出到多个sheet，不同的对象，设置了头部样式和内容样式，但是只有Sheet1有，但是Sheet2没有</title>
		<body>**建议先去看文档** [快速开始](https://www.yuque.com/easyexcel/doc/easyexcel) 、[常见问题](https://www.yuque.com/easyexcel/faq) **触发场景描述** 写出到多个sheet，不同的对象，设置了头部样式和内容样式，但是只有Sheet1有样式，Sheet2没有样式，版本：2.2.0-beta2 **触发Bug的代码** ```java    private static HorizontalCellStyleStrategy getStyle(){         // 头的策略         WriteCellStyle headWriteCellStyle = new WriteCellStyle();         // 背景设置为白色         headWriteCellStyle.setFillForegroundColor(IndexedColors.WHITE.getIndex());         WriteFont headWriteFont = new WriteFont();         headWriteFont.setBold(false);         headWriteFont.setFontHeightInPoints((short)10);         headWriteCellStyle.setWriteFont(headWriteFont);         headWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER); //居中对齐          // 内容的策略         WriteCellStyle contentWriteCellStyle = new WriteCellStyle();         WriteFont contentWriteFont = new WriteFont();         // 字体大小         contentWriteFont.setFontHeightInPoints((short)10);         contentWriteFont.setFontName("宋体");         contentWriteCellStyle.setWriteFont(contentWriteFont);         contentWriteCellStyle.setBorderLeft(BorderStyle.THIN);         contentWriteCellStyle.setBorderTop(BorderStyle.THIN);         contentWriteCellStyle.setBorderRight(BorderStyle.THIN);         contentWriteCellStyle.setBorderBottom(BorderStyle.THIN);          // 这个策略是 头是头的样式 内容是内容的样式 其他的策略可以自己实现         return new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle);     }  @Data @Builder public class User {      @ExcelProperty("用户名")     private String username;      @ExcelProperty("性别")     private String sex;  }  @Data @Builder public class Dept {      @ContentStyle(horizontalAlignment = HorizontalAlignment.CENTER)     @ExcelProperty("部门名称")     private String deptName;      @ExcelProperty(value = "时间", converter = LocalDateTimeConverter.class)     @DateTimeFormat("yyyy-MM-dd HH:mm:ss")     private LocalDateTime createTime;  }    public static void multiSheet2(String exportPath){          ExcelWriter excelWriter = EasyExcel.write(exportPath)                 .registerConverter(new LocalDateTimeConverter())                 .registerWriteHandler(getStyle())                 .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy()) //列宽度自适应                 .build();          WriteSheet writeSheet1 = EasyExcel.writerSheet(0, "Sheet1").head(User.class).build();         excelWriter.write(data1(), writeSheet1);          WriteSheet writeSheet2 = EasyExcel.writerSheet(1, "Sheet2").head(Dept.class).build();         excelWriter.write(data2(), writeSheet2);          /// 千万别忘记finish 会帮忙关闭流         excelWriter.finish();     } ``` **提示的异常或者没有达到的效果** ![image](https://user-images.githubusercontent.com/33519774/77426685-f1e36d80-6e0f-11ea-87e2-027c54a9e56b.png) ![image](https://user-images.githubusercontent.com/33519774/77426733-0c1d4b80-6e10-11ea-8af2-094fa648323a.png)  </body>
		<created>2020-03-24 12:44:11</created>
		<closed>2020-04-24 07:55:06</closed>
	</bug>
	<bug>
		<id>1174</id>
		<title>图片重复写入的问题</title>
		<body>您好： 根据所给文档  [https : //www.yuque.com/easyexcel/faq/wpedtd](url)    在设置自定义图片属性以后  发现图片重复写入了   两张重叠图片  一张是自定义属性的图片                     一张是非自定义属性图片  </body>
		<created>2020-03-20 07:52:44</created>
		<closed>2020-03-24 07:14:56</closed>
	</bug>
	<bug>
		<id>1170</id>
		<title>自动列宽的功能有静态变量的bug</title>
		<body> **触发场景描述** 自动列宽(使用的人可能不多,LongestMatchColumnWidthStyleStrategy)的缓存CACHE为全局静态变量,此map的key是SheetNo(且未做非空限制),会导致不同的excel使用同一个列宽的配置.我暂时通过重写StyleStrategy类覆盖来解决. **触发Bug的代码** ``` private static final Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; CACHE = new HashMap&lt;Integer, Map&lt;Integer, Integer&gt;&gt;(8); ```  ``` Map&lt;Integer, Integer&gt; maxColumnWidthMap = CACHE.get(writeSheetHolder.getSheetNo()); ```  </body>
		<created>2020-03-19 12:08:50</created>
		<closed>2020-03-23 11:35:08</closed>
	</bug>
	<bug>
		<id>1158</id>
		<title>读取浮点，精度丢失</title>
		<body>**触发场景描述**  **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** </body>
		<created>2020-03-13 06:48:21</created>
		<closed>2020-03-16 18:10:29</closed>
	</bug>
	<bug>
		<id>1154</id>
		<title>写入50万行，但是打开就65533行</title>
		<body>**触发场景描述** 写入50万行打开就65533行 **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** </body>
		<created>2020-03-12 04:12:34</created>
		<closed>2020-03-16 14:51:42</closed>
	</bug>
	<bug>
		<id>1153</id>
		<title>参照文档 web下载的demo 出现一个异常</title>
		<body>**触发场景描述**  **触发Bug的代码** ```java @RequestMapping("download") public ModelAndView download(HttpServletResponse response, Date startCreateTime,Date endCreateTime) { try { ServletOutputStream outputStream = response.getOutputStream(); String fileName = URLEncoder.encode("("+ DateUtil.formatDateTime(startCreateTime)+" - "+DateUtil.formatDateTime(endCreateTime) +")", "UTF-8"); List&lt;QuizPlanData&gt; quizPlanData = packageData(startCreateTime, endCreateTime); if (CollectionUtil.isNotEmpty(quizPlanData)){ EasyExcel.write(outputStream, QuizPlanData.class).sheet("33").doWrite(quizPlanData); }else { return ajaxFailure("无符合条件的数据!"); } response.setHeader("Content-disposition", "attachment;filename=" + fileName + ".xlsx"); response.setContentType("application/vnd.ms-excel"); response.setCharacterEncoding("utf-8"); return ajaxSuccess("获取成功!", false); } catch (Exception e) { logger.error("查询区间 [{}] - [{}] 方案详情异常", DateUtil.formatDateTime(startCreateTime),DateUtil.formatDateTime(endCreateTime),e); } return ajaxFailure("查询异常!"); }  **提示的异常或者没有达到的效果** ```java `java.lang.IllegalStateException: getOutputStream() has already been called for this response at org.apache.catalina.connector.Response.getWriter(Response.java:564) at org.apache.catalina.connector.ResponseFacade.getWriter(ResponseFacade.java:212) at javax.servlet.ServletResponseWrapper.getWriter(ServletResponseWrapper.java:109) at org.apache.jasper.runtime.JspWriterImpl.initOut(JspWriterImpl.java:115) at org.apache.jasper.runtime.JspWriterImpl.flushBuffer(JspWriterImpl.java:108) at org.apache.jasper.runtime.PageContextImpl.release(PageContextImpl.java:176) at org.apache.jasper.runtime.JspFactoryImpl.internalReleasePageContext(JspFactoryImpl.java:120) at org.apache.jasper.runtime.JspFactoryImpl.releasePageContext(JspFactoryImpl.java:75) at org.apache.jsp.WEB_002dINF.jsp.ajaxDone_jsp._jspService(ajaxDone_jsp.java:149) at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70) at javax.servlet.http.HttpServlet.service(HttpServlet.java:729) at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:438) at org.apache.jasper.servlet.JspServlet._serviceJspFile(JspServlet.java:396) at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:40001) at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:340) at javax.servlet.http.HttpServlet.service(HttpServlet.java:729) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:292) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:716) at org.apache.catalina.core.ApplicationDispatcher.doInclude(ApplicationDispatcher.java:584) at org.apache.catalina.core.ApplicationDispatcher.include(ApplicationDispatcher.java:523) at org.springframework.web.servlet.view.InternalResourceView.renderMergedOutputModel(InternalResourceView.java:160) at org.springframework.web.servlet.view.AbstractView.render(AbstractView.java:303) at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1257) at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1037) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:980) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:897) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872) at javax.servlet.http.HttpServlet.service(HttpServlet.java:648) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) at javax.servlet.http.HttpServlet.service(HttpServlet.java:729) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:292) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:240) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:207) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:212) at org.apache.catalina.core.StandardContextValve.__invoke(StandardContextValve.java:94) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:40002) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:504) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:141) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:620) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:88) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:502) at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1132) at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:684) at org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.doRun(AprEndpoint.java:2527) at org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:2516) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745)` ```    </body>
		<created>2020-03-11 10:49:32</created>
		<closed>2020-03-16 14:56:07</closed>
	</bug>
	<bug>
		<id>1148</id>
		<title>普通下载时，提示文件损坏</title>
		<body>**触发场景描述**  **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** </body>
		<created>2020-03-11 07:33:53</created>
		<closed>2020-03-16 15:29:56</closed>
	</bug>
	<bug>
		<id>1147</id>
		<title>多次执行测试用例imageWrite(),前几次能成功，后几次运行失败</title>
		<body>**触发场景描述** 多次执行测试用例imageWrite(),前几次能成功，后几次运行失败，运行失败后打开对应是生成的Excel文件，提示文件损坏。 **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** 2020-03-10 19:29:47.864 DEBUG [main] com.alibaba.excel.context.WriteContextImpl:78 - Begin to Initialization 'WriteContextImpl' 2020-03-10 19:29:47.879 DEBUG [main] com.alibaba.excel.metadata.property.ExcelHeadProperty:95 - The initialization sheet/table 'ExcelHeadProperty' is complete , head kind is CLASS 2020-03-10 19:29:47.895 DEBUG [main] com.alibaba.excel.context.WriteContextImpl:97 - CurrentConfiguration is writeWorkbookHolder 2020-03-10 19:29:48.176 DEBUG [main] com.alibaba.excel.context.WriteContextImpl:89 - Initialization 'WriteContextImpl' complete 2020-03-10 19:29:48.176 DEBUG [main] com.alibaba.excel.metadata.property.ExcelHeadProperty:95 - The initialization sheet/table 'ExcelHeadProperty' is complete , head kind is CLASS 2020-03-10 19:29:48.176 DEBUG [main] com.alibaba.excel.context.WriteContextImpl:145 - CurrentConfiguration is writeSheetHolder 2020-03-10 19:29:48.176 DEBUG [main] com.alibaba.excel.context.WriteContextImpl:181 - Can not find sheet:0 ,now create it 2020-03-10 19:29:49.660 DEBUG [main] com.alibaba.excel.context.WriteContextImpl:362 - Finished write.  com.alibaba.excel.exception.ExcelDataConvertException: Convert data:https://raw.githubusercontent.com/alibaba/easyexcel/master/src/test/resources/converter/img.jpg error,at row:1  at com.alibaba.excel.write.executor.AbstractExcelWriteExecutor.doConvert(AbstractExcelWriteExecutor.java:117) at com.alibaba.excel.write.executor.AbstractExcelWriteExecutor.convert(AbstractExcelWriteExecutor.java:93) at com.alibaba.excel.write.executor.AbstractExcelWriteExecutor.converterAndSet(AbstractExcelWriteExecutor.java:39) at com.alibaba.excel.write.executor.ExcelWriteAddExecutor.addJavaObjectToExcel(ExcelWriteAddExecutor.java:137) at com.alibaba.excel.write.executor.ExcelWriteAddExecutor.addOneRowOfDataToExcel(ExcelWriteAddExecutor.java:65) at com.alibaba.excel.write.executor.ExcelWriteAddExecutor.add(ExcelWriteAddExecutor.java:51) at com.alibaba.excel.write.ExcelBuilderImpl.addContent(ExcelBuilderImpl.java:61) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:161) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:146) at com.alibaba.excel.write.builder.ExcelWriterSheetBuilder.doWrite(ExcelWriterSheetBuilder.java:190) at com.alibaba.easyexcel.test.demo.write.WriteTest.imageWrite(WriteTest.java:229) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33) at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230) at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58) Caused by: java.net.SocketException: Connection reset at java.net.SocketInputStream.read(SocketInputStream.java:210) at java.net.SocketInputStream.read(SocketInputStream.java:141) at sun.security.ssl.InputRecord.readFully(InputRecord.java:465) at sun.security.ssl.InputRecord.read(InputRecord.java:503) at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:975) at sun.security.ssl.SSLSocketImpl.waitForClose(SSLSocketImpl.java:1761) at sun.security.ssl.HandshakeOutStream.flush(HandshakeOutStream.java:124) at sun.security.ssl.Handshaker.kickstart(Handshaker.java:1079) at sun.security.ssl.SSLSocketImpl.kickstartHandshake(SSLSocketImpl.java:1479)         at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:1346) at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1395) at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:1379) at sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:559) at sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:185) at sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1570) at sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1498) at sun.net.www.protocol.https.HttpsURLConnectionImpl.getInputStream(HttpsURLConnectionImpl.java:268) at java.net.URL.openStream(URL.java:1057) at com.alibaba.excel.converters.url.UrlImageConverter.convertToExcelData(UrlImageConverter.java:42) at com.alibaba.excel.converters.url.UrlImageConverter.convertToExcelData(UrlImageConverter.java:20) at com.alibaba.excel.write.executor.AbstractExcelWriteExecutor.doConvert(AbstractExcelWriteExecutor.java:113) ... 32 more   Process finished with exit code -1 </body>
		<created>2020-03-10 11:38:21</created>
		<closed>2020-03-12 12:22:47</closed>
	</bug>
	<bug>
		<id>1146</id>
		<title>Handler dispatch failed; nested exception is java.lang.NoClassDefFoundError: Could not initialize class com.alibaba.excel.write.ExcelBuilderImpl</title>
		<body>**后台使用EasyExcel.write方法生成excel让浏览器下载时报错**  **触发Bug的代码** ```java    String fileName =URLEncoder.encode("商户代偿未核账" + LocalDate.now().toString(), "UTF-8");         response.setContentType("application/vnd.ms-excel");         response.setCharacterEncoding("utf-8");         response.setHeader("Content-disposition", "attachment;filename=" + fileName + ".xlsx");         try {             EasyExcel.write(response.getOutputStream(),ExportCompensatoryUnVO.class).sheet(1).doWrite(voList);         }catch (Exception e ){             log.error(e.getMessage(),e);         }         return; ``` **** </body>
		<created>2020-03-10 09:11:17</created>
		<closed>2020-03-16 15:33:25</closed>
	</bug>
	<bug>
		<id>1143</id>
		<title>使用模板导出的时候报错 java.lang.IllegalArgumentException Attempting to write a row[2] in the range [0,6] that is already written to disk.</title>
		<body>### ### **触发场景描述** 使用模板导出的时候报错 **触发Bug的代码** EasyExcel.write(new FileOutputStream(new File(filePath))).withTemplate(inputStream).sheet().doFill(list); **提示的异常或者没有达到的效果** Caused by: java.lang.IllegalArgumentException: Attempting to write a row[2] in the range [0,6] that is already written to disk. at org.apache.poi.xssf.streaming.SXSSFSheet.createRow(SXSSFSheet.java:136) at org.apache.poi.xssf.streaming.SXSSFSheet.createRow(SXSSFSheet.java:65) at com.alibaba.excel.write.executor.ExcelWriteFillExecutor.getOneCell(ExcelWriteFillExecutor.java:270) at com.alibaba.excel.write.executor.ExcelWriteFillExecutor.doFill(ExcelWriteFillExecutor.java:154) at com.alibaba.excel.write.executor.ExcelWriteFillExecutor.fill(ExcelWriteFillExecutor.java:93) at com.alibaba.excel.write.ExcelBuilderImpl.fill(ExcelBuilderImpl.java:84) at com.alibaba.excel.ExcelWriter.fill(ExcelWriter.java:185) at com.alibaba.excel.write.builder.ExcelWriterSheetBuilder.doFill(ExcelWriterSheetBuilder.java:202) at com.alibaba.excel.write.builder.ExcelWriterSheetBuilder.doFill(ExcelWriterSheetBuilder.java:195) at com.pttl.bdrc.report.ebs.deptmanageanalysis.controller.ExpectReceivablePaymentGoodsAmountController.getExpectReceivablePaymentGoodsAmountDataDownloadFilePath(ExpectReceivablePaymentGoodsAmountController.java:187) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:133) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:849) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:760) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) ... 57 common frames omitted</body>
		<created>2020-03-09 09:41:02</created>
		<closed>2020-04-22 11:35:47</closed>
	</bug>
	<bug>
		<id>1139</id>
		<title>导出的excel 0字节</title>
		<body>**触发场景描述** 本地测试oraclejdk导出正常 服务器openjdk导出0字节  emmmmmm.</body>
		<created>2020-03-06 10:25:56</created>
		<closed>2020-03-10 02:13:39</closed>
	</bug>
	<bug>
		<id>1138</id>
		<title>下拉框数据量超过88条记录，文件无法打开</title>
		<body>**触发场景描述** 操作系统：mac  版本： ```pom         &lt;dependency&gt;             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;             &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;             &lt;version&gt;2.1.6&lt;/version&gt;         &lt;/dependency&gt; ```  excel版本： ![image](https://user-images.githubusercontent.com/13740210/76058467-784a2380-5fb7-11ea-9e4a-69d6fedc2443.png)    使用EasyExcel的 `CustomWriteHandler`生成下拉框时，下拉框大数据量会导致execl打开时报错。   业务代码中，如果是正常点的字符串，经测试二三十条数据就无法打开了。下面的例子是88条记录正常打开，但是如果下拉框有89条数据，则excel打开报错。  **触发Bug的代码** ```java  import com.alibaba.excel.EasyExcel; import com.alibaba.excel.annotation.ExcelProperty; import com.alibaba.excel.write.handler.SheetWriteHandler; import com.alibaba.excel.write.metadata.holder.WriteSheetHolder; import com.alibaba.excel.write.metadata.holder.WriteWorkbookHolder; import org.apache.poi.ss.usermodel.DataValidation; import org.apache.poi.ss.usermodel.DataValidationConstraint; import org.apache.poi.ss.usermodel.DataValidationHelper; import org.apache.poi.ss.util.CellRangeAddressList;  import java.util.Collections;  /**  * @author superlee  * @since 2020-03-06  */ public class TestEasyExcel {      public static void main(String[] args) {         generateExcel("/Users/superlee/test1.xlsx", 88);         generateExcel("/Users/superlee/test2.xlsx", 89);     }      private static void generateExcel(String fileName, int count) {         String[] array1 = new String[count];         for (int i = 0; i &lt; count; i++) {             array1[i] = i + "";         }         TestEasyExcel testEasyExcel = new TestEasyExcel();         EasyExcel                 .write(fileName, Model.class)                 .registerWriteHandler(testEasyExcel.new CustomWriteHandler(array1))                 .sheet("sheet").doWrite(Collections.emptyList());     }       class Model {         @ExcelProperty(value = "第一列", index = 0)         private String column;          public String getColumn() {             return column;         }          public void setColumn(String column) {             this.column = column;         }     }      public class CustomWriteHandler implements SheetWriteHandler {         private String[] data;          public CustomWriteHandler(String[] data) {             this.data = data;         }          @Override         public void beforeSheetCreate(WriteWorkbookHolder writeWorkbookHolder, WriteSheetHolder writeSheetHolder) {          }          @Override         public void afterSheetCreate(WriteWorkbookHolder writeWorkbookHolder, WriteSheetHolder writeSheetHolder) {             DataValidationHelper helper = writeSheetHolder.getSheet().getDataValidationHelper();             CellRangeAddressList cellRangeAddressList =                     new CellRangeAddressList(1, 500, 0, 0);             DataValidationConstraint constraint =                     helper.createExplicitListConstraint(data);             DataValidation dataValidation = helper.createValidation(constraint, cellRangeAddressList);             writeSheetHolder.getSheet().addValidationData(dataValidation);         }     } }  ``` **提示的异常或者没有达到的效果**  ![image](https://user-images.githubusercontent.com/13740210/76058501-957ef200-5fb7-11ea-82f1-a1b505533e51.png)  请问有没有解决方案，如何修改，谢谢。 </body>
		<created>2020-03-06 06:36:13</created>
		<closed>2020-03-23 11:39:20</closed>
	</bug>
	<bug>
		<id>1136</id>
		<title>Caused by: java.lang.ClassNotFoundException: com.alibaba.excel.read.listener.ReadListener</title>
		<body>**触发场景描述** 2.1.6版本 **触发Bug的代码** ```java    EasyExcel.read(file.getInputStream(), Product.class, new ProductImportListener(productMapper)).sheet().doRead(); ``` **提示的异常或者没有达到的效果** Error creating bean with name 'productController': Failed to introspect bean class [com.qunar.market.prince.material.web.controller.ProductController] for lookup method metadata: could not find class that it depends on; nested exception is java.lang.NoClassDefFoundError: com/alibaba/excel/read/listener/ReadListener</body>
		<created>2020-03-05 12:12:38</created>
		<closed>2020-03-16 16:06:45</closed>
	</bug>
	<bug>
		<id>1134</id>
		<title>模板方式插入数据时模板内的变量名为中文异常</title>
		<body>**触发场景描述** list模板方式插入数据时，变量名使用中文名如：{.序号}，使用map方式填入数据，生成的excle存在异常。 打开文件时文件部分内容出现问题，尝试修复。 打开后“通过修改会删除内容后可打开文件” 文件内容第一行数据为模板列，第二行数据为正常数据 **触发Bug的代码** ```java    File file = new File("C:\\tmp\\test_template.xlsx");         File file2 = new File("C:\\tmp\\test.xlsx");         String name = file2.getName();         int index = name.indexOf(".");         String fileName = name.substring(0,index);         ExcelWriter writer = EasyExcel.write(file2).withTemplate(file).build();         WriteSheet writeSheet = EasyExcel.writerSheet(fileName).build();          Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();         map.put("序号",1);         map.put("字段1",1);         map.put("字段2",1);         map.put("字段3",1);         map.put("字段4",1);         map.put("结果",1);         Map&lt;String,Object&gt; map2 = new HashMap&lt;&gt;();         map2.put("序号",2);         map2.put("字段1",2);         map2.put("字段2",2);         map2.put("字段3",2);         map2.put("字段4",2);         map2.put("结果",2);         List&lt;Map&gt; maps = new ArrayList&lt;&gt;();         maps.add(map);         maps.add(map2);         writer.fill(maps,writeSheet); ``` **提示的异常或者没有达到的效果** 模板： 序号 | 字段1 | 字段2 | 字段3 | 字段4 | 结果 -- | -- | -- | -- | -- | -- {.序号} | {.字段1} | {.字段2} | {.字段3} | {.字段4} | {.结果} 结果： 序号 | 字段1 | 字段2 | 字段3 | 字段4 | 结果 -- | -- | -- | -- | -- | -- {.序号} | {.字段1} | {.字段2} | {.字段3} | {.字段4} | {.结果} 2 | 2 | 2 | 2 | 2 | 2   </body>
		<created>2020-03-05 11:00:31</created>
		<closed>2020-03-16 18:12:13</closed>
	</bug>
	<bug>
		<id>1131</id>
		<title>自定义转换器中的 CellData cellData 读出的数据为 null</title>
		<body>**触发场景描述** 这是execl 表中转换失败的一列数据 起始时间 -- 2017/08/08 2017/08/08 2019-07-05 2019-07-12 2019-07-12 2019-09-29 2019-10-15 2019-10-15 2019-10-22 2019-10-22 2019-11-21 2019-11-21 2019-11-25 --- 这是我需要单独处理的一列 因为格式不一致 所以想用自定义日期转换器 但发现 读前2条数据时OK  第3条起 全部为 null?  现在只能用纯 String 类型的 model 转 纯String 类型 的 model 接数据 就完全正常... 然后再把数据 自行转换再把数据 复制到DB 实体类 保存 ---   **触发Bug的代码** ```java    //实体类中的属性     @ExcelProperty(value = "起始时间",converter = CustomDateConverter.class)     private LocalDate startDate;   // 自定义转换类 public class CustomDateConverter implements Converter&lt;LocalDate&gt; {        @Override     public Class supportJavaTypeKey() {         return LocalDate.class;     }      @Override     public CellDataTypeEnum supportExcelTypeKey() {         return CellDataTypeEnum.STRING;     }  /**      * 这里读的时候会调用      *      * @param cellData      *            NotNull      * @param contentProperty      *            Nullable      * @param globalConfiguration      *            NotNull      * @return      */     @Override     public LocalDate convertToJavaData(CellData cellData, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) throws Exception {         String dataStringValue = cellData.getStringValue();          //default, ISO_LOCAL_DATE [yyyy-mm-dd]         LocalDate localDate;         DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy/MM/dd");         try {             if (dataStringValue.length() == 10) {                 localDate = LocalDate.parse(dataStringValue, dateTimeFormatter);             } else {                 localDate = LocalDate.parse(dataStringValue);             }         } catch (Exception e) {             localDate = LocalDate.parse(dataStringValue, dateTimeFormatter);         }          return localDate;     } } ``` **提示的异常或者没有达到的效果** ```java 2020-03-04 18:11:46.252  INFO 6132 --- [nio-8181-exec-1] c.s.salary.listener.EListener     : 解析到一条数据:{"startDate":{"year":2017,"month":"AUGUST","monthValue":8,"dayOfMonth":8,"dayOfWeek":"TUESDAY","era":"CE","dayOfYear":220,"leapYear":false,"chronology":{"id":"ISO","calendarType":"iso8601"}} 2020-03-04 18:11:46.637  INFO 6132 --- [nio-8181-exec-1] c.s.salary.listener.EListener     : 解析到一条数据:{"startDate":{"year":2017,"month":"AUGUST","monthValue":8,"dayOfMonth":8,"dayOfWeek":"TUESDAY","era":"CE","dayOfYear":220,"leapYear":false,"chronology":{"id":"ISO","calendarType":"iso8601"}}} 2020-03-04 18:11:47.042 ERROR 6132 --- [nio-8181-exec-1] c.s.salary.listener.EListener     : 解析失败，但是继续解析下一行:Convert data 43651 to class java.time.LocalDate error  2020-03-04 18:11:47.042 ERROR 6132 --- [nio-8181-exec-1] c.s.salary.listener.EListener     : 第3行，第3列解析异常 ``` </body>
		<created>2020-03-04 10:17:55</created>
		<closed>2020-03-16 16:59:15</closed>
	</bug>
	<bug>
		<id>1125</id>
		<title>2.1.6使用模板方式写入时,单元格已经设置区中,但实际未居中.</title>
		<body>**触发场景描述** 使用的是模板方式写入(withTemplate),模板已经设置过居中,但实际生成的Excel未居中. **触发Bug的代码** File templateFile = PathUtils.getExcelTemplateFile("产线不良导出模板.xlsx"); File downloadFile = PathUtils.getExcelOutputFile(templateFile); EasyExcel.write(downloadFile, ProdlineBugVO.class).withTemplate(templateFile).sheet(0).needHead(Boolean.FALSE).doWrite(list); ```java    这里写代码 ``` **提示的异常或者没有达到的效果** </body>
		<created>2020-03-01 14:37:34</created>
		<closed>2020-04-24 07:49:34</closed>
	</bug>
	<bug>
		<id>1123</id>
		<title>因 sheetName 同名，导致数据没有写入到对应 sheetNo 的 sheet 中</title>
		<body>**触发场景描述**  `version 2.1.6`  使用`writerSheet(Integer sheetNo, String sheetName)`构建了 3 个 sheet，并且3个`sheetName `同名都为 `数据表清单`，然后分别向 sheet1、sheet2、sheet3 写入数据  结果：所有的数据都写进了 index 为 0 的 sheet 中了，且该 excel 中只有 1 个 sheet  期望：`writerSheet(Integer sheetNo, String sheetName)`即使 sheetName 同名，数据会根据 index 写入对应的 sheet  **触发Bug的代码**  ```java         // 1、构建ExcelWriter对象         ExcelWriter excelWriter = EasyExcel.write(TestFileUtil.createNewFile(FILE_NAME_XLSX), WriteData.class)                 .excelType(ExcelTypeEnum.XLSX)                 .build();          // 2、构建WriteSheet对象         WriteSheet sheet1 = EasyExcel.writerSheet(0, "数据表清单").build();         WriteSheet sheet2 = EasyExcel.writerSheet(1, "数据表清单").build();         WriteSheet sheet3 = EasyExcel.writerSheet(2, "数据表清单").build();          // 3、往sheet写入数据         excelWriter.write(data(), sheet1);         excelWriter.write(data(), sheet2);         excelWriter.write(data(), sheet3);          // 4、调用finish，否则数据不会写到文件中         // ps: 即使构建ExcelWriter时设置了autoCloseStream(true) 这里也必须要调用finish         excelWriter.finish(); ```  **初步分析**  因为我这里的 sheetName 都相同，所以只有第一个 sheet 调用`WriteContextImpl#selectSheetFromCache`方法会返回`false`， 剩下的调用`selectSheetFromCache`方法都会返回 true， 从而导致所有的数据都写进了 index 为 0 的 sheet， 如果写入数据超过单个Excel的限制时，还会进一步导致`java.lang.IllegalArgumentException: Invalid row number (1048576) outside allowable range`的异常发生  ```java     public void currentSheet(WriteSheet writeSheet, WriteTypeEnum writeType) {         if (writeSheet == null) {             throw new IllegalArgumentException("Sheet argument cannot be null");         }         if (selectSheetFromCache(writeSheet)) {             return;         }         initCurrentSheetHolder(writeSheet);         // Initialization current sheet         initSheet(writeType);     }      private boolean selectSheetFromCache(WriteSheet writeSheet) {         writeSheetHolder = null;         if (writeSheet.getSheetNo() != null) {             writeSheetHolder = writeWorkbookHolder.getHasBeenInitializedSheetIndexMap().get(writeSheet.getSheetNo());         }         if (writeSheetHolder == null &amp;&amp; !StringUtils.isEmpty(writeSheet.getSheetName())) {             writeSheetHolder = writeWorkbookHolder.getHasBeenInitializedSheetNameMap().get(writeSheet.getSheetName());         }         if (writeSheetHolder == null) {             return false;         }         // ......     } ```  **反馈**  如果把`selectSheetFromCache`方法中判断 sheetNo 与 sheetName 改用`if () {} else if () {}`的逻辑，是否可行呢？ 因为我不太明白源码这里使用 2 个`if`逻辑的初衷，还望点拨！  写在最后，如果有同学也碰到了我这里同样的问题，可以将 sheetNo 与 sheeName 拼接组成新的 sheeName 来解决。 换句话说，就是保证 sheetName 不重名，就不会发生这个问题了。</body>
		<created>2020-02-28 02:04:07</created>
		<closed>2020-03-16 16:39:42</closed>
	</bug>
	<bug>
		<id>1116</id>
		<title>读取excel的bug-com.alibaba.excel.read.metadata.holder.AbstractReadHolder#buildHead</title>
		<body>例如要解析一个excel，excel有两列，A列head是H1，B列head是H2 定义实体类DataDemo来存数据，定义两个字段 ```java @ExcelProperty("h2") private Integer h2; private int rowIdx; ``` 其中rowIdx是打算存行号的，在linstener的invoke方法里手动设置 A列数据压根没打算读 那么现在问题来了，com.alibaba.excel.read.metadata.holder.AbstractReadHolder#buildHead方法的206-210行有如下代码： **触发Bug的代码** ```java if (headData.getForceIndex() || !headData.getForceName()) {                 tmpHeadMap.put(entry.getKey(), headData);                 tmpContentPropertyMap.put(entry.getKey(),                  contentPropertyMapData.get(entry.getKey()));                 continue;             } ``` 这地方会把字段h2的映射覆盖掉，导致B列的数据都读出来设置到了rowIdx字段上面  所以，是不是应该让读excel时也支持@ExcelIgnoreUnannotated和@ExcelIgnore这两个注解，来主动避免默认的按字段顺序读excel的这种行为</body>
		<created>2020-02-25 10:12:45</created>
		<closed>2020-03-16 17:02:55</closed>
	</bug>
	<bug>
		<id>1111</id>
		<title>类的setter、getter名字带两个大写字母时写数据失败</title>
		<body>**触发场景描述** 如果一个类的定义如下： ```java @Data @Builder class Row{     @ExcelProperty(value = "姓名", index = 0)     private String name;     @ExcelProperty(value = "项目名", index = 1)     private String pName; } ``` 采用以下代码写数据到excel文件时，pName属性的值没有导出，具体表现为：没有异常、没有日志，excel文件中对应位置没有数据。 ```java List&lt;Row&gt; rows = new ArrayList&lt;&gt;(); rows.add(Row.builder().name("张三").pName("在线商城").build()); rows.add(Row.builder().name("李四").pName("在线图书馆").build());  String fileName = ResourceUtils.getURL("classpath:").getPath() + "test.xlsx"; EasyExcel.write(fileName, Row.class).sheet("模板").doWrite(rows); ``` 删除 `@Data` 注解后，手动为 pName 添加了名为 `getPName()` 和 `setPName()` 的 getter 和 setter，重新执行发现仍不能正常导出。后改函数名为 `getProjectName()` 和 `setProjectName()` 重新执行仍然无法正常导出。</body>
		<created>2020-02-21 15:57:17</created>
		<closed>2020-03-16 17:38:30</closed>
	</bug>
	<bug>
		<id>1109</id>
		<title>没有使用@ExcelProperty()的字段也会被赋值,导致转换异常</title>
		<body>--- name: bug about: 发现一个新的Bug title: '没有使用@ExcelProperty的字段也会被赋值,导致转换异常' labels: bug assignees: zhuangjiaju ---  **触发场景描述**    --- excel文件格式如下,用listener读取到实体并且存储到数据库时,   对应实体中,除id,create_time,update_time外,都指定了@ExcelProperty, 但在实际获取字段时,会获取上述不存在@ExcelProperty注解的字段并自动使用跳过的列码.如省份列(实体中并无此字段).   此时会将省份列赋值给create_time.因为 XX省,无法转换为日期格式,导致转换异常      | (列名为空) | 年份    |  公司名   | 所在省  | 所在城市 |     | 1         | 2019   | XX公司   |   XX省 |  XX市  | --- **触发Bug的代码** ```java @RestController @RequestMapping("/company") public class CompanyController {      @Autowired     ICompanyService companyService;      @ResponseBody     @RequestMapping(value = "/upload", method = RequestMethod.POST)     public String upload(MultipartFile file) throws Exception {         try {             EasyExcel.read(file.getInputStream(), CompanyEntity.class, new UploadCompanyListener(companyService))                     .sheet()                     .doRead();         } catch (Exception e) {             e.printStackTrace();         }         return "success";     } } ``` ```java @Data @AllArgsConstructor @NoArgsConstructor @TableName("company") public class CompanyEntity extends BaseEntity implements Serializable {      private static final long serialVersionUID = -5945145006983646839L;      /**      * 企业名称      */     @TableField("name")     @ExcelProperty(index = 2)     private String name;      /**      * 企业类型/行业类型      */     @TableField("type")     @ExcelProperty(index = 13)     private String type;      /**      * 法人代表      */     @TableField("law_person")     @ExcelProperty(index = 15)     private String lawPerson;      /**      * 企业联系人      */     @TableField("contact")     @ExcelProperty(index = 16)     private String contact;      /**      * 企业联系人电话      */     @TableField("contact_phone")     @ExcelProperty(index = 17)     private String contactPhone;      /**      * 备注      */     @TableField("remark")     private String remark; } ``` ```java public class UploadCompanyListener extends AnalysisEventListener&lt;CompanyEntity&gt; {     private static final Logger logger = LoggerFactory.getLogger(UploadCompanyListener.class);     /**      * 每隔100条存储数据库，实际使用中可以3000条，然后清理list ，方便内存回收      */     private static final int BATCH_COUNT = 100;      List&lt;CompanyEntity&gt; list = new ArrayList&lt;&gt;();      private ICompanyService companyService;      public UploadCompanyListener(ICompanyService service) {         this.companyService = service;     }      @Override     public void onException(Exception exception, AnalysisContext context) throws Exception {         logger.error("解析失败，但是继续解析下一行,异常原因:{}", exception.getMessage());         if (exception instanceof ExcelDataConvertException) {             ExcelDataConvertException excelDataConvertException = (ExcelDataConvertException) exception;             logger.error("第{}行，第{}列解析异常，数据为:{}", excelDataConvertException.getRowIndex(),                     excelDataConvertException.getColumnIndex(), excelDataConvertException.getCellData());             throw exception;         }     }      /**      * 这个每一条数据解析都会来调用      *      * @param data    data      * @param context context      */     @Override     public void invoke(CompanyEntity data, AnalysisContext context) {         list.add(data);         // 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM         if (list.size() &gt;= BATCH_COUNT) {             saveData();             // 存储完成清理 list             list.clear();         }     }      /**      * 所有数据解析完成了 都会来调用      *      * @param context context      */     @Override     public void doAfterAllAnalysed(AnalysisContext context) {         // 这里也要保存数据，确保最后遗留的数据也存储到数据库         saveData();         logger.info("所有数据解析完成！");     }      /**      * 加上存储数据库      */     private void saveData() {         System.out.println(list); //        companyService.saveBatch(list);     } } ``` ```text         &lt;dependency&gt;             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;             &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;             &lt;version&gt;2.1.6&lt;/version&gt;         &lt;/dependency&gt; ``` **提示的异常或者没有达到的效果** ```text 14:51:03 [http-nio-7044-exec-1] ERROR c.s.c.s.config.UploadCompanyListener - 解析失败，但是继续解析下一行,异常原因:Convert data 河北省 to class java.util.Date error  14:51:03 [http-nio-7044-exec-1] ERROR c.s.c.s.config.UploadCompanyListener - 第1行，第5列解析异常，数据为:河北省 com.alibaba.excel.exception.ExcelAnalysisException: Convert data 河北省 to class java.util.Date error  at com.alibaba.excel.read.metadata.holder.AbstractReadHolder.notifyEndOneRow(AbstractReadHolder.java:151) at com.alibaba.excel.analysis.v07.handlers.ProcessResultCellHandler.endHandle(ProcessResultCellHandler.java:45) at com.alibaba.excel.analysis.v07.XlsxRowHandler.endElement(XlsxRowHandler.java:44) at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.endElement(AbstractSAXParser.java:609) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanEndElement(XMLDocumentFragmentScannerImpl.java:1782) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2967) at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:602) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:505) at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:842) at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:771) at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:141) at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1213) at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:643) at com.alibaba.excel.analysis.v07.XlsxSaxAnalyser.parseXmlSource(XlsxSaxAnalyser.java:165) at com.alibaba.excel.analysis.v07.XlsxSaxAnalyser.execute(XlsxSaxAnalyser.java:189) at com.alibaba.excel.analysis.ExcelAnalyserImpl.analysis(ExcelAnalyserImpl.java:105) at com.alibaba.excel.ExcelReader.read(ExcelReader.java:180) at com.alibaba.excel.ExcelReader.read(ExcelReader.java:170) at com.alibaba.excel.read.builder.ExcelReaderSheetBuilder.doRead(ExcelReaderSheetBuilder.java:160) at com.suncere.chengde.st.controller.CompanyController.upload(CompanyController.java:40) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:888) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909) at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320) at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.invoke(FilterSecurityInterceptor.java:126) at org.springframework.security.web.access.intercept.FilterSecurityInterceptor.doFilter(FilterSecurityInterceptor.java:90) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:118) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:158) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:200) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:92) at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:77) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334) at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215) at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:358) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:271) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:526) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:861) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1579) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748) Caused by: com.alibaba.excel.exception.ExcelDataConvertException: Convert data 河北省 to class java.util.Date error  at com.alibaba.excel.util.ConverterUtils.doConvertToJavaObject(ConverterUtils.java:135) at com.alibaba.excel.util.ConverterUtils.convertToJavaObject(ConverterUtils.java:103) at com.alibaba.excel.read.listener.ModelBuildEventListener.buildUserModel(ModelBuildEventListener.java:113) at com.alibaba.excel.read.listener.ModelBuildEventListener.invoke(ModelBuildEventListener.java:38) at com.alibaba.excel.read.listener.ModelBuildEventListener.invoke(ModelBuildEventListener.java:28) at com.alibaba.excel.read.metadata.holder.AbstractReadHolder.notifyEndOneRow(AbstractReadHolder.java:145) ... 97 more Caused by: java.lang.IllegalArgumentException: can not find date format for：河北省 at com.alibaba.excel.util.DateUtils.switchDateFormat(DateUtils.java:72) at com.alibaba.excel.util.DateUtils.parseDate(DateUtils.java:34) at com.alibaba.excel.converters.date.DateStringConverter.convertToJavaData(DateStringConverter.java:33) at com.alibaba.excel.converters.date.DateStringConverter.convertToJavaData(DateStringConverter.java:18) at com.alibaba.excel.util.ConverterUtils.doConvertToJavaObject(ConverterUtils.java:133) ... 102 more ``` </body>
		<created>2020-02-21 07:31:34</created>
		<closed>2020-03-16 17:39:11</closed>
	</bug>
	<bug>
		<id>1102</id>
		<title>2.1.6写EXCEL数据丢失</title>
		<body>**触发场景描述** 数据量较大的时候写文件会丢失数据 **触发Bug的代码** ```java        /**      * 不创建对象的写      */     @Test     public void noModleWrite() {         // 写法1         String fileName = TestFileUtil.getPath() + "noModleWrite" + System.currentTimeMillis() + ".xlsx";         // 这里 需要指定写用哪个class去写，然后写到第一个sheet，名字为模板 然后文件流会自动关闭         EasyExcel.write(fileName).head(head()).sheet("模板").doWrite(dataList());     } ``` **提示的异常或者没有达到的效果** 按照DEMO给的方式写数据，因数据量比较大（300W），所以代码将数据拆成了多分，另外将数据做了聚合后重新提取了50w，但是这50w数据写文件的时候存在丢失问题（写前进行print能看到数据存在，且行数据不存在重复）</body>
		<created>2020-02-13 07:58:41</created>
		<closed>2020-04-22 11:33:08</closed>
	</bug>
	<bug>
		<id>1097</id>
		<title>excelWriter.finish()关闭流时报错”Can not close IO.“</title>
		<body>**触发场景描述** 我要导出15万数据到一个excel中，然后返回给页面下载，每个sheet一万条数据，每次查询一万条数据写入到一个sheet中，总共查询15次，一共生成15个sheet **触发Bug的代码** ```java    excelWriter.finish(); ``` 最后在执行这个的时候，报错了 **提示的异常或者没有达到的效果** ``` com.alibaba.excel.exception.ExcelGenerateException: Can not close IO. at com.alibaba.excel.context.WriteContextImpl.finish(WriteContextImpl.java:358) at com.alibaba.excel.write.ExcelBuilderImpl.finish(ExcelBuilderImpl.java:101) at com.alibaba.excel.ExcelWriter.finish(ExcelWriter.java:328) ... Caused by: org.apache.catalina.connector.ClientAbortException: null at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:413) at org.apache.tomcat.util.buf.ByteChunk.flushBuffer(ByteChunk.java:480) at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:359) at org.apache.catalina.connector.OutputBuffer.close(OutputBuffer.java:309) at org.apache.catalina.connector.CoyoteOutputStream.close(CoyoteOutputStream.java:108) at com.alibaba.excel.context.WriteContextImpl.finish(WriteContextImpl.java:333) ... 66 common frames omitted Caused by: java.net.SocketException: Broken pipe at java.net.SocketOutputStream.socketWrite0(Native Method) at java.net.SocketOutputStream.socketWrite(SocketOutputStream.java:113) at java.net.SocketOutputStream.write(SocketOutputStream.java:159) at org.apache.coyote.http11.InternalOutputBuffer.realWriteBytes(InternalOutputBuffer.java:215) at org.apache.tomcat.util.buf.ByteChunk.flushBuffer(ByteChunk.java:480) at org.apache.tomcat.util.buf.ByteChunk.append(ByteChunk.java:366) at org.apache.coyote.http11.InternalOutputBuffer$OutputStreamOutputBuffer.doWrite(InternalOutputBuffer.java:240) at org.apache.coyote.http11.filters.ChunkedOutputFilter.doWrite(ChunkedOutputFilter.java:117) at org.apache.coyote.http11.AbstractOutputBuffer.doWrite(AbstractOutputBuffer.java:192) at org.apache.coyote.Response.doWrite(Response.java:517) at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:408) ... 71 common frames omitted ``` </body>
		<created>2020-02-05 13:36:01</created>
		<closed>2020-03-16 18:18:20</closed>
	</bug>
	<bug>
		<id>1096</id>
		<title>在groovy项目中读取excel 出现报错</title>
		<body>**触发场景描述** 在groovy项目中出现错误，使用的是 2.0.5 版本   **触发Bug的代码**  EasyExcel.read(file.getInputStream(),Dto.class, new UploadData()).sheet().doRead();        ```   2020-02-05 19:14:53.108 [] [http-nio-9400-exec-6] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] 182 - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is com.alibaba.excel.exception.ExcelAnalysisException: Listen error!] with root cause com.alibaba.excel.exception.ExcelDataConvertException: Converter not found, convert STRING to org.codehaus.groovy.reflection.ClassInfo at com.alibaba.excel.util.ConverterUtils.convertToJavaObject(ConverterUtils.java:79) at com.alibaba.excel.read.listener.ModelBuildEventListener.buildUserModel(ModelBuildEventListener.java:94) at com.alibaba.excel.read.listener.ModelBuildEventListener.invoke(ModelBuildEventListener.java:36) at com.alibaba.excel.read.listener.ModelBuildEventListener.invoke(ModelBuildEventListener.java:27) at com.alibaba.excel.read.metadata.holder.AbstractReadHolder.notifyEndOneRow(AbstractReadHolder.java:141) at com.alibaba.excel.analysis.v07.handlers.ProcessResultCellHandler.endHandle(ProcessResultCellHandler.java:44) at com.alibaba.excel.analysis.v07.XlsxRowHandler.endElement(XlsxRowHandler.java:44) at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.endElement(AbstractSAXParser.java:609) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanEndElement(XMLDocumentFragmentScannerImpl.java:1782) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2973) at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:606) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:510) at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:848) at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:777) at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:141) at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1213) at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:649)</body>
		<created>2020-02-05 12:20:59</created>
		<closed>2020-03-16 17:25:00</closed>
	</bug>
	<bug>
		<id>1094</id>
		<title>第二次导入一直卡死，没有反应</title>
		<body></body>
		<created>2020-02-04 03:50:18</created>
		<closed>2020-03-20 04:08:05</closed>
	</bug>
	<bug>
		<id>1090</id>
		<title>读取多个Sheet时无法跳过表头</title>
		<body>**触发场景描述** 在读取多个 sheet 时不能自动跳过表头，会将表头的数据当作内容数据，导致converter失败出现异常 **触发Bug的代码** 我的实体如下： ![image](https://user-images.githubusercontent.com/45053977/72712888-f2a91a80-3ba6-11ea-9740-029cc2a1a654.png) 读取main方法如下： ```java         File file = new File("C:\\Users\\admin\\Desktop\\测试_用户-20200120160005.xlsx");         ExcelReader excelReader = EasyExcel.read(file).build();         ReadSheet readSheet = EasyExcel.readSheet(0).head(TestDomain.class)                 .registerReadListener(new TestListener()).build();         excelReader.read(readSheet);         excelReader.finish(); ``` **原因分析** 当进行读取的时候，在执行器中class为空： ![image](https://user-images.githubusercontent.com/45053977/72714573-e6728c80-3ba9-11ea-92bc-1f26a5bfd32e.png) ```java // 采用如下的方式不会出现，readWorkbook对象中的clazz对象不为空 EasyExcel.read(file,Test.class,new TestListener()).build().readAll(); ``` **提示的异常或者没有达到的效果** 出现的异常信息如下： ![image](https://user-images.githubusercontent.com/45053977/72713187-8d095e00-3ba7-11ea-8a21-d337feca8029.png) </body>
		<created>2020-01-20 09:26:49</created>
		<closed>2020-04-24 07:46:56</closed>
	</bug>
	<bug>
		<id>1089</id>
		<title>数据解析小数精度丢失异常</title>
		<body>**触发场景描述** excel表格里的数据是0.58，解析出来的是0.59999999999999，表格接收数据的类型是String,后来换成Bigdecimal也一样 **触发Bug的代码** ```java    这里写代码 ```    /**      * 数字      */     @ExcelProperty("数字")     private String nums; **提示的异常或者没有达到的效果** </body>
		<created>2020-01-20 07:53:38</created>
		<closed>2020-03-17 15:50:47</closed>
	</bug>
	<bug>
		<id>1087</id>
		<title>Redhat Docker Font问题</title>
		<body>**触发场景描述** Redhat 下 Docker  **触发Bug的代码** ```dockerfile FROM openjdk:8-jdk-alpine as build  RUN apk add ttf-dejavu Run fc-cache --force  ``` java.lang.NullPointerException: null\n\tat sun.awt.FontConfiguration.getVersion(FontConfiguration.java:1264)\n\tat sun.awt.FontConfiguration.readFontConfigFile(FontConfiguration.java:219)\n\tat sun.awt.FontConfiguration.init(FontConfiguration.java:107)\n\tat sun.awt.X11FontManager.createFontConfiguration(X11FontManager.java:774)\n\tat sun.font.SunFontManager$2.run(SunFontManager.java:431)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.font.SunFontManager.&lt;init&gt;(SunFontManager.java:376)\n\tat sun.awt.FcFontManager.&lt;init&gt;(FcFontManager.java:35)\n\tat sun.awt.X11FontManager.&lt;init&gt;(X11FontManager.java:57)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat java.lang.Class.newInstance(Class.java:442)\n\tat sun.font.FontManagerFactory$1.run(FontManagerFactory.java:83)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat sun.font.FontManagerFactory.getInstance(FontManagerFactory.java:74)\n\tat sun.java2d.SunGraphicsEnvironment.getFontManagerForSGE(SunGraphicsEnvironment.java:201)\n\tat sun.java2d.SunGraphicsEnvironment.getAvailableFontFamilyNames(SunGraphicsEnvironment.java:235)\n\tat sun.java2d.SunGraphicsEnvironment.getAvailableFontFamilyNames(SunGraphicsEnvironment.java:263)\n\tat sun.java2d.HeadlessGraphicsEnvironment.getAvailableFontFamilyNames(HeadlessGraphicsEnvironment.java:94)\n\tat com.moodys.marcopolo.controller.OrganizationsController.download(OrganizationsController.java:197)\n\tat com.moodys.marcopolo.controller.OrganizationsController.downloadTemplate(OrganizationsController.java:130)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:892)\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797)\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1039)\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942)\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005)\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:634)\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:741)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.springframework.web.servlet.resource.ResourceUrlEncodingFilter.doFilter(ResourceUrlEncodingFilter.java:63)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.springframework.boot.actuate.web.trace.servlet.HttpTraceFilter.doFilterInternal(HttpTraceFilter.java:88)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:118)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:320)\n\tat org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:119)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\n\tat org.springframework.security.web.session.SessionManagementFilter.doFilter(SessionManagementFilter.java:137)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\n\tat org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:111)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\n\tat org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:170)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\n\tat org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\n\tat com.moodys.sharedlibs.security.simple.SimpleAuthenticationFilter.doFilter(SimpleAuthenticationFilter.java:32)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\n\tat org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:116)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\n\tat org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:74)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:118)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\n\tat org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:105)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\n\tat org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:56)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:118)\n\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:334)\n\tat org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:215)\n\tat org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:178)\n\tat org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:357)\n\tat org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:270)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:118)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:118)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:118)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.filterAndRecordMetrics(WebMvcMetricsFilter.java:114)\n\tat org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:104)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:118)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:118)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:526)\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343)\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408)\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:860)\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1587)\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n\tat java.lang.Thread.run(Thread.java:748)\n </body>
		<created>2020-01-19 10:28:36</created>
		<closed>2020-03-12 10:08:19</closed>
	</bug>
	<bug>
		<id>1080</id>
		<title>excel中 数字：10.2，解析后是10.199999999999999</title>
		<body>excel中数字为10.2，解析成了10.199999999999999</body>
		<created>2020-01-16 06:02:13</created>
		<closed>2020-01-16 07:04:23</closed>
	</bug>
	<bug>
		<id>1078</id>
		<title>读取存在列合并的excel时实体对象不支持单字母字段</title>
		<body>**触发场景描述** easyexcel jar版本: 2.1.4  **触发Bug的代码** ```java    //测试类    String filePath1 = "C:\\Users\\Administrator\\Desktop\\work01\\题目导入模板测试1.xlsx";    List&lt;Test&gt; list =                EasyExcel.read(filePath1).head(Test.class).sheet("题目").doReadSync();     System.out.println("数量:" + list.size());      //实体类中部分代码如下     @ExcelProperty(value = {"标题一"}, index = 0)     private String test1;    @ExcelProperty(value = {"答题二", "A"})     private String A;     @ExcelProperty(value = {"答题二", "B"})     private String B;     @ExcelProperty(value = {"答题二", "C"})     private String C;     @ExcelProperty(value = {"答题二", "D"})     private String D;     @ExcelProperty(value = {"标题三"}, index = 5)     private String test3;     ``` **提示的异常或者没有达到的效果** A、B、C、D等字段无法取不到值。  **临时解决方法**     //实体类中部分代码如下     @ExcelProperty(value = {"标题一"}, index = 0)     private String test1;    @ExcelProperty(value = {"答题二", "A"})     private String AA;     @ExcelProperty(value = {"答题二", "B"})     private String BB;     @ExcelProperty(value = {"答题二", "C"})     private String CC;     @ExcelProperty(value = {"答题二", "D"})     private String DD;     @ExcelProperty(value = {"标题三"}, index = 5)     private String test3; </body>
		<created>2020-01-16 03:49:51</created>
		<closed>2020-03-17 15:35:16</closed>
	</bug>
	<bug>
		<id>1076</id>
		<title>写入Excel时，当needHead设置False，无法进入AbstractCellStyleStrategy下setContentCellStyle方法体</title>
		<body>**触发场景描述** 使用版本2.1.6，写入Excel时，当needHead设置False，head为null，此时无法进入AbstractCellStyleStrategy下setContentCellStyle方法体。使用历史版本2.0.5时无此情况  **问题相关代码** ```java     @Override     public void afterCellDispose(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder,         List&lt;CellData&gt; cellDataList, Cell cell, Head head, Integer relativeRowIndex, Boolean isHead) {         if (isHead == null || head == null) {             return;         }         if (isHead) {             setHeadCellStyle(cell, head, relativeRowIndex);         } else {             setContentCellStyle(cell, head, relativeRowIndex);         }     }  ``` **提示的异常或者没有达到的效果** 继承AbstractCellStyleStrategy后，由于head为null，无法进入setContentCellStyle方法 </body>
		<created>2020-01-15 06:32:39</created>
		<closed>2020-03-16 17:51:12</closed>
	</bug>
	<bug>
		<id>1075</id>
		<title>excel读取时无法读到数据</title>
		<body>**触发场景描述** ![图片](https://user-images.githubusercontent.com/18588851/72398047-a1e78b00-377c-11ea-8bc0-e094937d4608.png) 这个格式的数据，数据时间无法读取到 ![图片](https://user-images.githubusercontent.com/18588851/72398092-c479a400-377c-11ea-9300-38160270b8dc.png) 这个是我的模板类，数据时间字段无法读取到 </body>
		<created>2020-01-15 01:53:57</created>
		<closed>2020-03-16 17:35:09</closed>
	</bug>
	<bug>
		<id>1069</id>
		<title>读Excel操作,表头类中如果出现类似单字母开头的字段无法映射</title>
		<body>**使用EasyExcel.read方法时里面传入表头class，发现单字母开头的字段无法被映射 例如：String tStartTime或者String gEndTime**  **触发Bug的代码** ```java CbLog: public class CbLog {     @TableId     private String uploadId;     private String code;     private String message;     private String cStartTime;     private String cFinishTime;     private String cTimeConsume;     private Boolean cDone;     private String cError;     private String createTime; } 操作代码：            if (StringUtils.equals(dbName, "cb_log")) {             EasyExcel.read(file.getInputStream(), CbLog.class, new AnalysisEventListener&lt;CbLog&gt;() {                 private List&lt;CbLog&gt; cbLogs = Lists.newArrayList();                  @Override                 public void invoke(CbLog cbLog, AnalysisContext analysisContext) {                     log.info("cb-log:{}", JSON.toJSONString(cbLog));                     cbLogs.add(cbLog);                     if (cbLogs.size() &gt;= BATCH_COUNT) {                         cbLogService.saveBatch(cbLogs);                         cbLogs.clear();                     }                 }                  @Override                 public void doAfterAllAnalysed(AnalysisContext analysisContext) {                     cbLogService.saveBatch(cbLogs);                 }             }).sheet().doRead();             return ResUtils.ok(String.format("表%s,同步成功", dbName));         } 说明： Excel中的该字段数据是有的 打印结果： 2020-01-13 09:31:04.389  INFO 4724 --- [nio-9000-exec-1] c.p.a.k.i.service.impl.SyncServiceImpl   : cb-log:{"code":"101","createTime":"2020-01-02 21:43:11","message":"识别成功","uploadId":"76079932901949440"} 2020-01-13 09:31:04.389  INFO 4724 --- [nio-9000-exec-1] c.p.a.k.i.service.impl.SyncServiceImpl   : cb-log:{"code":"101","createTime":"2020-01-02 21:43:46","message":"识别成功","uploadId":"76080024969543680"} 2020-01-13 09:31:04.389  INFO 4724 --- [nio-9000-exec-1] c.p.a.k.i.service.impl.SyncServiceImpl   : cb-log:{"code":"101","createTime":"2020-01-02 21:44:51","message":"识别成功","uploadId":"76080195504701440"} 2020-01-13 09:31:04.389  INFO 4724 --- [nio-9000-exec-1] c.p.a.k.i.service.impl.SyncServiceImpl   : cb-log:{"code":"101","createTime":"2020-01-02 21:46:17","message":"识别成功","uploadId":"76080420607754240"} ``` **发现所有单字母开头的数据都丢失了** </body>
		<created>2020-01-13 01:32:06</created>
		<closed>2020-03-16 18:44:58</closed>
	</bug>
	<bug>
		<id>1067</id>
		<title>Springboot下面 不能写，创建对象失败，cglib</title>
		<body>**触发场景描述**  **触发Bug的代码**                 EasyExcel.write(fileName, UploadBaseArchivesFileResponseVo.class).sheet("模板").doWrite(list);    这里写代码 ``` **提示的异常或者没有达到的效果** 2020-一月-09 18:47:22.722 ERROR [http-nio-8090-exec-2] c.y.c.e.h.ApiExceptionHandler - java.lang.reflect.InvocationTargetException--&gt;null net.sf.cglib.core.CodeGenerationException: java.lang.reflect.InvocationTargetException--&gt;null at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:237) at net.sf.cglib.beans.BeanMap$Generator.create(BeanMap.java:122) at net.sf.cglib.beans.BeanMap.create(BeanMap.java:58) at com.alibaba.excel.write.executor.ExcelWriteAddExecutor.addJavaObjectToExcel(ExcelWriteAddExecutor.java:114) at com.alibaba.excel.write.executor.ExcelWriteAddExecutor.addOneRowOfDataToExcel(ExcelWriteAddExecutor.java:65) at com.alibaba.excel.write.executor.ExcelWriteAddExecutor.add(ExcelWriteAddExecutor.java:51) at com.alibaba.excel.write.ExcelBuilderImpl.addContent(ExcelBuilderImpl.java:61) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:161) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:146) at com.alibaba.excel.write.builder.ExcelWriterSheetBuilder.doWrite(ExcelWriterSheetBuilder.java:190) at com.ydl.archives.api.BaseArchivesApi.batchUploadBaseArchivesFile(BaseArchivesApi.java:97) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:209) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:136) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:891) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:991) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:925) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:974) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:877) at javax.servlet.http.HttpServlet.service(HttpServlet.java:661) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:851) at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:109) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:800) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:806) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1498) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.reflect.InvocationTargetException: null at sun.reflect.GeneratedMethodAccessor41.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at net.sf.cglib.core.ReflectUtils.defineClass(ReflectUtils.java:384) at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:219) ... 64 common frames omitted Caused by: java.lang.LinkageError: loader (instance of  sun/misc/Launcher$AppClassLoader): attempted  duplicate class definition for name: "com/ydl/archives/vo/response/UploadBaseArchivesFileResponseVo$$BeanMapByCGLIB$$4feba77d" at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:756) ... 69 common frames omitted</body>
		<created>2020-01-09 10:54:35</created>
		<closed>2020-04-22 11:33:28</closed>
	</bug>
	<bug>
		<id>1062</id>
		<title>使用模板填充时，用名称指定Sheet页不起作用</title>
		<body>**触发场景描述** 根据模板填充的业务，模板是包含多个sheet页的模板，数据使用Map结构  **触发Bug的代码** ```java ExcelWriter excelWriter =   EasyExcel.write("resources/excel-template/r.xlsx").withTemplate("templateFileName").build(); WriteSheet writeSheet = EasyExcel.writerSheet("第二页").build(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();     map.put("name", "张三");     map.put("number", 5.2); excelWriter.fill(map, writeSheet); ``` **提示的异常或者没有达到的效果** 输出的结果r.xlsx 中，数据被填充到了第一个Sheet页里，没有填充到指定名称的“第二页”里  使用 index 的话， 是好用的  请帮忙看看！ 谢谢</body>
		<created>2020-01-08 11:01:40</created>
		<closed>2020-03-16 18:45:32</closed>
	</bug>
	<bug>
		<id>1056</id>
		<title>读取excel能正确读取所有行数，但是访问的实体所有字段都为null</title>
		<body>**触发场景描述** 调用EasyExcel.bulid().sheet().doRead() **触发Bug的代码** ```java //执行语句 EasyExcel.read("C:\\Users\\sam\\Desktop\\工作簿1.xls", DemoData.class, new IndexOrNameDataListener()).sheet().doRead();  //重写部分 public class IndexOrNameDataListener extends AnalysisEventListener&lt;DemoData&gt; {          private static final Logger LOGGER = LoggerFactory.getLogger(IndexOrNameDataListener.class);      List&lt;DemoData&gt; list = new ArrayList&lt;&gt;();      @Override     public void invoke(DemoData data, AnalysisContext context) {         list.add(data);     }      //对应的实体 @Data public class DemoData {     @ExcelProperty(index = 2)     private Double doubleData;     /**      * 用名字去匹配，这里需要注意，如果名字重复，会导致只有一个字段读取到数据      */     @ExcelProperty("字符串标题")     private String string;     @ExcelProperty("日期标题")     private Date date; }  ``` 读取excel能正确读取所有行数，但是访问的实体所有字段都为null 上面代码中重写的invoke方法中的data，所有字段为null ![image](https://user-images.githubusercontent.com/29800728/71793440-cbffc580-3077-11ea-88b0-c82fcae53ff6.png)  </body>
		<created>2020-01-06 03:29:32</created>
		<closed>2020-01-07 13:51:26</closed>
	</bug>
	<bug>
		<id>1046</id>
		<title>当类的属性没有按照ExcelProperty的属性index顺序排序的时候，写数据出现错乱</title>
		<body>**触发场景描述** 当类的属性没有按照ExcelProperty注解的属性index排序的时候，写数据出现错乱顺序 **触发Bug的代码** ```java    public class EasyExcelFound {      /**      * 写数据      */     @Test     public void indexNotSort() {         Path path = Paths.get("/home/liuxu/Public/not-sort.xlsx");         ExcelWriter excelWriter = EasyExcel.write(path.toFile())                 .build();         WriteSheet writeSheet = EasyExcel.writerSheet("出现不排序的情况")                 .head(head())                 .build();          excelWriter.write(data(),writeSheet);         excelWriter.finish();     }      private List&lt;List&lt;String&gt;&gt; head() {         List&lt;List&lt;String&gt;&gt; head = new ArrayList&lt;&gt;();         head.add(Collections.singletonList("名字"));         head.add(Collections.singletonList("ID编号"));         return head;     }      public List&lt;CluesDto&gt; data() {         return IntStream.rangeClosed(0, 3)                 .boxed()                 .map(integer -&gt; {                     CluesDto cluesDto = new CluesDto();                     cluesDto.setId(integer);                     cluesDto.setName("线索名字-" + integer);                     cluesDto.setCreateDate(new Date());                     return cluesDto;                 })                 .collect(Collectors.toList());     } }  @ExcelIgnoreUnannotated class CluesDto {     @ExcelProperty(index = 1)     private Integer id;      @ExcelProperty(index = 0)     private String name;      private Date createDate;      public Integer getId() {         return id;     }      public void setId(Integer id) {         this.id = id;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public Date getCreateDate() {         return createDate;     }      public void setCreateDate(Date createDate) {         this.createDate = createDate;     } } ``` **提示的异常或者没有达到的效果** 写入结果为: ![not-sort](https://user-images.githubusercontent.com/31197548/71648972-c6d40b00-2d45-11ea-8354-d656a3ced7cc.png)  可以看到excel中的：名字和ID编号两列写反了。  目前的解决方案：在CluesDto类中，把id,name属性按照index的增长顺序写就行，也就是调整为: ``` @ExcelIgnoreUnannotated class CluesDto {     @ExcelProperty(index = 0)     private String name;      @ExcelProperty(index = 1)     private Integer id;      private Date createDate;      public Integer getId() {         return id;     }      public void setId(Integer id) {         this.id = id;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public Date getCreateDate() {         return createDate;     }      public void setCreateDate(Date createDate) {         this.createDate = createDate;     } } ``` 跟踪了下源码，发现： com.alibaba.excel.util.ClassUtils类中获取declaredFields的方法，获取allFieldList没有按照ExcelProperty的index进行排序。导致后面写入数据的时候获取fieldList只是按照反射拿取的字段顺序为准，并没有按照index排序。  </body>
		<created>2020-01-02 02:03:28</created>
		<closed>2020-04-24 11:38:12</closed>
	</bug>
	<bug>
		<id>1038</id>
		<title>读取手机号时候变成科学计算法</title>
		<body>读取手机号时候变成科学计算法</body>
		<created>2019-12-30 02:53:26</created>
		<closed>2020-01-07 14:04:19</closed>
	</bug>
	<bug>
		<id>1029</id>
		<title>2.1.3版本autoCloseStream设置为false也会自动关闭流</title>
		<body>**触发场景描述** InputStream先用于读取excel，再用于上传到oss **触发Bug的代码** ```java    EasyExcel.read(is, Order.class, listener)                 .autoCloseStream(false)                 .sheet()                 .headRowNumber(3)                 .doReadSync(); ``` **提示的异常或者没有达到的效果** 上传oss的时候出现 java.io.IOException: Stream closed</body>
		<created>2019-12-26 07:51:31</created>
		<closed>2020-03-17 15:10:17</closed>
	</bug>
	<bug>
		<id>1025</id>
		<title>导出xlsx文件，打开提示“部分内容有问题，是否让我们尽量尝试恢复？”</title>
		<body>**触发场景描述** ![image](https://user-images.githubusercontent.com/19327340/71445647-38182a80-2756-11ea-8e3e-62195110d5fa.png)  下面是导出有问题的表格文件 [1577274701056.xlsx](https://github.com/alibaba/easyexcel/files/4000448/1577274701056.xlsx)  使用版本 ```         &lt;dependency&gt;             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;             &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;             &lt;version&gt;2.1.3&lt;/version&gt;         &lt;/dependency&gt; ``` **触发Bug的代码** ```java List&lt;NumberExportData&gt; numberExportData = numberManagerService.numberExport(cloudAccountId, mode,                         telX, areaCode, buyStartTime, buyEndTime);  LOGGER.info("numberExport controller result size: {}", numberExportData.size()); response.setContentType("application/vnd.ms-excel"); response.setCharacterEncoding("utf-8"); response.setHeader("Content-disposition",                         "attachment;filename=" + System.currentTimeMillis() + ".xlsx");  EasyExcel.write(response.getOutputStream(), NumberExportData.class).excelType(ExcelTypeEnum.XLSX)                         .sheet("号码列表").doWrite(numberExportData); ``` **提示的异常或者没有达到的效果** </body>
		<created>2019-12-25 12:38:51</created>
		<closed>2019-12-28 12:01:38</closed>
	</bug>
	<bug>
		<id>1021</id>
		<title>EasyExcel版本2.1.4，poi版本3.17，withTemplate模板写入时，main方法测试正常，通过接口调用，在service中执行失败</title>
		<body>**触发场景描述**  public static void main(String args[]) {         System.out.println("Hello World!");         doExport("20191225");     }  private static void doExport(String day) {         String name = "模板15";         String templateFileName = FileUtil.getPath() + "demo" + File.separator + "fill" + File.separator + name + ".xlsx";         boolean isExists = new File(templateFileName).exists();         SimpleDateFormat sdf = new SimpleDateFormat("yyyy.MM.dd HH:mm:ss");         String str = sdf.format(new Date());         String fileName = FileUtil.getPath() + name + " - " + str + ".xlsx";         String fileNameFinal = FileUtil.getPath() + name + "- 最后数据 - " + str + ".xlsx";         String imagePath = FileUtil.getPath() + name + str + ".png";         String imagePathFinal = FileUtil.getPath() + name + "- 最后数据 - " + str + ".png";         ExcelWriter excelWriter = EasyExcel.write(fileName).withTemplate(templateFileName).build(); }  描述： 1、doExport（）方法在main（）方法中执行正常，可以生成新的excel文件 2. 通过接口访问（Controller-&gt;ServiceImpl）中调用doExport（）方法，则失败（未生成新的excel文件，服务自动重启）。     **触发Bug的代码**         ExcelWriter excelWriter = EasyExcel.write(fileName).withTemplate(templateFileName).build();  ``` **提示的异常或者没有达到的效果** 1.并没有生成新的excel文件，且会自动重启服务。 2.提示Shutting down ExecutorService 'applicationTaskExecutor'  [Thread-4 com.zaxxer.hikari.HikariDataSource] - HikariPool-1 - Shutdown initiated... [Thread-4 com.zaxxer.hikari.HikariDataSource] - HikariPool-1 - Shutdown completed.  </body>
		<created>2019-12-25 08:10:14</created>
		<closed>2020-03-17 15:23:57</closed>
	</bug>
	<bug>
		<id>1018</id>
		<title>使用纵向填充的方式去填充模板1使其变成另一个模板2，再运行另一个程序去填充模板2就不行了</title>
		<body>**触发场景描述** 使用纵向填充的方式去填充模板1使其生成另一个模板2，再运行另一个程序去填充模板2就不行了，目前发现必须在windos上打开后保存再去执行填充模板2就正常了 **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** </body>
		<created>2019-12-24 09:24:31</created>
		<closed>2019-12-25 06:01:00</closed>
	</bug>
	<bug>
		<id>1017</id>
		<title>文本格式的数字类型，解析时自动加上小数点</title>
		<body>**触发场景描述** 文本格式的数字，例如1，解析后变成 "1.0"  **触发Bug的代码** ```java   public final class NumberRecord extends CellRecord implements Cloneable {     public static final short sid = 0x0203;     private double field_4_value;       /**      * set the value for the cell      *      * @param value  double representing the value      */      // 用浮点类型接受，1这类的自动变成了浮点，导致后面toString的时候变成了1.0     public void setValue(double value){         field_4_value = value;     }  ``` **提示的异常或者没有达到的效果** </body>
		<created>2019-12-24 08:27:58</created>
		<closed>2019-12-28 12:00:05</closed>
	</bug>
	<bug>
		<id>1010</id>
		<title>使用自动列宽LongestMatchColumnWidthStyleStrategy时，第二次发送同样sheet的邮件，列宽未设置</title>
		<body>**触发场景描述** 表格的sheet有三个，第一次发送邮件，列宽是根据数据自动列宽；第二次发送邮件，列宽未设置 **触发Bug的代码** ```java    // 此处生命的CACHE是静态的，类被初始化后，所有类都共享    private static final Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; CACHE = new HashMap&lt;Integer, Map&lt;Integer, Integer&gt;&gt;(8);      @Override     protected void setColumnWidth(WriteSheetHolder writeSheetHolder, List&lt;CellData&gt; cellDataList, Cell cell, Head head,         Integer relativeRowIndex, Boolean isHead) {         boolean needSetWidth = isHead || !CollectionUtils.isEmpty(cellDataList);         if (!needSetWidth) {             return;         }         // 此处是从CACHE中获取，第一次发邮件时，CACHE中有3个key(0,1,2)，第二次发邮件，sheetNo还是0,1,2，所以取出了上次发邮件的sheetNo对应的内容         Map&lt;Integer, Integer&gt; maxColumnWidthMap = CACHE.get(writeSheetHolder.getSheetNo());         if (maxColumnWidthMap == null) {             maxColumnWidthMap = new HashMap&lt;Integer, Integer&gt;(16);             CACHE.put(writeSheetHolder.getSheetNo(), maxColumnWidthMap);         }         Integer columnWidth = dataLength(cellDataList, cell, isHead);         if (columnWidth &lt; 0) {             return;         }         if (columnWidth &gt; MAX_COLUMN_WIDTH) {             columnWidth = MAX_COLUMN_WIDTH;         }         // maxColumnWidthMap变量根据上面代码逻辑，就是上次发邮件sheet的map，此时columnIndex也是一样的，第二次发邮件时，maxColumnWidth不会为null，且与columnWidth基本相等，就不会进入设置宽度的方法，所以第二次发邮件时，宽度就未设置         Integer maxColumnWidth = maxColumnWidthMap.get(cell.getColumnIndex());         if (maxColumnWidth == null || columnWidth &gt; maxColumnWidth) {             maxColumnWidthMap.put(cell.getColumnIndex(), columnWidth);             writeSheetHolder.getSheet().setColumnWidth(cell.getColumnIndex(), columnWidth * 256);         }     } ``` **提示的异常或者没有达到的效果** 期望第二次发邮件时，也应该自动设置列宽，而不是从静态的CACHE获取，因为sheetNo，两次邮件会一样的，只是根据源码逻辑推断，如果是我使用错了，还望告知方案，感谢</body>
		<created>2019-12-23 03:18:28</created>
		<closed>2020-04-22 12:32:13</closed>
	</bug>
	<bug>
		<id>1009</id>
		<title>POJO类属性名为xXxxx无法读取属性值</title>
		<body>** 当要转Excel的POJO类属性名为xXxxx的小驼峰格式时，即第一个字母为小写，第二个字母为大写时，转出的Excel无法生成属性值 **  **触发Bug的代码** ```java    @Data    class SomeClass {         private String mParam1;   } ``` </body>
		<created>2019-12-22 06:29:52</created>
		<closed>2019-12-22 09:47:29</closed>
	</bug>
	<bug>
		<id>1007</id>
		<title>读取EXCEL超列</title>
		<body>**触发场景描述** 实体类属性字段读取Excel最大列设置28列 但是Excel里面如果某些行中28列之后也有数据 依然会读取并且报错  **提示的异常或者没有达到的效果** 前面是从异常类中获取的行号列号 第9行第42列 | For input string: "未完成整改的主要原因"  </body>
		<created>2019-12-21 02:01:00</created>
		<closed>2019-12-22 09:48:35</closed>
	</bug>
	<bug>
		<id>1005</id>
		<title>easyexcel动态指定头不能自定义颜色</title>
		<body>**触发场景描述**  **触发Bug的代码** ```java WriteCellStyle headWriteCellStyle = new WriteCellStyle();         WriteFont headWriteFont = new WriteFont();         headWriteFont.setFontHeightInPoints((short) 10);         headWriteCellStyle.setWriteFont(headWriteFont);         WriteCellStyle contentWriteCellStyle = new WriteCellStyle();         WriteFont contentWriteFont = new WriteFont();         contentWriteFont.setFontHeightInPoints((short) 10);         contentWriteFont.setColor(IndexedColors.RED.getIndex());         contentWriteCellStyle.setWriteFont(contentWriteFont);         HorizontalCellStyleStrategy horizontalCellStyleStrategy =                 new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle);         response.setContentType("application/vnd.ms-excel");         response.setCharacterEncoding("utf-8");          String fileNewName = URLEncoder.encode(fileName, "UTF-8");         response.setHeader("Content-disposition", "attachment;filename=" + fileNewName + ".xlsx");         EasyExcel.write(response.getOutputStream()).head(head).registerWriteHandler(horizontalCellStyleStrategy).sheet(sheetName).doWrite(list);      ``` **提示的异常或者没有达到的效果** 动态头是不可以指定颜色吗？</body>
		<created>2019-12-20 12:33:18</created>
		<closed>2019-12-20 12:35:11</closed>
	</bug>
	<bug>
		<id>1000</id>
		<title>HorizontalCellStyleStrategy 策略设置单元格样式没有起作用</title>
		<body>**触发场景描述** 在你们提供的 demo  com.alibaba.easyexcel.test.demo.write.WriteTest.styleWrite() 方法中，如果把表头设置去掉的话，excel 的样式设置 HorizontalCellStyleStrategy 策略就不起作用了。  **触发Bug的代码** ```                 EasyExcel.write(fileName).registerWriteHandler(horizontalCellStyleStrategy).sheet("模板")             .doWrite(data());      ``` **提示的异常或者没有达到的效果** HorizontalCellStyleStrategy 设置单元的策略没有生效，把 excel 表头设置加上就好了，去掉就不行。  加表头后导出的 excel 效果: ![image](https://user-images.githubusercontent.com/6457270/71239755-55a65800-2342-11ea-8662-48ad90848062.png) 去掉表头后导出的 excel 效果:  ![image](https://user-images.githubusercontent.com/6457270/71239945-cf3e4600-2342-11ea-87a9-a52b7184f257.png) </body>
		<created>2019-12-20 08:07:37</created>
		<closed>2019-12-22 09:52:02</closed>
	</bug>
	<bug>
		<id>996</id>
		<title>填充合并好的列表第一个正常后面就错了</title>
		<body>**触发场景描述**  **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** 模板效果 ![86U~M29$QNDT5MSRND7}VJS](https://user-images.githubusercontent.com/35451875/71139731-fcf39400-2249-11ea-9cbb-1edc8ec237f4.png) 填充后的效果  ![TIM截图20191219102723](https://user-images.githubusercontent.com/35451875/71139794-2dd3c900-224a-11ea-95b1-d66a39ca01bf.png) </body>
		<created>2019-12-19 02:29:20</created>
		<closed>2019-12-25 06:02:38</closed>
	</bug>
	<bug>
		<id>994</id>
		<title>填充Excel文件至OutputStream流时，无法正常打开文件</title>
		<body>**使用模板填充功能实现Excel文件下载，前端能正常触发下载，但无法打开文件，WPS显示：WPS表格在打开文件时遇到错误**  **触发Bug的代码** ```java  String fileName = URLEncoder.encode("日志明细表", "UTF-8");  response.setContentType("application/vnd.ms-excel");  response.setCharacterEncoding("UTF-8");   response.setHeader("Content-disposition", "attachement:filename=" + fileName + ".xlsx");   ServletOutputStream outputStream = response.getOutputStream();   ClassPathResource resource = new ClassPathResource("xlsx" + File.separator + "logTemplate.xlsx");             String tmplPath = resource.getFile().getPath();             ExcelWriter excelWriter = EasyExcel.write(outputStream).withTemplate(tmplPath).build();             WriteSheet writeSheet = EasyExcel.writerSheet(0).build();             excelWriter.fill(logs, writeSheet);             excelWriter.finish(); ``` **整个过程无法未出现任何异常提示** </body>
		<created>2019-12-18 16:58:55</created>
		<closed>2019-12-28 11:57:59</closed>
	</bug>
	<bug>
		<id>993</id>
		<title>当excel第一行为空时，没有进入invokeHeadMap</title>
		<body>**触发场景描述** 当工作簿的第一行为空行时，直接跳过了invokeHeadMap 设置ignoreEmptyRow=false也没作用    **触发Bug的代码** ```java  EasyExcelListener excelListener = new EasyExcelListener(handleService);  EasyExcel.read(fileName,null, excelListener).ignoreEmptyRow(false).doReadAll(); ``` **提示的异常或者没有达到的效果** </body>
		<created>2019-12-18 11:23:53</created>
		<closed>2020-04-24 11:32:04</closed>
	</bug>
	<bug>
		<id>991</id>
		<title>测试环境突然出现 Can not close IO，列表数据查询没有问题，一出现这个问题，所有的报表导出都无法使用了</title>
		<body>**触发场景描述** ![image](https://user-images.githubusercontent.com/35447633/71065273-e4cd3780-21ab-11ea-8345-c427da4d94d3.png)  **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果**  com.alibaba.excel.exception.ExcelGenerateException: Can not close IO at com.alibaba.excel.context.WriteContextImpl.finish(WriteContextImpl.java:328) at com.alibaba.excel.write.ExcelBuilderImpl.finish(ExcelBuilderImpl.java:98) at com.alibaba.excel.write.ExcelBuilderImpl.finishOnException(ExcelBuilderImpl.java:92) at com.alibaba.excel.write.ExcelBuilderImpl.addContent(ExcelBuilderImpl.java:63) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:161) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:146) at com.alibaba.excel.write.builder.ExcelWriterSheetBuilder.doWrite(ExcelWriterSheetBuilder.java:179) at cn.com.siss.member.finance.controller.admin.FinanceOrderAdminController.financeOrderExport(FinanceOrderAdminController.java:167) at cn.com.siss.member.finance.controller.admin.FinanceOrderAdminController$$FastClassBySpringCGLIB$$d45f3626.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:738) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157) at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:52) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:85) at cn.com.siss.spring.boot.logging.LogAspect.timeAround(LogAspect.java:194) at cn.com.siss.spring.boot.logging.LogAspect.controllerAround(LogAspect.java:181) at sun.reflect.GeneratedMethodAccessor250.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:629) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:618) at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:52) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:52) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:168) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:673) at cn.com.siss.member.finance.controller.admin.FinanceOrderAdminController$$EnhancerBySpringCGLIB$$eb0c532a.financeOrderExport(&lt;generated&gt;) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:133) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872) at javax.servlet.http.HttpServlet.service(HttpServlet.java:661) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.boot.web.filter.ApplicationContextHeaderFilter.doFilterInternal(ApplicationContextHeaderFilter.java:55) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.boot.actuate.trace.WebRequestTraceFilter.doFilterInternal(WebRequestTraceFilter.java:110) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:108) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.boot.actuate.autoconfigure.MetricsFilter.doFilterInternal(MetricsFilter.java:106) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:478) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:80) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:799) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1455) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.NoSuchMethodError: org.apache.poi.ss.usermodel.Workbook.close()V at com.alibaba.excel.context.WriteContextImpl.finish(WriteContextImpl.java:286) ... 100 common frames omitted</body>
		<created>2019-12-18 07:34:49</created>
		<closed>2019-12-18 10:52:13</closed>
	</bug>
	<bug>
		<id>989</id>
		<title>读文件和写文件都抛java.lang.ExceptionInInitializerError</title>
		<body>**触发场景描述** 引入依赖，按照demo示例读文件和写文件  **触发Bug的代码** ```xml &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt; &lt;/dependency&gt; ```  ```java @Data public class MyLogEntity {     @ExcelProperty("dt")     private String dt;     @ExcelProperty("hour")     private String hour;     @ExcelProperty("ctime")     private String ctime;     @ExcelProperty("ip")     private String ip;     @ExcelProperty("status")     private String status;      public String getDt() {         return dt;     }      public void setDt(String dt) {         this.dt = dt;     }      public String getHour() {         return hour;     }      public void setHour(String hour) {         this.hour = hour;     }      public String getCtime() {         return ctime;     }      public void setCtime(String ctime) {         this.ctime = ctime;     }      public String getIp() {         return ip;     }      public void setIp(String ip) {         this.ip = ip;     }      public String getStatus() {         return status;     }      public void setStatus(String status) {         this.status = status;     } } ``` ```java public class MyLogEntityListener extends AnalysisEventListener&lt;MyLogEntity&gt; {     private static final Logger LOGGER = LoggerFactory.getLogger(MyLogEntityListener.class);     private static final Gson GSON = new Gson();      @Override     public void invoke(MyLogEntity myLogEntity, AnalysisContext analysisContext) {         LOGGER.info("解析到一条数据:{}", GSON.toJson(myLogEntity));     }      @Override     public void doAfterAllAnalysed(AnalysisContext analysisContext) {         LOGGER.info("所有数据解析完成！");     } } ``` ```java public class ExcelTest {     @Test     public void read() {         String fileName = "/Users/turui/Desktop/excel-test.xlsx";         EasyExcel.read(fileName, MyLogEntity.class, new MyLogEntityListener()).sheet().doRead();     }      @Test     public void write() {         List&lt;MyLogEntity&gt; data = Lists.newArrayList();         for (int i = 0;i &lt; 10; i++) {             MyLogEntity myLogEntity = new MyLogEntity();             myLogEntity.setDt("20190101");             data.add(myLogEntity);         }         String fileName = "/Users/turui/Desktop/test_write" + System.currentTimeMillis() + ".xlsx";         EasyExcel.write(fileName, MyLogEntity.class).sheet("模板1").doWrite(data);     } }    ``` **提示的异常或者没有达到的效果** 读写文件都会抛出异常  com.alibaba.excel.exception.ExcelGenerateException: java.lang.ExceptionInInitializerError at com.alibaba.excel.write.ExcelBuilderImpl.addContent(ExcelBuilderImpl.java:67) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:161) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:146) at com.alibaba.excel.write.builder.ExcelWriterSheetBuilder.doWrite(ExcelWriterSheetBuilder.java:190) at com.meituan.rc.holmes.service.util.ExcelTest.write(ExcelTest.java:29) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: java.lang.ExceptionInInitializerError at net.sf.cglib.beans.BeanMap.create(BeanMap.java:57) at com.alibaba.excel.write.executor.ExcelWriteAddExecutor.addJavaObjectToExcel(ExcelWriteAddExecutor.java:114) at com.alibaba.excel.write.executor.ExcelWriteAddExecutor.addOneRowOfDataToExcel(ExcelWriteAddExecutor.java:65) at com.alibaba.excel.write.executor.ExcelWriteAddExecutor.add(ExcelWriteAddExecutor.java:51) at com.alibaba.excel.write.ExcelBuilderImpl.addContent(ExcelBuilderImpl.java:61) ... 26 more Caused by: java.lang.IllegalStateException: Unable to load cache item at net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:79) at net.sf.cglib.core.internal.LoadingCache.get(LoadingCache.java:34) at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData.get(AbstractClassGenerator.java:116) at net.sf.cglib.core.AbstractClassGenerator.create(AbstractClassGenerator.java:291) at net.sf.cglib.core.KeyFactory$Generator.create(KeyFactory.java:221) at net.sf.cglib.core.KeyFactory.create(KeyFactory.java:174) at net.sf.cglib.core.KeyFactory.create(KeyFactory.java:157) at net.sf.cglib.core.KeyFactory.create(KeyFactory.java:149) at net.sf.cglib.beans.BeanMap$Generator.&lt;clinit&gt;(BeanMap.java:66) ... 31 more Caused by: java.lang.IncompatibleClassChangeError: class net.sf.cglib.core.DebuggingClassWriter has interface org.objectweb.asm.ClassVisitor as super class at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:763) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) at java.net.URLClassLoader.defineClass(URLClassLoader.java:467) at java.net.URLClassLoader.access$100(URLClassLoader.java:73) at java.net.URLClassLoader$1.run(URLClassLoader.java:368) at java.net.URLClassLoader$1.run(URLClassLoader.java:362) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:361) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:335) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) at net.sf.cglib.core.DefaultGeneratorStrategy.getClassVisitor(DefaultGeneratorStrategy.java:30) at net.sf.cglib.core.DefaultGeneratorStrategy.generate(DefaultGeneratorStrategy.java:24) at net.sf.cglib.core.AbstractClassGenerator.generate(AbstractClassGenerator.java:329) at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:93) at net.sf.cglib.core.AbstractClassGenerator$ClassLoaderData$3.apply(AbstractClassGenerator.java:91) at net.sf.cglib.core.internal.LoadingCache$2.call(LoadingCache.java:54) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at net.sf.cglib.core.internal.LoadingCache.createEntry(LoadingCache.java:61) ... 39 more  </body>
		<created>2019-12-18 05:37:58</created>
		<closed>2019-12-18 08:11:16</closed>
	</bug>
	<bug>
		<id>985</id>
		<title>2.1.4 读取所有格式相同的sheet 重复保存</title>
		<body>**触发场景描述** 读取所有格式相同的sheet重复保存 **触发Bug的代码** // 按demo上面来写的  String fileName = TestFileUtil.getPath() + "demo" + File.separator + "demo.xlsx";     // 读取全部sheet     // 这里需要注意 DemoDataListener的doAfterAllAnalysed 会在每个sheet读取完毕后调用一次。然后所有sheet都会往同一个DemoDataListener里面写     EasyExcel.read(fileName, DemoData.class, new DemoDataListener()).doReadAll(); **提示的异常或者没有达到的效果** sheet1  :   1,2 sheet2  :   3,4 最终保存在数据库 : 1,2,1,2,3,4</body>
		<created>2019-12-17 01:47:14</created>
		<closed>2019-12-18 05:35:36</closed>
	</bug>
	<bug>
		<id>984</id>
		<title>读取多个sheet 重复了</title>
		<body>读取多个内容相同的sheet  **触发Bug的代码** ```java String fileName = TestFileUtil.getPath() + "demo" + File.separator + "demo.xlsx";     // 读取全部sheet     // 这里需要注意 DemoDataListener的doAfterAllAnalysed 会在每个sheet读取完毕后调用一次。然后所有sheet都会往同一个DemoDataListener里面写     EasyExcel.read(fileName, DemoData.class, new DemoDataListener()).doReadAll(); ``` **提示的异常或者没有达到的效果** sheet1中数据  1 ,2 sheet2中数据  3,4 最终保存数据 1,2,1,2,3,4 </body>
		<created>2019-12-17 01:31:10</created>
		<closed>2019-12-17 01:37:42</closed>
	</bug>
	<bug>
		<id>980</id>
		<title>com.alibaba.excel.exception.ExcelDataConvertException: Can not find 'Converter' support class LocalDateTime.</title>
		<body>**触发场景描述**  **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** com.alibaba.excel.exception.ExcelDataConvertException: Can not find 'Converter' support class LocalDateTime. at com.alibaba.excel.write.executor.AbstractExcelWriteExecutor.doConvert(AbstractExcelWriteExecutor.java:108) at com.alibaba.excel.write.executor.AbstractExcelWriteExecutor.convert(AbstractExcelWriteExecutor.java:93) at com.alibaba.excel.write.executor.AbstractExcelWriteExecutor.converterAndSet(AbstractExcelWriteExecutor.java:39) at com.alibaba.excel.write.executor.ExcelWriteAddExecutor.addJavaObjectToExcel(ExcelWriteAddExecutor.java:137) at com.alibaba.excel.write.executor.ExcelWriteAddExecutor.addOneRowOfDataToExcel(ExcelWriteAddExecutor.java:65) at com.alibaba.excel.write.executor.ExcelWriteAddExecutor.add(ExcelWriteAddExecutor.java:51) at com.alibaba.excel.write.ExcelBuilderImpl.addContent(ExcelBuilderImpl.java:61) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:161) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:146)</body>
		<created>2019-12-14 07:26:40</created>
		<closed>2020-03-17 15:34:18</closed>
	</bug>
	<bug>
		<id>979</id>
		<title>模版里面的单元格合并有问题</title>
		<body>**触发场景描述** 模版如下：  ![image](https://user-images.githubusercontent.com/13598763/70841952-df918500-1e59-11ea-9535-0ed8ac8c1495.png)    **触发Bug的代码** ```java @Test     public void listFill() {         // 模板注意 用{} 来表示你要用的变量 如果本来就有"{","}" 特殊字符 用"\{","\}"代替         // 填充list 的时候还要注意 模板中{.} 多了个点 表示list         String templateFileName =                 TestFileUtil.getPath() + File.separator + "list.xlsx";          // 方案1 一下子全部放到内存里面 并填充         String fileName = TestFileUtil.getPath()  + "listFill" + System.currentTimeMillis() + ".xlsx";         // 这里 会填充到第一个sheet， 然后文件流会自动关闭         EasyExcel.write(fileName).withTemplate(templateFileName).sheet().doFill(data());          // 方案2 分多次 填充 会使用文件缓存（省内存）         fileName = TestFileUtil.getPath() + "listFill" + System.currentTimeMillis() + ".xlsx";         ExcelWriter excelWriter = EasyExcel.write(fileName).withTemplate(templateFileName).build();         WriteSheet writeSheet = EasyExcel.writerSheet().build();         excelWriter.fill(data(), writeSheet);         excelWriter.fill(data(), writeSheet);         // 千万别忘记关闭流         excelWriter.finish();     }      private List&lt;FillData&gt; data() {         List&lt;FillData&gt; list = new ArrayList&lt;FillData&gt;();         for (int i = 0; i &lt; 10; i++) {             FillData fillData = new FillData();             list.add(fillData);             fillData.setName("张三");             fillData.setNumber(5.2);             fillData.setNumber2(3.4);         }         return list;     } ``` **提示的异常或者没有达到的效果** 输出的结果没有合并单元格，而是最后面多了一行 ![image](https://user-images.githubusercontent.com/13598763/70841986-f59f4580-1e59-11ea-9de5-8eb661450236.png)  </body>
		<created>2019-12-14 02:10:53</created>
		<closed>2019-12-14 05:55:21</closed>
	</bug>
	<bug>
		<id>977</id>
		<title>excel并发写出现异常异常ExcelDataConvertException: Can not find 'Converter' support class String.  </title>
		<body>**触发场景描述** 在做excel导出压力测试时，出现异常：com.alibaba.excel.exception.ExcelDataConvertException: Can not find 'Converter' support class String. **触发Bug的代码** ```java try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {     EasyExcel.write(outputStream).sheet().doWrite(sampleResp.getData().getData());     //.... } ``` **提示的异常或者没有达到的效果** 异常堆栈如下： ``` Caused by: com.alibaba.excel.exception.ExcelDataConvertException: Can not find 'Converter' support class String.         at com.alibaba.excel.write.ExcelBuilderImpl.convert(ExcelBuilderImpl.java:366)         at com.alibaba.excel.write.ExcelBuilderImpl.converterAndSet(ExcelBuilderImpl.java:304)         at com.alibaba.excel.write.ExcelBuilderImpl.doAddBasicTypeToExcel(ExcelBuilderImpl.java:195)         at com.alibaba.excel.write.ExcelBuilderImpl.addBasicTypeToExcel(ExcelBuilderImpl.java:185)         at com.alibaba.excel.write.ExcelBuilderImpl.addOneRowOfDataToExcel(ExcelBuilderImpl.java:126)         at com.alibaba.excel.write.ExcelBuilderImpl.doAddContent(ExcelBuilderImpl.java:79)         at com.alibaba.excel.write.ExcelBuilderImpl.addContent(ExcelBuilderImpl.java:93)         at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:155)         at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:140)         at com.alibaba.excel.write.builder.ExcelWriterSheetBuilder.doWrite(ExcelWriterSheetBuilder.java:134)         at com.haixue.datamart.biz.TaskExecuteBiz.estimateFileSize(TaskExecuteBiz.java:156)         at com.haixue.datamart.biz.TaskExecuteBiz.preCheck(TaskExecuteBiz.java:113) ``` 跟代码发现`DefaultConverterLoader.loadDefaultWriteConverter()`方法是非线程安全的，不确定是否因为此方法导致出现该异常？</body>
		<created>2019-12-13 03:11:18</created>
		<closed>2019-12-23 06:45:08</closed>
	</bug>
	<bug>
		<id>972</id>
		<title>使用lombok @Builder 映射不到实体</title>
		<body>**触发场景描述** 读取映射 **触发Bug的代码** ```java @Builder @Data @Entity @Table(name = "tsccheck_on_work") public class AttendSheet implements Serializable { ``` **提示的异常或者没有达到的效果** Caused by: java.lang.IllegalAccessException: Class com.alibaba.excel.read.listener.ModelBuildEventListener can not access a member of class com.demo with modifiers "" at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:102) at java.lang.Class.newInstance(Class.java:436) at com.alibaba.excel.read.listener.ModelBuildEventListener.buildUserModel(ModelBuildEventListener.java:94) ... 47 more</body>
		<created>2019-12-12 03:02:21</created>
		<closed>2019-12-12 10:04:34</closed>
	</bug>
	<bug>
		<id>971</id>
		<title>导入Excel xls 格式的时候   不能被识别 导致读到的对象为空</title>
		<body>**触发场景描述**  **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** </body>
		<created>2019-12-11 07:52:02</created>
		<closed>2020-01-07 14:06:30</closed>
	</bug>
	<bug>
		<id>969</id>
		<title>实体类使用lombok的@Accessors(chain = true)注解，当读取excel封装为该实体类时，不能封装数据</title>
		<body>见标题 </body>
		<created>2019-12-10 06:42:40</created>
		<closed>2019-12-12 10:07:52</closed>
	</bug>
	<bug>
		<id>957</id>
		<title> Convert data XF2D to int error 导入报错</title>
		<body>**触发场景描述** 导入excel，解析的时候直接到了onException **触发Bug的代码** 最简单的导入，excel中该字段为一个4位的英文数字混合编码 ```java EasyExcel.read(file.getInputStream(), dataClass, readListener).sheet().doRead(); ``` &gt; 报错信息 ``` com.alibaba.excel.exception.ExcelDataConvertException: Convert data XF2D to int error  at com.alibaba.excel.util.ConverterUtils.doConvertToJavaObject(ConverterUtils.java:135) at com.alibaba.excel.util.ConverterUtils.convertToJavaObject(ConverterUtils.java:103) at com.alibaba.excel.read.listener.ModelBuildEventListener.buildUserModel(ModelBuildEventListener.java:113) at com.alibaba.excel.read.listener.ModelBuildEventListener.invoke(ModelBuildEventListener.java:38) at com.alibaba.excel.read.listener.ModelBuildEventListener.invoke(ModelBuildEventListener.java:28) at com.alibaba.excel.read.metadata.holder.AbstractReadHolder.notifyEndOneRow(AbstractReadHolder.java:145) at com.alibaba.excel.analysis.v07.handlers.ProcessResultCellHandler.endHandle(ProcessResultCellHandler.java:44) at com.alibaba.excel.analysis.v07.XlsxRowHandler.endElement(XlsxRowHandler.java:44) at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.endElement(AbstractSAXParser.java:609) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanEndElement(XMLDocumentFragmentScannerImpl.java:1782) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2967) at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:602) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:505) at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:842) at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:771) at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:141) at com.sun.org.apache.xerces.internal.parsers.AbstractSAXParser.parse(AbstractSAXParser.java:1213) at com.sun.org.apache.xerces.internal.jaxp.SAXParserImpl$JAXPSAXParser.parse(SAXParserImpl.java:643) at com.alibaba.excel.analysis.v07.XlsxSaxAnalyser.parseXmlSource(XlsxSaxAnalyser.java:165) at com.alibaba.excel.analysis.v07.XlsxSaxAnalyser.execute(XlsxSaxAnalyser.java:189) at com.alibaba.excel.analysis.ExcelAnalyserImpl.analysis(ExcelAnalyserImpl.java:105) at com.alibaba.excel.ExcelReader.read(ExcelReader.java:180) at com.alibaba.excel.ExcelReader.read(ExcelReader.java:170) at com.alibaba.excel.read.builder.ExcelReaderSheetBuilder.doRead(ExcelReaderSheetBuilder.java:160) at com.reemii.dataer.controller.ImportController.token(ImportController.java:30) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:189) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:892) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1038) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:908) at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.boot.actuate.web.trace.servlet.HttpTraceFilter.doFilterInternal(HttpTraceFilter.java:90) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.filterAndRecordMetrics(WebMvcMetricsFilter.java:117) at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:106) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:200) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748) Caused by: java.lang.NumberFormatException: For input string: "XF2D" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Integer.parseInt(Integer.java:580) at java.lang.Integer.valueOf(Integer.java:766) at com.alibaba.excel.util.NumberUtils.parseInteger(NumberUtils.java:90) at com.alibaba.excel.converters.integer.IntegerStringConverter.convertToJavaData(IntegerStringConverter.java:32) at com.alibaba.excel.converters.integer.IntegerStringConverter.convertToJavaData(IntegerStringConverter.java:17) at com.alibaba.excel.util.ConverterUtils.doConvertToJavaObject(ConverterUtils.java:133) ... 87 more ``` **提示的异常或者没有达到的效果** </body>
		<created>2019-12-06 12:40:53</created>
		<closed>2019-12-12 10:21:12</closed>
	</bug>
	<bug>
		<id>950</id>
		<title>模板填充影响到了后面的数据样式</title>
		<body>**触发场景描述** 使用模板填充 pom依赖 ```xml &lt;dependency&gt;             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;             &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;             &lt;version&gt;2.1.4&lt;/version&gt;         &lt;/dependency&gt; ``` 模板 https://www.lanzous.com/i7vdtlg   **触发Bug的代码** ```java    public class Test {     public static void main(String[] args) throws IOException {         File excel = new File("test.xlsx");           InputStream inputStream = new DefaultResourceLoader().getResource("classpath:/apply/template.xlsx").getInputStream();         ExcelWriter excelWriter = EasyExcel.write(excel).withTemplate(inputStream).build();         WriteSheet writeSheet = EasyExcel.writerSheet().build();         writeSheet.setSheetName("aaa");         FillConfig fillConfig = FillConfig.builder().forceNewRow(Boolean.TRUE).build();         excelWriter.fill(data(), fillConfig, writeSheet);         Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();         map.put("name", "固定值");         map.put("name2", "名字2");         excelWriter.fill(map, writeSheet);         excelWriter.finish();      }      public static List&lt;PowerAttorneyDetail&gt; data() {         List&lt;PowerAttorneyDetail&gt; datas = new LinkedList&lt;&gt;();         for (int i = 0; i &lt; 3; i++) {             PowerAttorneyDetail data = new PowerAttorneyDetail();             data.setLineId(i + 1);             data.setRegion("重庆" + i);             data.setCompanyName("重庆宜迅联" + i);             data.setTaxNoUpdateAfter("02312313");             data.setTaxAuthorityCode("123");             data.setTaxAuthorityName("北京税务局");             data.setUserIdUpdateAfter("222");             data.setContainerNum("123");             data.setValidityPeriod("10年");             data.setServerId("ASE");             datas.add(data);         }         return datas;     } } @Data public class PowerAttorneyDetail {     private Integer lineId;     private String region;     private String companyName;     private String taxNoUpdateBefore;     private String taxNoUpdateAfter;     private String taxAuthorityCode;     private String taxAuthorityName;     private String userIdUpdateBefore;     private String userIdUpdateAfter;     private String serverId;     private String containerNum;      private String validityPeriod; } ``` **提示的异常或者没有达到的效果** 模板 ![image](https://user-images.githubusercontent.com/11626016/70293583-adf63980-181b-11ea-83e0-3a137b8b23e7.png) 异常的效果（填充一行数据是没问题的，多行会出现问题） ![image](https://user-images.githubusercontent.com/11626016/70293823-7d62cf80-181c-11ea-994c-faaebe89fc66.png)  </body>
		<created>2019-12-06 03:36:47</created>
		<closed>2019-12-12 10:26:03</closed>
	</bug>
	<bug>
		<id>943</id>
		<title>读取excel数字类型的字段精度损失 </title>
		<body>**触发场景描述** 读取带有数字类型的excel **触发Bug的代码** ![image](https://user-images.githubusercontent.com/29010438/70196163-cfcfbd80-1742-11ea-9c36-ea8b1511cca3.png)  **提示的异常或者没有达到的效果** ![image](https://user-images.githubusercontent.com/29010438/70196195-ed9d2280-1742-11ea-9400-6eb40de30aa9.png) </body>
		<created>2019-12-05 01:38:07</created>
		<closed>2019-12-12 10:28:18</closed>
	</bug>
	<bug>
		<id>941</id>
		<title>在读取Excel文本数据，例如20800.0，会让com.alibaba.excel.util.NumberUtils这个工具类处理，结果报错解析异常</title>
		<body>**触发场景描述** 1、依赖版本        &lt;dependency&gt;             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;             &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;             &lt;version&gt;2.1.4&lt;/version&gt;         &lt;/dependency&gt; ps：2.1.3版本也试过，一样的情况，目前2.1.3 2、Excel有24个字段，表格全部都为文本类型，6、7、8、9列数据为20800.0带小数点文本 3、继承com.alibaba.excel.event.AnalysisEventListener的监听对象，重写了 invoke()方法  4、按照文档代码解析对象到List集合，并未存数据库 **触发Bug的代码** ```java --------------------------------------------------分割线-------------------------------------------------    package com.tedu.sois.common.listener;  import com.alibaba.excel.context.AnalysisContext; import com.alibaba.excel.event.AnalysisEventListener; import com.alibaba.fastjson.JSON; import com.tedu.sois.sys.entity.DemoData; import com.tedu.sois.sys.entity.SysStuCrmManageTemporary; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  import java.util.ArrayList; import java.util.List; /** 测试监听对象 */ public class DemoListener extends AnalysisEventListener&lt;SysStuCrmManageTemporary&gt; {     private static final Logger LOGGER = LoggerFactory.getLogger(DemoListener.class);      /**      * 每隔3000条存储数据库，然后清理list ，方便内存回收      */ //    private static final int BATCH_COUNT = 1000;      List&lt;DemoData&gt; list = new ArrayList&lt;&gt;();      @Override     public void invoke(SysStuCrmManageTemporary sysStuCrmManageTemporary, AnalysisContext analysisContext) {         if(!("正式学员".equals(sysStuCrmManageTemporary.getColumn4()) ||                 "毕业学员".equals(sysStuCrmManageTemporary.getColumn4())))             return;         LOGGER.info("解析到一条数据:{}", JSON.toJSONString(sysStuCrmManageTemporary));         DemoData data = new DemoData();         data.setCost_all(sysStuCrmManageTemporary.getColumn6());         data.setCost_value(sysStuCrmManageTemporary.getColumn9());         list.add(data);     }      @Override     public void doAfterAllAnalysed(AnalysisContext analysisContext) {         LOGGER.info("所有数据解析完毕");     }  //    @Override //    public void onException(Exception exception, AnalysisContext context) { //        LOGGER.error("解析失败，但是继续解析下一行:{}", exception.getMessage()); //        // 如果是某一个单元格的转换异常 能获取到具体行号 //        // 如果要获取头的信息 配合invokeHeadMap使用 //        if (exception instanceof ExcelDataConvertException) { //            ExcelDataConvertException excelDataConvertException = (ExcelDataConvertException)exception; //            LOGGER.error("第{}行，第{}列解析异常", excelDataConvertException.getRowIndex(), //                    excelDataConvertException.getColumnIndex()); //        } //    }      public List&lt;DemoData&gt; getList(){         return list;     } } --------------------------------------------------分割线------------------------------------------------- package com.tedu.sois.sys.entity;  import lombok.Data; import lombok.ToString;  import java.io.Serializable;  /**  * 临时表实体对象  */ @Data @ToString public class SysStuCrmManageTemporary implements Serializable {      private String column0;     private String column1;     private String column2;     private String column3;     private String column4;     private String column5;     private Double column6;     private Double column7;     private Double column8;     private Double column9;     private String column10;     private String column11;     private String column12;     private String column13;     private String column14;     private String column15;     private String column16;     private String column17;     private String column18;     private String column19;     private String column20;     private String column21;     private String column22; } --------------------------------------------------分割线------------------------------------------------- package com.tedu.sois.sys.entity;  import com.alibaba.excel.annotation.ExcelProperty; import com.alibaba.excel.annotation.format.NumberFormat; import lombok.Data; import lombok.ToString;  import java.io.Serializable;  @Data @ToString public class DemoData implements Serializable {     @NumberFormat("#.#")     @ExcelProperty(value = "学费总值",index = 6)     private Double cost_value;      @NumberFormat("#.#")     @ExcelProperty(value = "累计缴费",index = 9)     private Double cost_all; }  ``` **提示的异常或者没有达到的效果** com.alibaba.excel.exception.ExcelAnalysisException: Convert data 20800.0 to class java.lang.Integer error   at com.alibaba.excel.read.metadata.holder.AbstractReadHolder.notifyEndOneRow(AbstractReadHolder.java:151) at com.alibaba.excel.analysis.v03.XlsSaxAnalyser.endRow(XlsSaxAnalyser.java:193) at com.alibaba.excel.analysis.v03.XlsSaxAnalyser.processLastCellOfRow(XlsSaxAnalyser.java:183) at com.alibaba.excel.analysis.v03.XlsSaxAnalyser.processRecord(XlsSaxAnalyser.java:172) at org.apache.poi.hssf.eventusermodel.MissingRecordAwareHSSFListener.processRecord(MissingRecordAwareHSSFListener.java:158) at org.apache.poi.hssf.eventusermodel.FormatTrackingHSSFListener.processRecord(FormatTrackingHSSFListener.java:92) at org.apache.poi.hssf.eventusermodel.HSSFRequest.processRecord(HSSFRequest.java:109) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.genericProcessEvents(HSSFEventFactory.java:179) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.processEvents(HSSFEventFactory.java:136) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.processWorkbookEvents(HSSFEventFactory.java:82) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.processWorkbookEvents(HSSFEventFactory.java:54) at com.alibaba.excel.analysis.v03.XlsSaxAnalyser.execute(XlsSaxAnalyser.java:112) at com.alibaba.excel.analysis.ExcelAnalyserImpl.analysis(ExcelAnalyserImpl.java:105) at com.alibaba.excel.ExcelReader.read(ExcelReader.java:180) at com.alibaba.excel.ExcelReader.read(ExcelReader.java:170) at com.alibaba.excel.read.builder.ExcelReaderSheetBuilder.doRead(ExcelReaderSheetBuilder.java:160) at com.tedu.sois.service.SysStuCrmManageServiceTestCase.reader(SysStuCrmManageServiceTestCase.java:33) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74) at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84) at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: com.alibaba.excel.exception.ExcelDataConvertException: Convert data 20800.0 to class java.lang.Integer error  at com.alibaba.excel.util.ConverterUtils.doConvertToJavaObject(ConverterUtils.java:135) at com.alibaba.excel.util.ConverterUtils.convertToJavaObject(ConverterUtils.java:103) at com.alibaba.excel.read.listener.ModelBuildEventListener.buildUserModel(ModelBuildEventListener.java:113) at com.alibaba.excel.read.listener.ModelBuildEventListener.invoke(ModelBuildEventListener.java:38) at com.alibaba.excel.read.listener.ModelBuildEventListener.invoke(ModelBuildEventListener.java:28) at com.alibaba.excel.read.metadata.holder.AbstractReadHolder.notifyEndOneRow(AbstractReadHolder.java:145) ... 46 more Caused by: java.lang.NumberFormatException: For input string: "20800.0" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Integer.parseInt(Integer.java:580) at java.lang.Integer.valueOf(Integer.java:766) at com.alibaba.excel.util.NumberUtils.parseInteger(NumberUtils.java:90) at com.alibaba.excel.converters.integer.IntegerStringConverter.convertToJavaData(IntegerStringConverter.java:32) at com.alibaba.excel.converters.integer.IntegerStringConverter.convertToJavaData(IntegerStringConverter.java:17) at com.alibaba.excel.util.ConverterUtils.doConvertToJavaObject(ConverterUtils.java:133) ... 51 more  </body>
		<created>2019-12-04 17:44:28</created>
		<closed>2019-12-16 08:21:02</closed>
	</bug>
	<bug>
		<id>935</id>
		<title>字段有值, 但是输出数据为空</title>
		<body>**触发场景描述**     **触发Bug的代码**  ```  &lt;dependency&gt;             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;             &lt;artifactId&gt;fastjson&lt;/artifactId&gt;             &lt;version&gt;1.2.7&lt;/version&gt;         &lt;/dependency&gt;          &lt;dependency&gt;             &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;             &lt;artifactId&gt;lombok&lt;/artifactId&gt;             &lt;version&gt;1.16.18&lt;/version&gt;         &lt;/dependency&gt;          &lt;dependency&gt;             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;             &lt;artifactId&gt;easyexcel&lt;/artifactId&gt;             &lt;version&gt;2.0.1&lt;/version&gt;         &lt;/dependency&gt; ``` ```java   @Test     public void test111() throws IOException {         String sss = "[{\"cActualMoney\":24,\"cShouldMoney\":24,\"category\":\"美妆个护/基础护肤/面膜\",\"childOrderId\":\"649035547506900992\",\"costPrice\":11.1,\"createTime\":1574783733000,\"gSinglePrice\":0,\"gTotalMoney\":0,\"orderId\":\"649035735168\",\"orderStatus\":\"待收货\",\"payWay\":\"支付宝\",\"postFee\":24,\"sendTime\":1574835662000,\"skuId\":\"100\",\"skuNum\":2,\"speci1\":\"5片/盒\",\"spid\":1,\"supplierName\":\"自营仓\",\"taxFee\":0,\"title\":\"保湿面膜5片/盒 修复屏障舒缓补水\"},{\"cActualMoney\":12,\"cShouldMoney\":12,\"category\":\"美氛/眼部彩妆\",\"childOrderId\":\"648675234324414464\",\"costPrice\":9.6,\"createTime\":1574697828000,\"gSinglePrice\":0,\"gTotalMoney\":0,\"orderId\":\"648675234303442944\",\"orderStatus\":\"待收货\",\"payWay\":\"微信\",\"postFee\":12,\"sendTime\":1574767548000,\"skuId\":\"10101\",\"skuNum\":1,\"speci1\":\"黑色\",\"spid\":200,\"supplierName\":\"石狮市有限公司\",\"taxFee\":0,\"title\":\"线笔 0.6ml*1支 不脱色持久不晕染 \"}]";         List&lt;ExcelOrderCommonVO&gt; objects = JSON.parseArray(sss, ExcelOrderCommonVO.class);         EasyExcel.write(new FileOutputStream(new File("D:/xxx.xlsx")), ExcelOrderCommonVO.class)                 .needHead(true)                 .sheet(0)                 .doWrite(objects);     }   ```  ``` import com.alibaba.excel.annotation.ExcelProperty; import lombok.Data;  import java.math.BigDecimal; import java.util.Date;  /**  * 普通商品  *  * @author shuai-ys  * @date 2019/11/26  */ @Data public class ExcelOrderCommonVO {      @ExcelProperty(value = "父订单号", index = 0)     private String orderId;      @ExcelProperty(value = "子订单号", index = 1)     private String childOrderId;      @ExcelProperty(value = "下单时间", index = 2)     private Date createTime;      @ExcelProperty(value = "发货时间", index = 3)     private Date sendTime;      @ExcelProperty(value = "退货时间", index = 4)     private Date backTime;      @ExcelProperty(value = "供应商id", index = 5)     private Integer spid;      @ExcelProperty(value = "供应商名字", index = 6)     private String supplierName;      @ExcelProperty(value = "SkuId", index = 7)     private String skuId;      @ExcelProperty(value = "商品名称", index = 8)     private String title;      @ExcelProperty(value = "副标题", index = 9)     private String subtitle;      @ExcelProperty(value = "规格1", index = 10)     private String speci1;      @ExcelProperty(value = "规格2", index = 11)     private String speci2;      @ExcelProperty(value = "分类", index = 12)     private String category;      @ExcelProperty(value = "购买数量", index = 13)     private Integer skuNum;      @ExcelProperty(value = "退货数量", index = 14)     private Integer returnNum;      @ExcelProperty(value = "成本价", index = 15)     private BigDecimal costPrice;      @ExcelProperty(value = "商品单价", index = 16)     private BigDecimal gSinglePrice;      @ExcelProperty(value = "总售价(商品单价*数量)", index = 17)     private BigDecimal gTotalMoney;      @ExcelProperty(value = "(分摊)应付金额", index = 18)     private BigDecimal cShouldMoney;      @ExcelProperty(value = "(分摊)实付金额", index = 19)     private BigDecimal cActualMoney;      @ExcelProperty(value = "(分摊)优惠金额", index = 20)     private BigDecimal cCouponMoney;      @ExcelProperty(value = "(分摊)总返利", index = 21)     private BigDecimal orderCommission;      @ExcelProperty(value = "订单状态", index = 22)     private String orderStatus;      @ExcelProperty(value = "支付方式", index = 23)     private String payWay;      @ExcelProperty(value = "完成时间", index = 24)     private Date confirmTime;      @ExcelProperty(value = "邮费", index = 25)     private BigDecimal postFee;      @ExcelProperty(value = "税费", index = 26)     private BigDecimal taxFee;  }  ```    输出结果 ![image](https://user-images.githubusercontent.com/13514547/70044110-a73dab80-15fc-11ea-994c-e4921b7becdb.png) </body>
		<created>2019-12-03 10:43:28</created>
		<closed>2019-12-12 10:31:42</closed>
	</bug>
	<bug>
		<id>933</id>
		<title>多次横向填充 前者的填充会影响后者</title>
		<body>**触发场景描述** [接这个issue的问题](https://github.com/alibaba/easyexcel/issues/800#issuecomment-561043430) 我将上下填充的模板改成横向写的模板 但是出现了如题的问题 **触发Bug的代码** ```java    @Override     public ResponseEntity&lt;Resource&gt; exportHorizonComplex(String fileName, String sheetName) throws IOException {         //填充文件         // 模板注意 用{} 来表示你要用的变量 如果本来就有"{","}" 特殊字符 用"\{","\}"代替         // {} 代表普通变量 {.} 代表是list的变量         String templateFileName = "complexTemplate2.xlsx";         fileName = fileName+".xlsx";         ExcelWriter excelWriter = EasyExcel.write(fileName).withTemplate(templateFileName).build();         WriteSheet writeSheet = EasyExcel.writerSheet().build();         writeSheet.setSheetName(sheetName);          //横向写         FillConfig fillConfig = FillConfig.builder().direction(WriteDirectionEnum.HORIZONTAL).build();         excelWriter.fill(data1(), fillConfig, writeSheet);         excelWriter.fill(data2(),fillConfig,writeSheet);         excelWriter.fill(data3(),fillConfig,writeSheet);         excelWriter.fill(data4(),writeSheet);          // 别忘记关闭流         excelWriter.finish();          //下载文件         File dbfFile = new File(fileName);         if (!dbfFile.exists() || dbfFile.isDirectory()) {             dbfFile.createNewFile();         }         InputStreamResource resource = new InputStreamResource(new FileInputStream(dbfFile));         HttpHeaders headers = new HttpHeaders();         headers.add("Content-disposition", "attachment;filename="+ fileName);          return ResponseEntity.ok()                 .headers(headers)                 .contentLength(dbfFile.length())                 .contentType(MediaType.parseMediaType("application/octet-stream"))                 .body(resource);     }      private QinComplexObject data1(){         QinComplexObject complexObject = new QinComplexObject();         complexObject.setModelCnName("模型一");         complexObject.setModelEnName("model No.1");         complexObject.setModelNumber("HB1235879530");         complexObject.setModelStuff("小明");         complexObject.setDevStuff("小芳");         complexObject.setModelState("开发中");         complexObject.setMinspace("100MB");         complexObject.setMintime("2 days");         complexObject.setRequiretime("4 days");         complexObject.setOnlyexpression("说明一：这是一个说明");         complexObject.setMainIndex("A分区 索引一");         complexObject.setModelState("A");         complexObject.setModelLevel("A");         return complexObject;     }     private List&lt;DepenceModel&gt; data2(){         List&lt;DepenceModel&gt; depenceModels = new ArrayList&lt;&gt;();         DepenceModel depenceModel1 = new DepenceModel();         DepenceModel depenceModel2 = new DepenceModel();         DepenceModel depenceModel3 = new DepenceModel();         depenceModel1.setModelEnName("Model 1");         depenceModel1.setRelateDescription("这是一个相关描述一");         depenceModel2.setModelEnName("Model 2");         depenceModel2.setRelateDescription("这是一个相关描述二");         depenceModel3.setModelEnName("Model3");         depenceModel3.setRelateDescription("这是一个相关描述三");         depenceModels.add(depenceModel1);         depenceModels.add(depenceModel2);         depenceModels.add(depenceModel3);         return depenceModels;     }     private List&lt;Detail&gt; data3(){         List&lt;Detail&gt; details = new ArrayList&lt;&gt;();         Detail detail1 = new Detail();         detail1.setId(1);         detail1.setKeys(1003);         detail1.setCnMark("标识一");         detail1.setEnMark("mark one");         detail1.setType("NUMBER");         detail1.setLenght("1024");         detail1.setUnit("cm");         detail1.setDefaut("1024");         detail1.setAttributesExpression("属性一");         detail1.setDatasource("数据源表一");         detail1.setDatasourceText("数据源表字段一");         detail1.setAlgorithmExpression("算法描述一");         detail1.setFunction("函数一");         Detail detail2 = new Detail();         detail2.setId(2);         detail2.setKeys(1004);         detail2.setCnMark("标识二");         detail2.setEnMark("mark two");         detail2.setType("NUMBER");         detail2.setLenght("1024");         detail2.setUnit("cm");         detail2.setDefaut("1024");         detail2.setAttributesExpression("属性二");         detail2.setDatasource("数据源表二");         detail2.setDatasourceText("数据源表字段二");         detail2.setAlgorithmExpression("算法描述二");         detail2.setFunction("函数二");         details.add(detail1);         details.add(detail2);         return details;     }     private StoageDatabase data4(){         StoageDatabase stoageDatabase = new StoageDatabase();         stoageDatabase.setDatabase("MySql");         stoageDatabase.setDatabaseName("名字一");         stoageDatabase.setStorageCycle("两天");         return stoageDatabase;     } ``` **提示的异常或者没有达到的效果** ![微信截图_20191203164253](https://user-images.githubusercontent.com/22855982/70034349-fb8c5f80-15eb-11ea-8050-d25cadd231a8.png) ![微信截图_20191203163830](https://user-images.githubusercontent.com/22855982/70034375-05ae5e00-15ec-11ea-90f3-cb1a787f14d3.png)  </body>
		<created>2019-12-03 08:43:35</created>
		<closed>2020-03-17 15:04:53</closed>
	</bug>
	<bug>
		<id>932</id>
		<title>com.alibaba.excel.exception.ExcelAnalysisException: java.lang.IncompatibleClassChangeError: Found interface org.apache.poi.util.POILogger, but class was expected</title>
		<body>easyexcel最新版，poi4.1.0，读取excel报错：com.alibaba.excel.exception.ExcelAnalysisException: java.lang.IncompatibleClassChangeError: Found interface org.apache.poi.util.POILogger, but class was expected </body>
		<created>2019-12-03 01:41:26</created>
		<closed>2019-12-03 01:54:14</closed>
	</bug>
	<bug>
		<id>928</id>
		<title>xls文件导入时，字符型数字总是变成数值型，导致数据异常</title>
		<body>**触发场景描述**  **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** </body>
		<created>2019-12-02 10:33:58</created>
		<closed>2020-03-17 15:56:45</closed>
	</bug>
	<bug>
		<id>920</id>
		<title>怎样设置单元格属性为文本格式？</title>
		<body>**异常代码** ```java  怎样设置单元格属性为文本格式？ 导出的excel单元格属性 默认不是文本格式 ``` **异常提示** 请提供完整的异常提示,记住是全部异常！ **建议描述** </body>
		<created>2019-11-29 07:56:43</created>
		<closed>2020-03-17 15:57:43</closed>
	</bug>
	<bug>
		<id>917</id>
		<title>实体对象导入导出时，如果set方法返回值不为void，则无法赋值</title>
		<body>**触发场景描述** 实体对象导入导出时，如果set方法返回值不为void，则无法赋值 **触发Bug的代码** ```java    BeanMap.create(resultModel).putAll(map); ``` **提示的异常或者没有达到的效果** 跟踪是cglib的putAll方法没有将值放进去</body>
		<created>2019-11-29 06:32:57</created>
		<closed>2020-03-17 15:02:54</closed>
	</bug>
	<bug>
		<id>914</id>
		<title>子类继承父类,只能解析出父类字段</title>
		<body>**触发场景描述** 实体 EntityInfo extends BaseEntity 只能解析出BaseEntity里边的字段， EntityInfo里边的字段没有解析出来，这种怎么处理 **触发Bug的代码** ```java    -------------------------------父类----------------------------- @Data public class BaseEntity {     private String file1;     private String file2; } ----------------------------子类------------------------------ @Data @Accessors(chain = true) public class EntityInfo extends BaseEntity{     @ExcelProperty("file3名称")     private String file3;     @ExcelProperty("file4名称")     private String file4; } --------------------excel-------------------------------------  file3名称 file4名称 1111 222 333         444  ------------------------main-------------------- EasyExcel.read(fileName,EntityInfo.class, new EntityInfoDataListener()).sheet().doRead();  ``` **提示的异常或者没有达到的效果** 只能解析出 file1,file2 不能解析出file3，file4</body>
		<created>2019-11-29 04:08:00</created>
		<closed>2019-11-29 09:05:30</closed>
	</bug>
	<bug>
		<id>913</id>
		<title>使用流导出自定义头，导出的模板不是在同一行，而是在同一列</title>
		<body>**触发场景描述** 使用OutputStream导出模板，采用自定义头的形式，导出的模板在同一列，而非同一行，使用的是2.0.5版本，后来更新至最新的版本也没用 **触发Bug的代码** ```java    这里写代码 `DeviceExportDataDTO deviceExportDataDTO = remoteDeviceCommonService.loadTemplate("13162520604836 ![B11E0EE4-6BE6-4e10-A731-1B60B0F8BA97](https://user-images.githubusercontent.com/35823818/69840531-e71c3000-1296-11ea-8127-c986b3cfcd98.png) 16");             String fileName = deviceExportDataDTO.getDeviceModelIdentification() + "设备导入模板";             this.setResponseHeader(response,fileName);             OutputStream os = response.getOutputStream();             try{                 EasyExcel.write(os).head(deviceExportDataDTO.getTableTemplate()).sheet(fileName).doWrite(new LinkedList());             }catch (Exception e){                 throw new RuntimeException("文件流操作失败");             }finally {                 try{                     os.close();                 }catch (IOException e){                     throw new RuntimeException("输出流关闭失败");                 }             } **提示的异常或者没有达到的效果** </body>
		<created>2019-11-29 02:56:38</created>
		<closed>2020-03-17 15:27:19</closed>
	</bug>
	<bug>
		<id>904</id>
		<title>relativeHeadRowIndex无法指定行写入</title>
		<body>**我的代码** ```java    EasyExcel.write(file, WtgInfoExcel.class).sheet(0).needHead(false).relativeHeadRowIndex(3).doWrite(wtgInfoData()); ``` **疑问** 该处设置relativeHeadRowIndex为3，但还是从首行写 **请帮忙看下是否有问题** </body>
		<created>2019-11-27 10:24:30</created>
		<closed>2020-03-17 15:01:16</closed>
	</bug>
	<bug>
		<id>894</id>
		<title>excel 导出出现数组越界</title>
		<body>**触发场景描述** 在本地、开发环境都能够正常导出excel文件 在测试环境中使用时无法正常导出 **触发Bug的代码** ```java    response.setContentType("application/vnd.ms-excel");     response.setCharacterEncoding("utf-8");     fileName = URLEncoder.encode(fileName, "UTF-8");     response.setHeader("Content-disposition", "attachment;filename=" + fileName + ".xlsx");     EasyExcel.write(response.getOutputStream(), clazz)         .sheet("Sheet1")         .doWrite(datas); ``` **提示的异常或者没有达到的效果** [2019-11-26 16:38:37.444] [http-nio-8068-exec-5] [ERROR] [] DirectJDKLog.log:175 - Servlet.service() for servlet [dispatcherServlet] in context with path [/ed/api] threw exception [Request processing failed; nested exception is java.lang.ArrayIndexOutOfBoundsException: 0] with root cause java.lang.ArrayIndexOutOfBoundsException: 0 at sun.font.CompositeFont.getSlotFont(CompositeFont.java:340) at sun.font.CompositeGlyphMapper.initMapper(CompositeGlyphMapper.java:81) at sun.font.CompositeGlyphMapper.&lt;init&gt;(CompositeGlyphMapper.java:62) at sun.font.CompositeFont.getMapper(CompositeFont.java:398) at sun.font.CompositeFont.canDisplay(CompositeFont.java:424) at java.awt.Font.canDisplayUpTo(Font.java:2063) at java.awt.font.TextLayout.singleFont(TextLayout.java:470)</body>
		<created>2019-11-26 08:44:06</created>
		<closed>2020-03-17 15:26:31</closed>
	</bug>
	<bug>
		<id>873</id>
		<title>实体类跟表头类不是一个时会发生错列现象</title>
		<body>**触发场景描述** 实体类跟表头模板类不是同一个类时，并且2个类的属性不一一对应，导出表格会有错列现象。  **触发Bug的代码** ```java // 实体类 @Data public class Entity {  private String string;  private Date date; }  // 表头类 @Data public class Head { @ExcelProperty("字符串标题") private String string; }  // 测试类 public class Main {  public static void main(String[] args) {  Entity data = new Entity(); data.setString("测试字符串"); data.setDate(new Date());  List&lt;Entity&gt; datas = new ArrayList&lt;&gt;(); datas.add(data);  EasyExcel.write(new File("D:\\data.xlsx"), Head.class).sheet("data").doWrite(datas); }  } ``` **提示的异常或者没有达到的效果** 导出结果： 字符串标题 2019-11-21 13:57:42  期望结果： 字符串标题 测试字符串</body>
		<created>2019-11-21 06:04:01</created>
		<closed>2019-11-27 10:49:55</closed>
	</bug>
	<bug>
		<id>869</id>
		<title>2.1.3版本 写Excel 列宽自适应策略的问题</title>
		<body>**触发场景描述** 按照demo编写按照列宽自适应策略来导出数据的Excel **触发Bug的代码** ``` public class EasyExcelExportUtil {     private static Logger log = LoggerFactory.getLogger(EasyExcelExportUtil.class);     private static final String FIRE_FOX = "Firefox";      /**      * 导出Excel的接口      * @author paul      * @date 9:55 2019/10/19      * @param request HttpRequest      * @param response HttpResponse      * @param fileName 导出excel文件名      * @param list 导出的每一个sheet的名称、表头类型和表格数据      **/     public static void exportExcelFile (HttpServletRequest request, HttpServletResponse response, String fileName, List&lt;EasyExcelExportBean&gt; list) throws Exception {         EasyExcelExportUtil.exportExcelFile(request, response, fileName, list, getDefaultWriteHandlerList());     }      public static void exportExcelFile (HttpServletRequest request, HttpServletResponse response, String fileName, List&lt;EasyExcelExportBean&gt; list, List&lt;WriteHandler&gt; writeHandlerList) throws Exception {         String browser = (request.getParameter("browser") != null) ? request.getParameter("browser") : "";         fileName = FIRE_FOX.equals(browser) ? new String(fileName.getBytes(), "iso-8859-1") : URLEncoder.encode(fileName, "UTF-8");         response.setContentType("application/vnd.ms-excel");         response.setCharacterEncoding("utf-8");         response.setHeader("Content-disposition", "attachment;filename=" + fileName);         ExcelWriter excelWriter = EasyExcel.write(response.getOutputStream()).build();         try {             for (int i = 0; i &lt; list.size(); i++) {                 EasyExcelExportBean bean = list.get(i);                 ExcelWriterSheetBuilder excelWriterSheetBuilder = EasyExcel.writerSheet(i, bean.getSheetName()).head(bean.getHeadClass());                 if (null != writeHandlerList) {                     for (WriteHandler writeHandler : writeHandlerList) {                         excelWriterSheetBuilder = excelWriterSheetBuilder.registerWriteHandler(writeHandler);                     }                 }                 WriteSheet writeSheet = excelWriterSheetBuilder.build();                 excelWriter.write(bean.getDataList(), writeSheet);             }         } catch (Exception e) {             log.error(e.getMessage(), e);             throw e;         } finally {             excelWriter.finish();         }     }      /**      * 获取默认的excel导出样式（黑色边框，列宽自适应）      * @author paul      * @date 17:19 2019/11/19      * return void      **/     private static List&lt;WriteHandler&gt; getDefaultWriteHandlerList() {         List&lt;WriteHandler&gt; writeHandlerList = new ArrayList&lt;&gt;();         WriteCellStyle headWriteCellStyle = new WriteCellStyle();         headWriteCellStyle.setWrapped(false);         setBorderStyle(headWriteCellStyle);         List&lt;WriteCellStyle&gt; contentWriteCellStyleList = new ArrayList&lt;&gt;();         WriteCellStyle writeCellStyle = new WriteCellStyle();         setBorderStyle(writeCellStyle);         contentWriteCellStyleList.add(writeCellStyle);         writeHandlerList.add(new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyleList));         writeHandlerList.add(new LongestMatchColumnWidthStyleStrategy());         return writeHandlerList;     }          private static void setBorderStyle(WriteCellStyle writeCellStyle) {     writeCellStyle.setBorderTop(BorderStyle.THIN);         writeCellStyle.setBorderRight(BorderStyle.THIN);         writeCellStyle.setBorderBottom(BorderStyle.THIN);         writeCellStyle.setBorderLeft(BorderStyle.THIN);         writeCellStyle.setTopBorderColor(IndexedColors.BLACK.getIndex());         writeCellStyle.setRightBorderColor(IndexedColors.BLACK.getIndex());         writeCellStyle.setBottomBorderColor(IndexedColors.BLACK.getIndex());         writeCellStyle.setLeftBorderColor(IndexedColors.BLACK.getIndex());     } } ``` **提示的异常或者没有达到的效果** 第一次导出结果是正常列宽自适应的，而从第二次导出同一个excel开始，导出的Excel列宽，全部都是默认的宽度，而不再是自适应的宽度。 个人追寻列宽自适应策源源码，猜测原因如下： ``` public class LongestMatchColumnWidthStyleStrategy extends AbstractColumnWidthStyleStrategy {     private static final int MAX_COLUMN_WIDTH = 255;     private static final Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; CACHE = new HashMap(8);      public LongestMatchColumnWidthStyleStrategy() {     }      protected void setColumnWidth(WriteSheetHolder writeSheetHolder, List&lt;CellData&gt; cellDataList, Cell cell, Head head, Integer relativeRowIndex, Boolean isHead) {         boolean needSetWidth = isHead || !CollectionUtils.isEmpty(cellDataList);         if (needSetWidth) {             Map&lt;Integer, Integer&gt; maxColumnWidthMap = (Map)CACHE.get(writeSheetHolder.getSheetNo());             if (maxColumnWidthMap == null) {                 maxColumnWidthMap = new HashMap(16);                 CACHE.put(writeSheetHolder.getSheetNo(), maxColumnWidthMap);             }              Integer columnWidth = this.dataLength(cellDataList, cell, isHead);             if (columnWidth &gt;= 0) {                 if (columnWidth &gt; 255) {                     columnWidth = 255;                 }                  Integer maxColumnWidth = (Integer)((Map)maxColumnWidthMap).get(cell.getColumnIndex());                 if (maxColumnWidth == null || columnWidth &gt; maxColumnWidth) {                     ((Map)maxColumnWidthMap).put(cell.getColumnIndex(), columnWidth);                     writeSheetHolder.getSheet().setColumnWidth(cell.getColumnIndex(), columnWidth * 256);                 }              }         }     }      private Integer dataLength(List&lt;CellData&gt; cellDataList, Cell cell, Boolean isHead) {         if (isHead) {             return cell.getStringCellValue().getBytes().length;         } else {             CellData cellData = (CellData)cellDataList.get(0);             CellDataTypeEnum type = cellData.getType();             if (type == null) {                 return -1;             } else {                 switch(type) {                 case STRING:                     return cellData.getStringValue().getBytes().length;                 case BOOLEAN:                     return cellData.getBooleanValue().toString().getBytes().length;                 case NUMBER:                     return cellData.getNumberValue().toString().getBytes().length;                 default:                     return -1;                 }             }         }     } } ``` 如图，官方提供的自适应列宽策略当中，用了static的Map来存储计算出来的每个sheet每列的最大宽度，导致第一次我new出这个策略，并执行完导出excel之后，虽然new出的实体被销毁，但是这个Map仍然保存在内存中，而第二次再执行同一个（或者其他）excel导出时，列宽永远只会小于或等于已经在CACHE当中存储的每列最大列宽，因此，自适应列宽策略中的最后一个if判断永远是false，导致我从第二次开始得到的都是默认列宽的excel，请告知，这是否是一个issue，或者是我使用策略的方式有误？感谢您的时间。 </body>
		<created>2019-11-20 10:01:00</created>
		<closed>2020-04-22 11:38:04</closed>
	</bug>
	<bug>
		<id>867</id>
		<title>通过指定excel模板写入时，如果模板的格式是xls后缀，会提示：Create workbook failure</title>
		<body>**触发场景描述** 通过指定excel模板写入数据 **触发Bug的代码** ```java    `String templateFileName = "F:\\Test\\1.xlsx";         String fileName = "F:\\Test\\根据模板写入.xls";         // 这里 需要指定写用哪个class去读，然后写到第一个sheet，名字为模板 然后文件流会自动关闭         EasyExcel.write(fileName, IndexData.class).needHead(Boolean.FALSE).withTemplate(templateFileName).sheet().doWrite(IndexData.data());` ``` **提示的异常或者没有达到的效果** 会提示 com.alibaba.excel.exception.ExcelGenerateException:Create workboook failure 。。。。。。。 The supplied data appears to be in the OLE2 Format....</body>
		<created>2019-11-20 09:01:47</created>
		<closed>2019-11-27 10:52:35</closed>
	</bug>
	<bug>
		<id>855</id>
		<title>填充Excel时 设置边框样式有问题 </title>
		<body>填充Excel时 设置写出Excel的样式没法设置  实现CellWriteHandler和RowWriteHandler均无法实现  只能设置行高   边框设置无法实现 1.实现RowWriteHandler 任何方法没法实现增加边框 2.使用CellWriteHandler afterCellDispose方法能实现增加部分数据边框 不知道什么原因 出来的文件有问题 </body>
		<created>2019-11-16 13:55:20</created>
		<closed>2019-11-27 11:20:56</closed>
	</bug>
	<bug>
		<id>852</id>
		<title>导出$jacocoData</title>
		<body>在使用jacoco的测试环境进行excel导出，会自动多出表头为$jacocoData的一列 </body>
		<created>2019-11-15 12:57:08</created>
		<closed>2019-11-17 03:57:27</closed>
	</bug>
	<bug>
		<id>846</id>
		<title>实体类字段第一个字母小写第二个字母大写，取不到值，如pDate</title>
		<body>**触发场景描述** 经测试，属性字段名称，大写字母前必须有2位以上的小写字母，不然实体字段的值一直为null **触发Bug的代码** ```java     @ExcelProperty(value = "航班日期", index = 0)     @DateTimeFormat(pattern = "yyyy-MM-dd")    private Date pDate; ``` **提示的异常或者没有达到的效果** pDate的值永远为null</body>
		<created>2019-11-15 05:47:57</created>
		<closed>2019-11-15 08:04:15</closed>
	</bug>
	<bug>
		<id>839</id>
		<title>写数据时写入指定sheet后其他sheet丢失</title>
		<body>**触发场景描述** 　写数据时写入指定sheet后其他sheet丢失 &lt;br/&gt; **触发Bug的代码** ```java         ExcelWriter writer = EasyExcel.write(inFileName).build();         WriteSheet sheet = EasyExcel.writerSheet(8, "sheet9").head(Relation.class).build();         writer.write(relationList, sheet);         writer.finish(); ``` **提示的异常或者没有达到的效果** &lt;br/&gt; 　Excel中共有10个sheet，我只向第9个sheet中写入数据后，其他9个sheet数据丢失。   ___ 　写入前 ![10](https://user-images.githubusercontent.com/45744410/68822371-b8fdf400-06cb-11ea-883c-4c7131254864.png) ___ 　写入后 ![20](https://user-images.githubusercontent.com/45744410/68822378-bbf8e480-06cb-11ea-9b70-e6e808200e2c.png)  </body>
		<created>2019-11-14 02:45:12</created>
		<closed>2019-11-14 08:57:51</closed>
	</bug>
	<bug>
		<id>836</id>
		<title>读Excel时, Model使用了lombok.experimental.Accessors注解会导致读不到值</title>
		<body>**触发场景描述** 在com.alibaba.easyexcel.test.demo.read.ReadTest#simpleRead方法中将DemoData类加上@Accessors(chain = true)注解，其他不变，会导致读取到的对象中值为null ![image](https://user-images.githubusercontent.com/24428913/68746785-4857c880-0634-11ea-9464-ae250ba3c4f0.png) ![image](https://user-images.githubusercontent.com/24428913/68747072-c74d0100-0634-11ea-9e1b-67f7ebdc1091.png) </body>
		<created>2019-11-13 08:44:41</created>
		<closed>2019-11-13 11:44:51</closed>
	</bug>
	<bug>
		<id>834</id>
		<title>写入数据时插入列为从1递增的序号时，未写入数据</title>
		<body>**触发场景描述** 　向Excel中写入数据时插入列为从1递增的序号时，未写入数据。   　其他列可正常插入数据。  **触发Bug的代码** ```java     public static &lt;T&gt; void writeData(Integer sheetNum, String sheetName, List&lt;T&gt; data, Class&lt;T&gt; tClass){         ExcelWriter writer = EasyExcel.write(outFileName, tClass).build();         WriteSheet sheet = EasyExcel.writerSheet(sheetNum, sheetName).build();         writer.write(data, sheet);         writer.finish();     } ``` **提示的异常或者没有达到的效果** &lt;br/&gt; ***断点到上述代码第一行时，data中的数据*** ![1](https://user-images.githubusercontent.com/45744410/68725540-b206b100-05f9-11ea-9a1b-45895d2663bf.png) &lt;br/&gt; ***tClass中No*** ![4](https://user-images.githubusercontent.com/45744410/68725603-e0848c00-05f9-11ea-9fe1-c1fc3cd9d8b9.png) &lt;br/&gt; ***生成 Excel中数据*** ![3](https://user-images.githubusercontent.com/45744410/68725610-e7130380-05f9-11ea-86aa-6670595fb575.png) </body>
		<created>2019-11-13 01:45:42</created>
		<closed>2019-11-13 07:01:37</closed>
	</bug>
	<bug>
		<id>824</id>
		<title>报错 java.lang.NoSuchFieldError: RAW_XML_FILE_HEADER</title>
		<body>**触发场景描述** **springboot 2.1.0.RELEASE 版本 集成时，运行测试类读取excel文件异常。**  **触发Bug的代码**  ``` @Test public void readExcel() {         String fileName = "D:/smsTemplate.xls";         // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭         EasyExcel.read(fileName, TemplateData.class, new TemplateDataListener()).sheet().doRead(); } ```  **提示的异常或者没有达到的效果** ``` Caused by: java.lang.NoSuchFieldError: RAW_XML_FILE_HEADER at org.apache.poi.poifs.filesystem.FileMagic.&lt;clinit&gt;(FileMagic.java:42) at com.alibaba.excel.support.ExcelTypeEnum.valueOf(ExcelTypeEnum.java:38) at com.alibaba.excel.read.metadata.holder.ReadWorkbookHolder.&lt;init&gt;(ReadWorkbookHolder.java:147) at com.alibaba.excel.context.AnalysisContextImpl.&lt;init&gt;(AnalysisContextImpl.java:45) at com.alibaba.excel.analysis.ExcelAnalyserImpl.&lt;init&gt;(ExcelAnalyserImpl.java:44) ... 54 more ```   </body>
		<created>2019-11-11 06:06:22</created>
		<closed>2019-11-11 08:43:44</closed>
	</bug>
	<bug>
		<id>813</id>
		<title>在tmp文件夹中创建的poifiles会有权限问题</title>
		<body>**触发场景描述** 在一台服务器不同用户下部署相同的应用 **触发Bug的代码** public static void createPOIFilesDirectory() {          String tmpDir = System.getProperty(JAVA_IO_TMPDIR);         if (tmpDir == null) {             throw new RuntimeException(                 "Systems temporary directory not defined - set the -D" + JAVA_IO_TMPDIR + " jvm property!");         }         File directory = new File(tmpDir, POIFILES);         if (!directory.exists()) {             syncCreatePOIFilesDirectory(directory);         }      } **提示的异常或者没有达到的效果** 在linux下，打个比方在dev执行导出，会在tmp下创建poifiles文件夹，创建用户是dev，同时在test下执行导出，test用户没有poifiles文件夹权限导致io异常，报无权限，导致导出失败</body>
		<created>2019-11-07 07:44:42</created>
		<closed>2019-11-14 11:34:59</closed>
	</bug>
	<bug>
		<id>812</id>
		<title>Writing excel boolean field issue </title>
		<body>**I can not write the boolean field to the excel cell. Field is always empty**  **触发Bug的代码** ```java @ExcelProperty(converter = BooleanNumberConverter.class)   private Boolean isActive ; ```  **I change poi version from 3.17 to 4.1.1  because I got the exception when I implement the library spring boot project ( exception was Class Not found org.apache.poi.ss.usermodel.IndexedColors) **提示的异常或者没有达到的效果** </body>
		<created>2019-11-07 07:28:45</created>
		<closed>2020-03-17 12:22:28</closed>
	</bug>
	<bug>
		<id>808</id>
		<title>下拉框中文本长度超过255，导致生成的Excel文件不能正常打开，提示”部分内容有问题“</title>
		<body>**触发场景描述** 下拉框数据，String[]中包含的所有文本长度超过255 **触发Bug的代码** ```java /** * SheetWriteHandler的实现类 */ public class TemplateSheetWriteHandler implements SheetWriteHandler {  /** * 下拉框选项1 */ private String[] theFirst;  // 构造函数 public TemplateSheetWriteHandler(String[] theFirst,String[] theSecond) {         // 异常数据         this.theFirst = new String[]{"1:测试01","2:测试02","14:大众","15:123","16:测试33","17:cs","18:车系12","19:测试12","20:shell","21:1","22:2113","23:22222","24:4","25:测试11","26:kw-series","27:kw-series","28:yugu","29:ceshi","30:车系车","31:车系车型","32:3333444","33:yugu","34:车系","35:极光","36:相同车系141","37:HH","38:JJ","39:LL","40:114新增车系","41:114新增车系2edit4","42:444444","43:55555"};         // 正常数据         // this.theFirst = new String[]{"1:测试01","15:123","17:cs","20:shell","23:22222","24:4","26:kw-series","27:kw-series","28:yugu","32:3333444","33:yugu","34:车系","35:极光","36:相同车系141","37:HH","40:114新增车系","41:114新增车系2edit4","42:444444","43:55555"}; }  @Override public void beforeSheetCreate(WriteWorkbookHolder writeWorkbookHolder, WriteSheetHolder writeSheetHolder) {  }  @Override public void afterSheetCreate(WriteWorkbookHolder writeWorkbookHolder, WriteSheetHolder writeSheetHolder) {     LOGGER.info("第{}个Sheet写入成功。", writeSheetHolder.getSheetNo());     // 区间设置 第一列第一行和第二行的数据。由于第一行是头，所以第一、二行的数据实际上是第二三行     DataValidationHelper helper = writeSheetHolder.getSheet().getDataValidationHelper();     // theFirst     if (ArrayUtils.isNotEmpty(theFirst)) {     CellRangeAddressList cellRangeAddressList = new CellRangeAddressList(1, 1000, 0, 0);     DataValidationConstraint constraint = helper.createExplicitListConstraint(theFirst);     DataValidation dataValidation = helper.createValidation(constraint, cellRangeAddressList);     writeSheetHolder.getSheet().addValidationData(dataValidation);     } }  } ``` **提示的异常或者没有达到的效果** 文件打开提示”部分内容有问题“ ![image](https://user-images.githubusercontent.com/16682039/68361689-c7925b80-015f-11ea-8cc7-f9de4a1820d9.png) </body>
		<created>2019-11-07 05:15:19</created>
		<closed>2019-11-07 10:38:56</closed>
	</bug>
	<bug>
		<id>806</id>
		<title>excel写的时候，如果没有设置表头，会出现一个空指针异常</title>
		<body>**触发场景描述**  不设置表头 **触发Bug的代码** ```AbstractHeadColumnWidthStyleStrategy类中的setColumnWidth方法 当不设置表头时，这里的boolean needSetWidth = relativeRowIndex != null &amp;&amp; (isHead ||   relativeRowIndex == 0);判断为true会执行     Integer width = columnWidth(head);    当入参head为null时，执行AbstractWriteHolder类中的 new AbstractHeadColumnWidthStyleStrategy() {                 protected Integer columnWidth(Head head) {                     return columnWidthMap.containsKey(head.getColumnIndex()) ? (Integer)columnWidthMap.get(head.getColumnIndex()) / 256 : 20;                 } 时，会出现空指针异常。 ``` **提示的异常或者没有达到的效果** </body>
		<created>2019-11-07 03:40:43</created>
		<closed>2019-11-14 11:34:24</closed>
	</bug>
	<bug>
		<id>800</id>
		<title>多集合数据源(上下层填充)时，会出现下层标题被覆盖问题</title>
		<body>**假设我上层存在A集合数据源，A集合下方存在B集合数据源，都有各自的数据源标题头，做完数据动态填充后，下方B集合(包括标题头)应该是要随着A集合的数据情况向下移动**  **触发Bug的代码** ```java public static void exportExcel(String templateId,WriteDirectionEnum writeDirectionEnum,  HttpServletResponse response, Object... dataList ) throws ApplicationException {          ExcelWriter excelWriter = null;         try{              // 读取模板并做数据填充             InputStream inputStream = FileUtils.readTemplate(templateId);             excelWriter = EasyExcel.write(response.getOutputStream()).withTemplate(inputStream).build();             WriteSheet writeSheet = EasyExcel.writerSheet().build();             FillConfig fillConfig = FillConfig.builder().forceNewRow(Boolean.TRUE).build();             fillConfig.setDirection(writeDirectionEnum);             for (Object data: dataList) {                  if (Collection.class.isAssignableFrom(data.getClass()) || data.getClass().isArray()) {                     excelWriter.fill(data, fillConfig, writeSheet);                 } else {                     excelWriter.fill(data, writeSheet);                 }             }              // 导出 excel             FileUtils.exportExcel(templateId,  response);         } catch (Exception e) {             throw new ApplicationException("NOMA_ERROR0005", templateId);         } finally {             if (null != excelWriter) {                 excelWriter.finish();             }         }     }  使用版本：  &lt;easyexcel.version&gt;2.1.0-beta4&lt;/easyexcel.version&gt;  ``` ![image](https://user-images.githubusercontent.com/24260681/68172712-86f5df00-ffb3-11e9-83ed-b4dc4cb44ae5.png) ![image](https://user-images.githubusercontent.com/24260681/68172735-a12fbd00-ffb3-11e9-9045-fe74df08660b.png)    **实际并没有出现这种效果，B集合的数据源向下移动了,但是其标题消失了？ 验证了上层集合，下层对象，并没有出现类似的情况，这个是什么原因呢？** </body>
		<created>2019-11-05 01:59:49</created>
		<closed>2020-03-17 15:51:36</closed>
	</bug>
	<bug>
		<id>797</id>
		<title>生成Excel文件时无报错信息，打开文件提示“部分内容有问题”</title>
		<body>**触发场景描述** 参照demo中的CustomSheetWriteHandler，生成包含下拉框的Excel文件，下拉框中数据包含有符号时，生成的Excel打开报错，提示：部分内容有问题。 从数据中去掉包含有特殊符号的两条数据后，再次生成的文件可以正常打开； **触发Bug的代码** ```java    // 测试用的数据为："经济型:1 勿动","大众（测试）" ``` **提示的异常或者没有达到的效果** ![image](https://user-images.githubusercontent.com/16682039/68118754-b963f580-ff3b-11e9-8581-2fea1d0c5790.png) </body>
		<created>2019-11-04 11:55:35</created>
		<closed>2019-11-07 05:05:34</closed>
	</bug>
	<bug>
		<id>792</id>
		<title>EasyExcel(2.1.0-beta4) 当head只有一列时，数据列第一列不会写入excel</title>
		<body>**触发场景描述** 当head只有一列时，数据列第一列不会写入excel  **触发Bug的代码** ```java    public GeneralExcelWriter(String filePath, List&lt;String&gt; heads) {         if (StringUtil.isBlank(filePath)) {             throw new RuntimeException("File path is blank");         }         if (null == heads || heads.isEmpty()) {             throw new RuntimeException("File labels is blank");         }          // 临时解决 当head只有一列时，数据列第一列不会写入excel         heads.add("错误信息");         excelWriter = EasyExcel.write(filePath).head(initHeads(heads))                 .registerWriteHandler(getStrategy()).build();         writeSheet = EasyExcel.writerSheet(SHEET_NAME).build();     }      public static List&lt;List&lt;String&gt;&gt; initHeads(List&lt;String&gt; heads) {         List&lt;List&lt;String&gt;&gt; lists = new ArrayList&lt;&gt;(heads.size());          heads.forEach(e -&gt; {             List&lt;String&gt; head0 = new ArrayList&lt;&gt;(1);             head0.add(e);             lists.add(head0);         });         return lists;     } ``` **提示的异常或者没有达到的效果**  不正常效果：  物料编码 数据不存在  正常效果：  物料编码 abcd                  数据不存在</body>
		<created>2019-11-03 12:01:10</created>
		<closed>2020-03-17 12:21:22</closed>
	</bug>
	<bug>
		<id>784</id>
		<title>读取过长数字（&gt;18位）时候出现数字有误</title>
		<body>**触发场景描述** 读取 Excel 中 过长的数字有误：  例如读取：          100321572315281000 结果：           100221564646660990  **触发Bug的代码** ``` JavaBean： @ExcelProperty("ID")     private String id;   读取代码： BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(sourceExcelPath));          ExcelReader excelReader = EasyExcel.read(bufferedInputStream, BalFlowTran.class, new BalFlowTranListener()).build();         ReadSheet readSheet = EasyExcel.readSheet(0).build();         excelReader.read(readSheet);          // 这里千万别忘记关闭，读的时候会创建临时文件，到时磁盘会崩的         excelReader.finish();  ``` **提示的异常或者没有达到的效果** 读出来的数字是：           100221564646660990</body>
		<created>2019-10-31 12:28:07</created>
		<closed>2019-11-01 03:00:56</closed>
	</bug>
	<bug>
		<id>779</id>
		<title>当读取的sheet不是首个时, readSheetHolder().getTotal()获取的值有误</title>
		<body>**触发场景描述** 我有个excel，有两个sheet，第一个sheet是说明，第二个sheet才是数据，在解析这个excel时，监听器中获取的sheet的条数都变为1 **触发Bug的代码** ```java   EasyExcel.read("C:\\Users\\Administrator\\Desktop\\模拟数据.xlsx",new MyListener()).sheet(1).doRead();   public class MyListener extends AnalysisEventListener {     @Override     public void invoke(Object data, AnalysisContext context) {         // 值永远为1         Integer total = context.readSheetHolder().getTotal();     }      @Override     public void doAfterAllAnalysed(AnalysisContext context) {      } } ``` **提示的异常或者没有达到的效果** 只有把第二个sheet移到第一个sheet时，才会获取到真正的数据条目 </body>
		<created>2019-10-31 03:11:26</created>
		<closed>2019-11-04 11:07:00</closed>
	</bug>
	<bug>
		<id>772</id>
		<title>不能和原来的版本一样，直接读取指定的sheet。</title>
		<body>**触发场景描述** 比如一个excel有5个sheet，我想直接读取第二个，这时候会报空指针 **触发Bug的代码** ```java    TestListener listener = new TestListener();         //EasyExcel.read(fileName, listener).sheet(1).headRowNumber(0).doRead();         ExcelReader excelReader = EasyExcel.read(fileName).build();         ReadSheet readSheet =                 EasyExcel.readSheet(1, "Sheet1").registerReadListener(listener).build();         //List&lt;ReadSheet&gt; readSheets = excelReader.excelExecutor().sheetList();         //excelReader.read(readSheets);         excelReader.read(readSheet);         excelReader.finish(); ``` **提示的异常或者没有达到的效果** Exception in thread "main" java.lang.NullPointerException at com.alibaba.excel.analysis.v03.handlers.BofRecordHandler.processRecord(BofRecordHandler.java:78) at com.alibaba.excel.analysis.v03.XlsSaxAnalyser.processRecord(XlsSaxAnalyser.java:138) at org.apache.poi.hssf.eventusermodel.MissingRecordAwareHSSFListener.processRecord(MissingRecordAwareHSSFListener.java:203) at org.apache.poi.hssf.eventusermodel.FormatTrackingHSSFListener.processRecord(FormatTrackingHSSFListener.java:92) at org.apache.poi.hssf.eventusermodel.HSSFRequest.processRecord(HSSFRequest.java:109) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.genericProcessEvents(HSSFEventFactory.java:179) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.processEvents(HSSFEventFactory.java:136) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.processWorkbookEvents(HSSFEventFactory.java:82) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.processWorkbookEvents(HSSFEventFactory.java:54) at com.alibaba.excel.analysis.v03.XlsSaxAnalyser.execute(XlsSaxAnalyser.java:110) at com.alibaba.excel.analysis.ExcelAnalyserImpl.analysis(ExcelAnalyserImpl.java:104) at com.alibaba.excel.ExcelReader.read(ExcelReader.java:185) at com.alibaba.excel.ExcelReader.read(ExcelReader.java:174) at cn.pelerin.bfanalyze.common.EasyExcelTest.easyExcel(EasyExcelTest.java:28) at cn.pelerin.bfanalyze.common.EasyExcelTest.main(EasyExcelTest.java:16)</body>
		<created>2019-10-29 07:52:37</created>
		<closed>2019-11-04 11:12:33</closed>
	</bug>
	<bug>
		<id>770</id>
		<title>日期类型只支持Date，不支持LocalDate和LocalDateTime</title>
		<body>**触发场景描述** 在导出excel的时候   EasyExcel.write(fileName, c).sheet(sheetName).doWrite(data); **触发Bug的代码** ```java      @ApiModelProperty(value = "下次跟进时间")     @ExcelProperty("下次跟进时间")     private LocalDateTime nextFollowUpTime;  ``` **提示的异常或者没有达到的效果**  com.alibaba.excel.exception.ExcelDataConvertException: Can not find 'Converter' support class LocalDateTime.</body>
		<created>2019-10-29 03:18:32</created>
		<closed>2019-10-29 11:14:00</closed>
	</bug>
	<bug>
		<id>751</id>
		<title>afterRowDispose isHead设置错误</title>
		<body>WriteContextImpl的initHead方法,回调afterRowDispose 方法时isHead设置为FALASE ![image](https://user-images.githubusercontent.com/7498703/67456603-e70b8d80-f663-11e9-861f-db6e09636dfb.png) </body>
		<created>2019-10-24 05:41:14</created>
		<closed>2019-10-24 14:10:58</closed>
	</bug>
	<bug>
		<id>748</id>
		<title>主页demo url 404</title>
		<body>https://alibaba-easyexcel.github.io/ 里面的demo链接404了</body>
		<created>2019-10-23 18:14:23</created>
		<closed>2019-10-24 14:08:28</closed>
	</bug>
	<bug>
		<id>747</id>
		<title>excel导出空指针异常</title>
		<body>**触发场景描述** 实体类字段中的值为null时,导出会产生空指针异常,版本2.1.0-beta2 **触发Bug的代码** ```java                    WriteHandlerUtils.afterCellCreate(writeContext, cell, head, relativeRowIndex, Boolean.FALSE);                 Object value = beanMap.get(name);                 CellData cellData = converterAndSet(currentWriteHolder, excelContentProperty.getField().getType(), cell,                     value, excelContentProperty);                 WriteHandlerUtils.afterCellDispose(writeContext, cellData, cell, head, relativeRowIndex, Boolean.FALSE);                 beanMapHandledSet.add(name); ``` **提示的异常或者没有达到的效果** 空指针异常</body>
		<created>2019-10-23 11:37:02</created>
		<closed>2019-10-24 14:07:16</closed>
	</bug>
	<bug>
		<id>742</id>
		<title>2.1.0-beta1/beta2 03版指定sheet，java.lang.NullPointerException</title>
		<body>**触发场景描述** 03版指定sheetNo&gt;0,则报错 **触发Bug的代码** ```java     ExcelReaderBuilder read = EasyExcel.read(excelPath, new TestExcelListener());     ExcelReaderSheetBuilder sheet = read.sheet(1);     sheet.doRead(); ``` **提示的异常或者没有达到的效果** java.lang.NullPointerException at com.alibaba.excel.analysis.v03.handlers.BofRecordHandler.processRecord(BofRecordHandler.java:78) at com.alibaba.excel.analysis.v03.XlsSaxAnalyser.processRecord(XlsSaxAnalyser.java:138) at org.apache.poi.hssf.eventusermodel.MissingRecordAwareHSSFListener.processRecord(MissingRecordAwareHSSFListener.java:203) at org.apache.poi.hssf.eventusermodel.FormatTrackingHSSFListener.processRecord(FormatTrackingHSSFListener.java:92) at org.apache.poi.hssf.eventusermodel.HSSFRequest.processRecord(HSSFRequest.java:109) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.genericProcessEvents(HSSFEventFactory.java:179) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.processEvents(HSSFEventFactory.java:136) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.processWorkbookEvents(HSSFEventFactory.java:82) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.processWorkbookEvents(HSSFEventFactory.java:54) at com.alibaba.excel.analysis.v03.XlsSaxAnalyser.execute(XlsSaxAnalyser.java:110) at com.alibaba.excel.analysis.ExcelAnalyserImpl.analysis(ExcelAnalyserImpl.java:104) at com.alibaba.excel.ExcelReader.read(ExcelReader.java:185) at com.alibaba.excel.ExcelReader.read(ExcelReader.java:174) at com.alibaba.excel.read.builder.ExcelReaderSheetBuilder.doRead(ExcelReaderSheetBuilder.java:160)</body>
		<created>2019-10-23 09:58:02</created>
		<closed>2019-10-23 10:46:37</closed>
	</bug>
	<bug>
		<id>741</id>
		<title>2.1.0-beta2，表格填充，默认为cell.getStringCellValue()，遇到数字会报Cannot get a STRING value from a NUMERIC cell</title>
		<body>**触发场景描述** 模板表格中有数字，会报Cannot get a STRING value from a NUMERIC cell **触发Bug的代码** private List&lt;AnalysisCell&gt; readTemplateData(Map&lt;Integer, List&lt;AnalysisCell&gt;&gt; analysisCache) {         Integer sheetNo = writeContext.writeSheetHolder().getSheetNo();         List&lt;AnalysisCell&gt; analysisCellList = analysisCache.get(sheetNo);         if (analysisCellList != null) {             return analysisCellList;         }         Sheet sheet = writeContext.writeSheetHolder().getCachedSheet();         analysisCellList = new ArrayList&lt;AnalysisCell&gt;();         List&lt;AnalysisCell&gt; collectionAnalysisCellList = new ArrayList&lt;AnalysisCell&gt;();         for (int i = 0; i &lt;= sheet.getLastRowNum(); i++) {             Row row = sheet.getRow(i);             if (row == null) {                 continue;             }             for (int j = 0; j &lt; row.getLastCellNum(); j++) {                 Cell cell = row.getCell(j);                 if (cell == null) {                     continue;                 }                 boolean needFill =                     prepareData(cell.getStringCellValue(), analysisCellList, collectionAnalysisCellList, i, j);                 // Prevent empty data from not being replaced                 if (needFill) {                     cell.setCellValue(StringUtils.EMPTY);                 }             }         }         templateAnalysisCache.put(sheetNo, analysisCellList);         templateCollectionAnalysisCache.put(sheetNo, collectionAnalysisCellList);         return analysisCache.get(sheetNo);     } ```java    prepareData(cell.getStringCellValue(), analysisCellList, collectionAnalysisCellList, i, j); 这一句不能先判断Cell.getCellType,再去根据不同getStringCellValue或者getNumericCellValue去获取Cell的Value吗？ ``` **提示的异常或者没有达到的效果** java.lang.IllegalStateException: Cannot get a STRING value from a NUMERIC cell</body>
		<created>2019-10-23 09:37:07</created>
		<closed>2019-10-23 10:47:23</closed>
	</bug>
	<bug>
		<id>740</id>
		<title>exceleasy2.0，读取XLSX时，getPartsByContentType方法报异常</title>
		<body>**触发场景描述** 版本2.0.0 **触发Bug的代码** ![image](https://user-images.githubusercontent.com/10843358/67378201-7e67d680-f5b9-11e9-8e29-b57ce715c472.png)  ![image](https://user-images.githubusercontent.com/10843358/67377233-f0d7b700-f5b7-11e9-8541-f275c7426293.png)  很奇怪的问题，在本地好好的，线上就报这个错误，再导入一次就好了 ```java     ``` **提示的异常或者没有达到的效果** </body>
		<created>2019-10-23 09:21:43</created>
		<closed>2019-10-23 10:52:41</closed>
	</bug>
	<bug>
		<id>739</id>
		<title>自定义样式导致的问题</title>
		<body>**触发场景描述* 设置ShrinkToFit属性,导致导出内容中明明存在数据,但不会显示 **触发Bug的代码** ```java public class ExcelStyleUtil{      public static HorizontalCellStyleStrategy getStyle(){         // 头样式         WriteCellStyle headWriteCellStyle = new WriteCellStyle();         WriteFont headWriteFont = new WriteFont();         headWriteFont.setFontHeightInPoints((short)14);         headWriteCellStyle.setWriteFont(headWriteFont);         headWriteCellStyle.setBorderBottom(BorderStyle.MEDIUM);         headWriteCellStyle.setBorderLeft(BorderStyle.MEDIUM);         headWriteCellStyle.setBorderRight(BorderStyle.MEDIUM);         headWriteCellStyle.setBorderTop(BorderStyle.MEDIUM);         // 内容样式         WriteCellStyle contentWriteCellStyle = new WriteCellStyle();         contentWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND);         contentWriteCellStyle.setFillForegroundColor(IndexedColors.WHITE.getIndex());         contentWriteCellStyle.setBorderBottom(BorderStyle.THIN);         contentWriteCellStyle.setBorderLeft(BorderStyle.THIN);         contentWriteCellStyle.setBorderRight(BorderStyle.THIN);         contentWriteCellStyle.setBorderTop(BorderStyle.THIN);         contentWriteCellStyle.setShrinkToFit(true);         WriteFont contentWriteFont = new WriteFont();         contentWriteFont.setFontHeightInPoints((short)12);         // 这个策略是 头是头的样式 内容是内容的样式 其他的策略可以自己实现         return  new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle);     } }   //导出主要代码 EasyExcel.write(response.getOutputStream(),TbTraineequestion.class).registerWriteHandler(ExcelStyleUtil.getStyle()).sheet().doWrite(questions); ``` **提示的异常或者没有达到的效果** ![image](https://user-images.githubusercontent.com/32916396/67377120-c685f980-f5b7-11e9-9853-b474b07ada9d.png) </body>
		<created>2019-10-23 09:18:06</created>
		<closed>2019-10-23 10:53:16</closed>
	</bug>
	<bug>
		<id>735</id>
		<title>升级2.1.0-beta2后使用SimpleRowHeightStyleStrategy设置表头高度无效</title>
		<body>@Test     public void testHeight() {         SimpleRowHeightStyleStrategy rowHeightStyleStrategy = new SimpleRowHeightStyleStrategy((short)150, (short)120);         EasyExcel.write("C:\\Users\\Administrator\\Desktop\\test2.xlsx", DemoData.class).                 registerWriteHandler(rowHeightStyleStrategy)                 .sheet("测试").doWrite(data());     }  升级了2.1.0-beta2后，使用SimpleRowHeightStyleStrategy 设置表头的高度，但是并未生效，内容高度生效了   ![image](https://user-images.githubusercontent.com/7498703/67353685-bfde8e80-f585-11e9-80d2-f768c72ace9a.png) </body>
		<created>2019-10-23 03:10:46</created>
		<closed>2019-10-23 10:54:13</closed>
	</bug>
	<bug>
		<id>734</id>
		<title>LongestMatchColumnWidthStyleStrategy 单元格长度错误</title>
		<body>**触发场景描述** 单元格内容长度大于256时触发 **触发Bug的代码** ```java   private List&lt;LongestMatchColumnWidthData&gt; dataLong() {         List&lt;LongestMatchColumnWidthData&gt; list = new ArrayList&lt;LongestMatchColumnWidthData&gt;();         for (int i = 0; i &lt; 10; i++) {             LongestMatchColumnWidthData data = new LongestMatchColumnWidthData();             data.setString("测试很长的字符串测试很长的字符串测试很长的字符串测试很长的字符串测试很长的字符串测试很长的字符串测试很长的字符串测试很长的字符串测试很长的字符串测试很长的字符串测试很长的字符串测试很长的字符串测试很长的字符串测试很长的字符串测试很长的字符串" + i);             data.setDate(new Date());             data.setDoubleData(1000000000000.0);             list.add(data);         }         return list;     }  public void longestMatchColumnWidthWrite() {         String fileName =             TestFileUtil.getPath() + "longestMatchColumnWidthWrite" + System.currentTimeMillis() + ".xlsx";         // 这里 需要指定写用哪个class去读，然后写到第一个sheet，名字为模板 然后文件流会自动关闭         EasyExcel.write(fileName, LongestMatchColumnWidthData.class)             .registerWriteHandler(new LongestMatchColumnWidthStyleStrategy()).sheet("模板").doWrite(dataLong());     } ``` **提示的异常或者没有达到的效果**  java.lang.IllegalArgumentException: The maximum column width for an individual cell is 255 characters.  at org.apache.poi.xssf.usermodel.XSSFSheet.setColumnWidth(XSSFSheet.java:2527) at org.apache.poi.xssf.streaming.SXSSFSheet.setColumnWidth(SXSSFSheet.java:268) at com.alibaba.excel.write.style.column.LongestMatchColumnWidthStyleStrategy.setColumnWidth(LongestMatchColumnWidthStyleStrategy.java:47) at com.alibaba.excel.write.style.column.AbstractColumnWidthStyleStrategy.afterCellCreate(AbstractColumnWidthStyleStrategy.java:34) at com.alibaba.excel.write.ExcelBuilderImpl.afterCellCreate(ExcelBuilderImpl.java:287) at com.alibaba.excel.write.ExcelBuilderImpl.addJavaObjectToExcel(ExcelBuilderImpl.java:222) at com.alibaba.excel.write.ExcelBuilderImpl.addOneRowOfDataToExcel(ExcelBuilderImpl.java:128) at com.alibaba.excel.write.ExcelBuilderImpl.doAddContent(ExcelBuilderImpl.java:79) at com.alibaba.excel.write.ExcelBuilderImpl.addContent(ExcelBuilderImpl.java:93) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:155) at com.alibaba.excel.ExcelWriter.write(ExcelWriter.java:140) at com.alibaba.excel.write.builder.ExcelWriterSheetBuilder.doWrite(ExcelWriterSheetBuilder.java:134) at com.alibaba.easyexcel.test.demo.write.WriteTest.longestMatchColumnWidthWrite(WriteTest.java:360) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) </body>
		<created>2019-10-23 02:59:10</created>
		<closed>2019-10-23 10:55:13</closed>
	</bug>
	<bug>
		<id>730</id>
		<title>今天在使用咱们的框架后发现在简析中文的时候会带上拼音</title>
		<body>今天在使用咱们的框架后发现在简析中文的时候会带上拼音 这是简析excel中一段中文后，后面会带上拼音： 具有抗氧化性强、不易结垢、耐高温、抗高压等特点ju'youkangyang'huaxingqiangbuyijie'gounaigao'wenkanggao'yadengte'dian</body>
		<created>2019-10-22 10:49:53</created>
		<closed>2019-10-22 15:17:47</closed>
	</bug>
	<bug>
		<id>726</id>
		<title>读取文件异常</title>
		<body>**触发场景描述** 在jeesite框架中引入，读取文件报错 **触发Bug的代码**  String fileName = "C:\\Users\\13918\\Desktop\\fond_import_data.xlsx";         // 有个很重要的点 DemoDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去         // 写法1：         // 这里 需要指定读用哪个class去读，然后读取第一个sheet 文件流会自动关闭 //        EasyExcel.read(fileName, FondProductImport.class, new FondProductImportListener()).sheet().doRead();         ExcelReader excelReader = EasyExcel.read(fileName, FondProductImport.class, new FondProductImportListener()).build();         ReadSheet readSheet = EasyExcel.readSheet(0).build();         excelReader.read(readSheet);         // 这里千万别忘记关闭，读的时候会创建临时文件，到时磁盘会崩的         excelReader.finish(); ```java    这里写代码 ``` **提示的异常或者没有达到的效果**  com.alibaba.excel.exception.ExcelAnalysisException: java.lang.NoClassDefFoundError: org/openxmlformats/schemas/spreadsheetml/x2006/main/CTTableStyles  at com.alibaba.excel.analysis.ExcelAnalyserImpl.&lt;init&gt;(ExcelAnalyserImpl.java:43) at com.alibaba.excel.ExcelReader.&lt;init&gt;(ExcelReader.java:145) at com.alibaba.excel.read.builder.ExcelReaderBuilder.build(ExcelReaderBuilder.java:226) at com.senbo.product.FondProductExportTest.testImport(FondProductExportTest.java:49) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:73) at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:83) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) at org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27) at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: java.lang.NoClassDefFoundError: org/openxmlformats/schemas/spreadsheetml/x2006/main/CTTableStyles at org.openxmlformats.schemas.spreadsheetml.x2006.main.impl.CTStylesheetImpl.getTableStyles(Unknown Source) at org.apache.poi.xssf.model.StylesTable.readFrom(StylesTable.java:243) at org.apache.poi.xssf.model.StylesTable.&lt;init&gt;(StylesTable.java:141) at org.apache.poi.xssf.eventusermodel.XSSFReader.getStylesTable(XSSFReader.java:126) at com.alibaba.excel.analysis.v07.XlsxSaxAnalyser.&lt;init&gt;(XlsxSaxAnalyser.java:73) at com.alibaba.excel.analysis.ExcelAnalyserImpl.choiceExcelExecutor(ExcelAnalyserImpl.java:80) at com.alibaba.excel.analysis.ExcelAnalyserImpl.&lt;init&gt;(ExcelAnalyserImpl.java:37) ... 35 more Caused by: java.lang.ClassNotFoundException: org.openxmlformats.schemas.spreadsheetml.x2006.main.CTTableStyles at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ... 42 more </body>
		<created>2019-10-22 06:00:31</created>
		<closed>2019-10-22 15:20:41</closed>
	</bug>
	<bug>
		<id>722</id>
		<title>2.0.5 xls格式的文件获取sheet里面总行数报空指针</title>
		<body>**异常代码** ```java    这里写你的代码 ``` analysisContext.readSheetHolder().getTotal() **异常提示** 请提供完整的异常提示,记住是全部异常！ java.lang.NullPointerException at com.hzcursor.q_core.excel.ReadFileListener.invoke(ReadFileListener.java:84) at com.hzcursor.q_core.excel.ReadFileListener.invoke(ReadFileListener.java:20) at com.alibaba.excel.read.metadata.holder.AbstractReadHolder.notifyEndOneRow(AbstractReadHolder.java:141) at com.alibaba.excel.analysis.v03.XlsSaxAnalyser.endRow(XlsSaxAnalyser.java:188) at com.alibaba.excel.analysis.v03.XlsSaxAnalyser.processLastCellOfRow(XlsSaxAnalyser.java:178) at com.alibaba.excel.analysis.v03.XlsSaxAnalyser.processRecord(XlsSaxAnalyser.java:167) at org.apache.poi.hssf.eventusermodel.MissingRecordAwareHSSFListener.processRecord(MissingRecordAwareHSSFListener.java:158) at org.apache.poi.hssf.eventusermodel.FormatTrackingHSSFListener.processRecord(FormatTrackingHSSFListener.java:92) at org.apache.poi.hssf.eventusermodel.HSSFRequest.processRecord(HSSFRequest.java:109) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.genericProcessEvents(HSSFEventFactory.java:179) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.processEvents(HSSFEventFactory.java:136) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.processWorkbookEvents(HSSFEventFactory.java:82) at org.apache.poi.hssf.eventusermodel.HSSFEventFactory.processWorkbookEvents(HSSFEventFactory.java:54) at com.alibaba.excel.analysis.v03.XlsSaxAnalyser.execute(XlsSaxAnalyser.java:107) at com.alibaba.excel.analysis.ExcelAnalyserImpl.analysis(ExcelAnalyserImpl.java:91) at com.alibaba.excel.ExcelReader.read(ExcelReader.java:170) at com.hzcursor.q_core.service.impl.SmartModelRunServiceImpl.doReadFile(SmartModelRunServiceImpl.java:115) at com.hzcursor.q_core.service.impl.SmartModelRunServiceImpl.runSmartModel(SmartModelRunServiceImpl.java:91) at com.hzcursor.q_core.threadPool.IntentionRunner.run(IntentionRunner.java:43) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:748)  **建议描述** Listener 的invoke获取xls格式sheet的总行数报空指针，xlsx是正常的  </body>
		<created>2019-10-21 10:04:06</created>
		<closed>2019-10-21 13:16:30</closed>
	</bug>
	<bug>
		<id>714</id>
		<title>HorizontalCellStyleStrategy样式策略在复用时出现导出文件打不开的现象</title>
		<body>**触发场景描述** 为节省内存，把样式策略放到了spring bean 中，只新建一次。初次导出excel正常，但是第二次复用此策略导出文件报错 **触发Bug的代码** ```java     WriteTable writeTable  = EasyExcel                 .writerTable(tableId)                //这里如果new一个策略正常，如果复用一个策略，出现问题                 .registerWriteHandler(excelCommonBuilder.getEmptyLineStyleStrategy())                 .head(CraftTitle.class)                 .build();  @Component public class ExcelCommonBuilder {     //空行样式     private HorizontalCellStyleStrategy emptyLineStyleStrategy;      @PostConstruct     public void init(){         //空行样式         //内容的样式         WriteCellStyle contentWriteCellStyle = new WriteCellStyle();         //启用样式         this.emptyLineStyleStrategy = new HorizontalCellStyleStrategy(new WriteCellStyle(), contentWriteCellStyle);     }     public HorizontalCellStyleStrategy getEmptyLineStyleStrategy(){         return this.emptyLineStyleStrategy;     }  }  ``` **提示的异常或者没有达到的效果** </body>
		<created>2019-10-18 07:56:40</created>
		<closed>2019-10-19 03:59:08</closed>
	</bug>
	<bug>
		<id>704</id>
		<title>使用模板文件，新的修改会保存在模板文件内</title>
		<body>**触发场景描述** 在web项目中，读取模板，客户端下载修改后的模板文件，发现第一次使用模板后，对模板sheet的修改保存在了原模板文件中，导致再次使用该模板出错 **触发Bug的代码** ```java            String filePath = request.getSession().getServletContext().getRealPath("/framework/template/technology/制造能力测评--柜机测评完成版.xlsx");         ExcelWriter excelWriter = EasyExcel.write(response.getOutputStream()).withTemplate(filePath).build();         WriteSheet writeSheet = EasyExcel.writerSheet(3).needHead(Boolean.FALSE).build(); //合并单元格         OnceAbsoluteMergeStrategy onceAbsoluteMergeStrategy1=new OnceAbsoluteMergeStrategy(2,3,2,12);         OnceAbsoluteMergeStrategy onceAbsoluteMergeStrategy2=new OnceAbsoluteMergeStrategy(2,2,14,17);         OnceAbsoluteMergeStrategy onceAbsoluteMergeStrategy3=new OnceAbsoluteMergeStrategy(3,3,14,17);         //内容的样式         WriteCellStyle contentWriteCellStyle = new WriteCellStyle();         //字体样式         WriteFont contentWriteFont = new WriteFont();         contentWriteFont.setBold(true);         contentWriteFont.setFontName("微软雅黑");         contentWriteCellStyle.setWriteFont(contentWriteFont);         //边框         contentWriteCellStyle.setBorderBottom(BorderStyle.THIN);         contentWriteCellStyle.setBorderRight(BorderStyle.THIN);         //垂直居中         contentWriteCellStyle.setVerticalAlignment(VerticalAlignment.CENTER);         contentWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);         //启用样式         HorizontalCellStyleStrategy horizontalCellStyleStrategy = new HorizontalCellStyleStrategy(null, contentWriteCellStyle);         WriteTable writeTable1  = EasyExcel                 .writerTable(1)                 .head(TotalTitle.class)                 .registerWriteHandler(onceAbsoluteMergeStrategy1)                 .registerWriteHandler(onceAbsoluteMergeStrategy2)                 .registerWriteHandler(onceAbsoluteMergeStrategy3)                 .registerWriteHandler(horizontalCellStyleStrategy)                 .needHead(false)                 .build();         List&lt;TotalTitle&gt; data = totalTitleBuild2();         excelWriter.write(data,writeSheet, writeTable1);  ``` **提示的异常或者没有达到的效果** </body>
		<created>2019-10-17 02:39:40</created>
		<closed>2019-10-22 15:24:47</closed>
	</bug>
	<bug>
		<id>703</id>
		<title>数据导出使用CellWriteHandler拦截器设置cell内容位置时，2003版本出现位置设置失效</title>
		<body>**触发场景描述** 导出为Excel2003版本 **触发Bug的代码** ```java     ExcelWriterSheetBuilder sheet = EasyExcel.write(out, CourtFillOpenExcelDto.class)                 // 定义列拦截器  实现列自定义设置                 .registerWriteHandler(new CellWriteHandler() {                     @Override                     public void beforeCellCreate(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Row row, Head head, int i, boolean b) {                     }                      @Override                     public void afterCellCreate(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder,                                                 CellData cellData, Cell cell, Head head, int relativeRowIndex, boolean isHead) {                         if (!isHead &amp;&amp; StringUtils.equalsAnyIgnoreCase(head.getFieldName(), "amount", "totalAmount")) {                             CellStyle cellStyle = writeSheetHolder.getSheet().getWorkbook().createCellStyle();                             cellStyle.setAlignment(HorizontalAlignment.RIGHT);                             cell.setCellStyle(cellStyle);                         }                     }                 }).sheet();         sheet.doWrite(fillOpenExcelMapper.noteFillOpensToCourtFillOpenExcelDtos(noteFillOpens.getContent())); ``` **提示的异常或者没有达到的效果** 设置的列数据 从第22列开始  样式设置失效 </body>
		<created>2019-10-16 09:18:20</created>
		<closed>2019-10-17 01:49:08</closed>
	</bug>
	<bug>
		<id>695</id>
		<title>resin服务器环境下，Web导出报错 getWriter() can't be called after getOutputStream()</title>
		<body>**触发场景描述** resin服务器环境下 **触发Bug的代码** ```java List&lt;DemoData&gt; result = data(); EasyExcel.write(response.getOutputStream(), DemoData.class).sheet("sheet1").doWrite(result); ``` **提示的异常或者没有达到的效果** getWriter() can't be called after getOutputStream()</body>
		<created>2019-10-15 04:39:26</created>
		<closed>2019-10-21 12:57:57</closed>
	</bug>
	<bug>
		<id>692</id>
		<title>使用.withTemplate(templateFileName)后，文件第一行为空白</title>
		<body>**触发场景描述**  **触发Bug的代码** ```EasyExcel.write(fileName, ExportExcelData.class) .withTemplate(templateFileName) .relativeHeadRowIndex(0) .head(head()) .sheet("专利清单") .doWrite(datas); private List&lt;List&lt;String&gt;&gt; head() {         List&lt;List&lt;String&gt;&gt; headList = new ArrayList&lt;List&lt;String&gt;&gt;();                  List&lt;String&gt; index = new ArrayList&lt;String&gt;();         List&lt;String&gt; patentName = new ArrayList&lt;String&gt;();         List&lt;String&gt; inventionType = new ArrayList&lt;String&gt;();         List&lt;String&gt; departmentName = new ArrayList&lt;String&gt;();         List&lt;String&gt; inventor = new ArrayList&lt;String&gt;();         List&lt;String&gt; mainInventorName = new ArrayList&lt;String&gt;();         List&lt;String&gt; mainInventorTel = new ArrayList&lt;String&gt;();         List&lt;String&gt; mainInventorPhone = new ArrayList&lt;String&gt;();         List&lt;String&gt; mainInventorEmail = new ArrayList&lt;String&gt;();         List&lt;String&gt; technicalField = new ArrayList&lt;String&gt;();         List&lt;String&gt; standardType = new ArrayList&lt;String&gt;();         List&lt;String&gt; expeditedFlag = new ArrayList&lt;String&gt;();         List&lt;String&gt; description = new ArrayList&lt;String&gt;();         List&lt;String&gt; remark = new ArrayList&lt;String&gt;();                           index.add("动态列表"+ System.currentTimeMillis());         index.add("序号");                  patentName.add("动态列表"+ System.currentTimeMillis());         patentName.add("提交姓名");                  inventionType.add("动态列表"+ System.currentTimeMillis());         inventionType.add("申请类别");                  departmentName.add("动态列表"+ System.currentTimeMillis());         departmentName.add("上报单位");                  inventor.add("动态列表"+ System.currentTimeMillis());         inventor.add("发明人");                  mainInventorName.add("动态列表"+ System.currentTimeMillis());         mainInventorName.add("联系人");                  mainInventorTel.add("动态列表"+ System.currentTimeMillis());         mainInventorTel.add("联系电话");                  mainInventorPhone.add("动态列表"+ System.currentTimeMillis());         mainInventorPhone.add("联系手机");                  mainInventorEmail.add("动态列表"+ System.currentTimeMillis());         mainInventorEmail.add("联系邮件");                  technicalField.add("动态列表"+ System.currentTimeMillis());         technicalField.add("所属技术领域");                  standardType.add("动态列表"+ System.currentTimeMillis());         standardType.add("与标准关系");                  expeditedFlag.add("动态列表"+ System.currentTimeMillis());         expeditedFlag.add("是否加急处理");                  description.add("动态列表"+ System.currentTimeMillis());         description.add("专利简要说明");          remark.add("动态列表"+ System.currentTimeMillis());         remark.add("备注");                   headList.add(index);         headList.add(patentName);         headList.add(inventionType);         headList.add(departmentName);         headList.add(inventor);         headList.add(mainInventorName);         headList.add(mainInventorTel);         headList.add(mainInventorPhone);         headList.add(mainInventorEmail);         headList.add(technicalField);         headList.add(standardType);         headList.add(expeditedFlag);         headList.add(description);         headList.add(remark);                  return headList;     } ``` **提示的异常或者没有达到的效果** </body>
		<created>2019-10-14 07:02:04</created>
		<closed>2019-10-22 15:25:20</closed>
	</bug>
	<bug>
		<id>691</id>
		<title>导入的时候会触发io关闭错误</title>
		<body>![image](https://user-images.githubusercontent.com/30247983/66726101-ffacc400-ee69-11e9-997d-6fa72af4f08f.png) 我在读excel的时候第一次成功了，但是后续一直会抛出  Can not create temporary file!,stream is closed  我跟踪了一下代码，具体是下图抛出的 ![image](https://user-images.githubusercontent.com/30247983/66726200-75b12b00-ee6a-11e9-8a01-80aa89ec9726.png)  我不知道是我自己的写法有问题还是什么 环境：window10   版本：version: '2.0.5' </body>
		<created>2019-10-14 02:10:23</created>
		<closed>2019-10-14 05:45:17</closed>
	</bug>
	<bug>
		<id>685</id>
		<title>在android中引用该库时，报Program type already present: org.apache.xmlbeans.xml.stream.Location异常</title>
		<body>**触发场景描述** 在android中引用该库，运行代码时。 **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** </body>
		<created>2019-10-12 07:57:03</created>
		<closed>2019-10-16 11:03:20</closed>
	</bug>
	<bug>
		<id>682</id>
		<title>EasyExcel.read(filePath).sheet(sheetName) 无法根据sheet name读取</title>
		<body>EasyExcel.read(filePath).sheet(sheetName).doReadSync()</body>
		<created>2019-10-11 14:45:44</created>
		<closed>2019-10-21 12:55:38</closed>
	</bug>
	<bug>
		<id>678</id>
		<title>无法解析所有得excel内容</title>
		<body>**上传excel时发现如果内容有多个回车 只会获取最后一段数据**  ** @Data public class ExcelDemoListeners extends AnalysisEventListener {      private List&lt;Demo&gt; demos = new ArrayList&lt;&gt;();      @Override     public void invoke(Object data, AnalysisContext context) {         Map&lt;String,Object&gt; map = (Map&lt;String,Object&gt;) data; //        Demo demo = new Demo(list.get(0), list.get(1)); //        demos.add(demo);     }      @Override     public void doAfterAllAnalysed(AnalysisContext context) {      } }** ```java   @Slf4j @Component public class ExcelManager {      public String uploadExcel(MultipartFile file) throws IOException {         String filename = file.getOriginalFilename();         String suffix = filename.substring(filename.lastIndexOf("."), filename.length());         if (!(Objects.equals(suffix, ExcelTypeEnum.XLSX.getValue()) || Objects.equals(suffix, ExcelTypeEnum.XLS.getValue()))) {             log.info("传入得文件不是excel文件--{}", filename);             return null;         }         InputStream inputStream = file.getInputStream();         ExcelDemoListeners listeners = new ExcelDemoListeners();         EasyExcelFactory.read(inputStream, listeners).headRowNumber(1).sheet("Sheet1").doReadSync();         List&lt;Demo&gt; demos = listeners.getDemos();         return JSONObject.toJSONString(demos);     } } ``` ** excel 内容为：  MySQL安装         请参考MySQL环境安装     笔者安装的时候的MySQL版本是8.0.15           库表的创建 --  最后解析出来得数据 "1" -&gt; "笔者安装的时候的MySQL版本是8.0.15 库表的创建"  ** </body>
		<created>2019-10-09 08:32:51</created>
		<closed>2019-10-10 04:10:53</closed>
	</bug>
	<bug>
		<id>674</id>
		<title>ExcelProperty设置列名匹配时，读取到的值不正确</title>
		<body>**定义实体类时，如果根据列名匹配 @ExcelProperty("xxx"), 数值中的下划线会被自动转换成短横线，但是根据Index匹配则不会**  ```java    // 正确    @ExcelProperty(index = 2)     private String originalId;     // 下划线会被转换为短横线     @ExcelProperty("源ID")     private String originalId; ``` </body>
		<created>2019-10-09 01:48:10</created>
		<closed>2019-10-09 02:15:23</closed>
	</bug>
	<bug>
		<id>660</id>
		<title>com.alibaba.excel.exception.ExcelGenerateException: Can not close IO</title>
		<body>**导出excel报错**  **触发Bug的代码** public void export(List&lt;?&gt; data, String filename, String sheetName,Class&lt;?&gt; clazz) {         HttpServletResponse response = GenereateRequestAndResponseUtils.getHttpServletResponse();         response.setContentType("application/vnd.ms-excel");         response.setCharacterEncoding("utf-8");         try {             filename = URLEncoder.encode(filename, "UTF-8");             response.setHeader("Content-disposition", "attachment;filename=" + filename);         } catch (UnsupportedEncodingException e) {             log.error("处理文件名乱码出错, filename: {}", filename, e);         }         try (OutputStream out = response.getOutputStream()) {             // 这里 需要指定写用哪个class去读，然后写到第一个sheet，名字为模板 然后文件流会自动关闭             EasyExcel.write(out, clazz).registerWriteHandler(setTableStyle()).sheet(sheetName).doWrite(data);         } catch (IOException e) {             log.error("excel导出失败", e);         }     } ``` **提示的异常或者没有达到的效果** com.alibaba.excel.exception.ExcelGenerateException: Can not close IO         at com.alibaba.excel.context.WriteContextImpl.throwCanNotCloseIo(WriteContextImpl.java:390) ~[easyexcel-2.0.4.jar!/:na]         at com.alibaba.excel.context.WriteContextImpl.finish(WriteContextImpl.java:352) ~[easyexcel-2.0.4.jar!/:na]         at com.alibaba.excel.write.ExcelBuilderImpl.finish(ExcelBuilderImpl.java:106) ~[easyexcel-2.0.4.jar!/:na]         at com.alibaba.excel.ExcelWriter.finish(ExcelWriter.java:298) ~[easyexcel-2.0.4.jar!/:na]         at com.alibaba.excel.write.builder.ExcelWriterSheetBuilder.doWrite(ExcelWriterSheetBuilder.java:135) ~[easyexcel-2.0.4.jar!/:na]         at com.jing.crm2.order.service.impl.ExcelExportServiceImpl.export(ExcelExportServiceImpl.java:48) ~[classes!/:na]         at com.jing.crm2.order.service.impl.OrderExportServiceImpl.export(OrderExportServiceImpl.java:68) ~[classes!/:na]         at com.jing.crm2.order.controller.OrderExportController.exportOrder(OrderExportController.java:33) ~[classes!/:na]         at com.jing.crm2.order.controller.OrderExportController$$FastClassBySpringCGLIB$$1f70fbbd.invoke(&lt;generated&gt;) ~[classes!/:na]         at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749) ~[spring-aop-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:56) ~[spring-aop-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88) ~[spring-aop-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at com.jing.crm2.config.WebAspectLogger.doAround(WebAspectLogger.java:58) ~[classes!/:na]         at jdk.internal.reflect.GeneratedMethodAccessor229.invoke(Unknown Source) ~[na:na]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]         at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]         at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644) ~[spring-aop-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633) ~[spring-aop-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70) ~[spring-aop-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55) ~[spring-aop-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:93) ~[spring-aop-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) ~[spring-aop-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at com.jing.crm2.order.controller.OrderExportController$$EnhancerBySpringCGLIB$$641c1ec1.exportOrder(&lt;generated&gt;) ~[classes!/:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]         at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]         at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]         at java.base/java.lang.reflect.Method.invoke(Method.java:566) ~[na:na]         at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:189) ~[spring-web-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) ~[spring-webmvc-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:895) ~[spring-webmvc-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:800) ~[spring-webmvc-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1038) ~[spring-webmvc-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) ~[spring-webmvc-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897) ~[spring-webmvc-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) ~[spring-webmvc-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.16.jar!/:9.0.16]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at com.jing.crm2.config.xss.XssFilter.doFilter(XssFilter.java:23) ~[classes!/:na]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) ~[spring-web-5.1.5.RELEASE.jar!/:5.1.5.RELEASE]         at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:200) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:668) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:834) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128) ~[na:na]         at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628) ~[na:na]         at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at java.base/java.lang.Thread.run(Thread.java:834) ~[na:na]         Suppressed: org.apache.catalina.connector.ClientAbortException: java.io.IOException: Broken pipe                 at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:341) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]                 at org.apache.catalina.connector.OutputBuffer.flushByteBuffer(OutputBuffer.java:766) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]                 at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:288) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]                 at org.apache.catalina.connector.OutputBuffer.close(OutputBuffer.java:241) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]                 at org.apache.catalina.connector.CoyoteOutputStream.close(CoyoteOutputStream.java:157) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]                 at com.jing.crm2.order.service.impl.ExcelExportServiceImpl.export(ExcelExportServiceImpl.java:46) ~[classes!/:na]                 ... 69 common frames omitted         Caused by: java.io.IOException: Broken pipe                 at java.base/sun.nio.ch.FileDispatcherImpl.write0(Native Method)                 at java.base/sun.nio.ch.SocketDispatcher.write(SocketDispatcher.java:47)                 at java.base/sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:113)                 at java.base/sun.nio.ch.IOUtil.write(IOUtil.java:79)                 at java.base/sun.nio.ch.IOUtil.write(IOUtil.java:50)                 at java.base/sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:466)                 at org.apache.tomcat.util.net.NioChannel.write(NioChannel.java:134)                 at org.apache.tomcat.util.net.NioBlockingSelector.write(NioBlockingSelector.java:105)                 at org.apache.tomcat.util.net.NioSelectorPool.write(NioSelectorPool.java:144)                 at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.doWrite(NioEndpoint.java:1223)                 at org.apache.tomcat.util.net.SocketWrapperBase.doWrite(SocketWrapperBase.java:743)                 at org.apache.tomcat.util.net.SocketWrapperBase.writeBlocking(SocketWrapperBase.java:513)                 at org.apache.tomcat.util.net.SocketWrapperBase.write(SocketWrapperBase.java:451)                 at org.apache.coyote.http11.Http11OutputBuffer$SocketOutputBuffer.doWrite(Http11OutputBuffer.java:530)                 at org.apache.coyote.http11.filters.ChunkedOutputFilter.doWrite(ChunkedOutputFilter.java:110)                 at org.apache.coyote.http11.Http11OutputBuffer.doWrite(Http11OutputBuffer.java:189)                 at org.apache.coyote.Response.doWrite(Response.java:599)                 at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:329)                 ... 74 common frames omitted Caused by: org.apache.catalina.connector.ClientAbortException: java.io.IOException: Broken pipe         at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:341) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.connector.OutputBuffer.flushByteBuffer(OutputBuffer.java:766) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.connector.OutputBuffer.append(OutputBuffer.java:671) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.connector.OutputBuffer.writeBytes(OutputBuffer.java:376) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.connector.OutputBuffer.write(OutputBuffer.java:354) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.connector.CoyoteOutputStream.write(CoyoteOutputStream.java:96) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at java.base/java.util.zip.DeflaterOutputStream.deflate(DeflaterOutputStream.java:253) ~[na:na]         at java.base/java.util.zip.ZipOutputStream.closeEntry(ZipOutputStream.java:256) ~[na:na]         at java.base/java.util.zip.ZipOutputStream.finish(ZipOutputStream.java:361) ~[na:na]         at java.base/java.util.zip.DeflaterOutputStream.close(DeflaterOutputStream.java:238) ~[na:na]         at java.base/java.util.zip.ZipOutputStream.close(ZipOutputStream.java:378) ~[na:na]         at org.apache.poi.xssf.streaming.SXSSFWorkbook.injectData(SXSSFWorkbook.java:401) ~[poi-ooxml-3.17.jar!/:3.17]         at org.apache.poi.xssf.streaming.SXSSFWorkbook.write(SXSSFWorkbook.java:936) ~[poi-ooxml-3.17.jar!/:3.17]         at com.alibaba.excel.context.WriteContextImpl.finish(WriteContextImpl.java:349) ~[easyexcel-2.0.4.jar!/:na]         ... 73 common frames omitted Caused by: java.io.IOException: Broken pipe         at java.base/sun.nio.ch.FileDispatcherImpl.write0(Native Method) ~[na:na]         at java.base/sun.nio.ch.SocketDispatcher.write(SocketDispatcher.java:47) ~[na:na]         at java.base/sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:113) ~[na:na]         at java.base/sun.nio.ch.IOUtil.write(IOUtil.java:79) ~[na:na]         at java.base/sun.nio.ch.IOUtil.write(IOUtil.java:50) ~[na:na]         at java.base/sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:466) ~[na:na]         at org.apache.tomcat.util.net.NioChannel.write(NioChannel.java:134) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.tomcat.util.net.NioBlockingSelector.write(NioBlockingSelector.java:105) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.tomcat.util.net.NioSelectorPool.write(NioSelectorPool.java:144) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.doWrite(NioEndpoint.java:1223) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.tomcat.util.net.SocketWrapperBase.doWrite(SocketWrapperBase.java:743) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.tomcat.util.net.SocketWrapperBase.writeBlocking(SocketWrapperBase.java:513) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.tomcat.util.net.SocketWrapperBase.write(SocketWrapperBase.java:451) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.coyote.http11.Http11OutputBuffer$SocketOutputBuffer.doWrite(Http11OutputBuffer.java:530) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.coyote.http11.filters.ChunkedOutputFilter.doWrite(ChunkedOutputFilter.java:112) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.coyote.http11.Http11OutputBuffer.doWrite(Http11OutputBuffer.java:189) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.coyote.Response.doWrite(Response.java:599) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         at org.apache.catalina.connector.OutputBuffer.realWriteBytes(OutputBuffer.java:329) ~[tomcat-embed-core-9.0.16.jar!/:9.0.16]         ... 86 common frames omitted</body>
		<created>2019-09-30 06:33:11</created>
		<closed>2019-10-08 12:28:28</closed>
	</bug>
	<bug>
		<id>654</id>
		<title>自定义表头，属性值为空忽略了当前属性的值，但是保存了下一个不为空的属性值，造成列错位</title>
		<body>**触发场景描述** 在类【Xxx】的属性上自定义了一个注解（每个字段上都有这个自定义注解【Yyy】），通过这个注解的某个属性值来作为表头。 **触发Bug的代码** ```java         List&lt;Xxx&gt; data = getAllData();         ServletOutputStream sos = response.getOutputStream();          Field[] fields = Xxx.class.getDeclaredFields();         List&lt;List&lt;String&gt;&gt; headers = new ArrayList&lt;&gt;();         List&lt;String&gt; list;         for (Field field : fields) {             if (field.isAnnotationPresent(Yyy.class)) {                 list = new ArrayList&lt;&gt;();                 list.add(field.getAnnotation(Yyy.class).name());                 headers.add(list);             }         }          new ExcelWriterBuilder().file(sos).registerConverter(new ObjectToStringConverter()).excelType(ExcelTypeEnum.XLSX)                 .autoCloseStream(true)                 //.registerWriteHandler(new LongestMatchColumnWidthStyleStrategy())                 .sheet(0, "datas")                 .head(Xxx.class).doWrite(data); ``` **提示的异常或者没有达到的效果** excel列发生错位</body>
		<created>2019-09-29 09:05:11</created>
		<closed>2019-10-15 06:47:00</closed>
	</bug>
	<bug>
		<id>653</id>
		<title>EasyExcle第一次因为格式导入报错，再次导入即使格式是对了也会导入失败，报同样的错误</title>
		<body>**需求** 1、数据库设计：id，name，age；其中id为主键，不能为空 2、导入excle 数据（id手动输入） **产生的情况** 1、当excel没有空行的时候导入成功 2、当excel有空行的时候导入失败，接下来不重启系统，即使再次导入正确的没有空行的文件，依然回报同样的错误 **触发Bug的代码** ```java    public void invoke(Person data, AnalysisContext context) {         log.info("解析到一条数据:{}", JSON.toJSONString(data));        //不添加该处判断，会因为读入的空对象，导致存储失败         if (data != null &amp;&amp; data.getId() != null) {             list.add(data);         }         if (list.size() &gt;= BATCH_COUNT) {            //简单的数据库批量存储             saveData();             list.clear();         }     }  ``` **希望达到的效果** 1、希望不会读取空的对象； 2、即使因为格式导入失败，但只要格式对，不重启服务器接口导入功能正常 </body>
		<created>2019-09-29 06:46:05</created>
		<closed>2019-10-15 14:21:03</closed>
	</bug>
	<bug>
		<id>649</id>
		<title>RichTextString无效</title>
		<body>在CellWriteHandler的afterCellCreat()方法中，设置新建了RichTextString并设置了字体，但是为生效  `@Override public void afterCellCreate(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, CellData cellData, Cell cell, Head head, int relativeRowIndex, boolean isHead) {         Font redFont = writeSheetHolder.getSheet().getWorkbook().createFont();         if(redFont instanceof XSSFFont) {             XSSFRichTextString richString = new XSSFRichTextString("21213");             richString.applyFont(0, 1, redFont);             cell.setCellValue(richString);          } }`</body>
		<created>2019-09-27 07:34:09</created>
		<closed>2019-10-23 11:05:00</closed>
	</bug>
	<bug>
		<id>648</id>
		<title>2.0.4版本bug，读取excel2007数据格式的数据，用String类型接收精度丢失，测试数据4.9 读取的时候丢失精度</title>
		<body>**触发场景描述** Excel2007读取 **触发Bug的代码** ```java   @Data public class DemoData {     private String string;     private Date date;     private String doubleData; } ``` doubleData精度丢失，读取的数值变成4.9000000000000004  </body>
		<created>2019-09-27 06:58:44</created>
		<closed>2019-10-15 14:27:21</closed>
	</bug>
	<bug>
		<id>647</id>
		<title>使用sheetName定位sheet页时，如果该sheetName不存在的话，返回了index为0的sheet页</title>
		<body>**触发场景描述** 使用sheetName定位sheet页   **触发Bug的代码** ```java EasyExcel.read(file.getInputStream(), typeRelation.getModelClass(), typeRelation.getReadListener()).customObject(customerData).sheet(typeRelation.getSheetName()).doRead(); ``` **提示的异常或者没有达到的效果** 返回给我索引为0的sheet页，期望不存在指定的sheet页时报错</body>
		<created>2019-09-27 06:37:36</created>
		<closed>2019-10-21 12:53:45</closed>
	</bug>
	<bug>
		<id>646</id>
		<title>导出的excel,点击数字类型格子里,数据会变科学计数法,并且丢位</title>
		<body>使用版本2.0.3 如果导出 类型为长整型或者string,导出后excel点击进某个数据框内再出来,数据就会发生变化 依旧有丢位情况,比如7495396815497821会变成7495396815497820 </body>
		<created>2019-09-27 03:26:20</created>
		<closed>2020-03-17 12:19:42</closed>
	</bug>
	<bug>
		<id>642</id>
		<title>导入时如果异常突然终止导入，文件就无法再导入了</title>
		<body>感觉像是再导入时，IO没有正常关闭的话，会损坏文件</body>
		<created>2019-09-26 09:29:42</created>
		<closed>2019-10-16 10:50:42</closed>
	</bug>
	<bug>
		<id>636</id>
		<title>org.apache.poi.poifs.filesystem.FileMagic</title>
		<body>**触发场景描述**    如下代码所示 **触发Bug的代码** ```java     @Test     public void simpleRead() {          // 写法2：         String fileName =  "test.xlsx";         ExcelReader excelReader = EasyExcel.read(fileName, DemoData.class, new DemoDataListener()).build();         ReadSheet readSheet = EasyExcel.readSheet(0).build();         excelReader.read(readSheet);         // 这里千万别忘记关闭，读的时候会创建临时文件，到时磁盘会崩的         excelReader.finish();     } ``` **提示的异常或者没有达到的效果** Caused by: java.lang.ClassNotFoundException: org.apache.poi.poifs.filesystem.FileMagic at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:335) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ... 32 more</body>
		<created>2019-09-25 08:34:46</created>
		<closed>2019-09-25 10:37:36</closed>
	</bug>
	<bug>
		<id>632</id>
		<title>Could not open the specified zip entry source stream</title>
		<body>**触发场景描述** 如果excel 数据很大 就会报异常  Could not open the specified zip entry source stream **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** </body>
		<created>2019-09-24 15:35:38</created>
		<closed>2019-10-16 10:54:23</closed>
	</bug>
	<bug>
		<id>631</id>
		<title>com.alibaba.excel.exception.ExcelAnalysisException: Can not close IO</title>
		<body>**触发场景描述** 从.xlsx中获取数据, 数据已经入库, 但是抛出异常 **触发Bug的代码** ```java    EasyExcel.read(uploadFileProperties.getFile(), ScyUserImpVo.class, scyUserImpListener).sheet()                     .doRead(); ``` **提示的异常或者没有达到的效果** ```java c.j.j.w.controller.ExceptionController   : com.alibaba.excel.exception.ExcelAnalysisException: Can not close IO at com.alibaba.excel.analysis.ExcelAnalyserImpl.throwCanNotCloseIo(ExcelAnalyserImpl.java:152) at com.alibaba.excel.analysis.ExcelAnalyserImpl.finish(ExcelAnalyserImpl.java:125) at com.alibaba.excel.ExcelReader.finish(ExcelReader.java:273) at com.alibaba.excel.read.builder.ExcelReaderSheetBuilder.doRead(ExcelReaderSheetBuilder.java:161) at com.jsan.jvaif.inf.service.impl.ScyUserServiceImpl.impScyUser(ScyUserServiceImpl.java:310) at com.jsan.jvaif.web.controller.ScyUserController.importScyUserFromTemplate(ScyUserController.java:153) at com.jsan.jvaif.web.controller.ScyUserController$$FastClassBySpringCGLIB$$f49f6b7f.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:749) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) at org.springframework.validation.beanvalidation.MethodValidationInterceptor.invoke(MethodValidationInterceptor.java:119) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:93) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) at com.jsan.jvaif.web.controller.ScyUserController$$EnhancerBySpringCGLIB$$f9a4aa9a.importScyUserFromTemplate(&lt;generated&gt;) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:566) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:892) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1039) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:908) at javax.servlet.http.HttpServlet.service(HttpServlet.java:660) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) at org.springframework.test.web.servlet.TestDispatcherServlet.service(TestDispatcherServlet.java:71) at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) at org.springframework.mock.web.MockFilterChain$ServletFilterProxy.doFilter(MockFilterChain.java:166) at org.springframework.mock.web.MockFilterChain.doFilter(MockFilterChain.java:133) at org.springframework.test.web.servlet.MockMvc.perform(MockMvc.java:182) at com.jsan.jvaif.web.WebApplicationTests.uploadParams(WebApplicationTests.java:102) at com.jsan.jvaif.web.controller.ScyUserControllerTest.testImportScyUser(ScyUserControllerTest.java:97) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.base/java.lang.reflect.Method.invoke(Method.java:566) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74) at org.springframework.test.context.junit4.statements.RunAfterTestExecutionCallbacks.evaluate(RunAfterTestExecutionCallbacks.java:84) at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26) at org.springframework.test.context.junit4.statements.RunBeforeTestMethodCallbacks.evaluate(RunBeforeTestMethodCallbacks.java:75) at org.springframework.test.context.junit4.statements.RunAfterTestMethodCallbacks.evaluate(RunAfterTestMethodCallbacks.java:86) at org.springframework.test.context.junit4.statements.SpringRepeat.evaluate(SpringRepeat.java:84) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:251) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:97) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:190) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: org.apache.poi.openxml4j.exceptions.OpenXML4JRuntimeException: Fail to save: an error occurs while saving the package : class org.apache.poi.openxml4j.util.ZipSecureFile$ThresholdInputStream cannot be cast to class java.util.zip.ZipFile$ZipFileInputStream (org.apache.poi.openxml4j.util.ZipSecureFile$ThresholdInputStream is in unnamed module of loader 'app'; java.util.zip.ZipFile$ZipFileInputStream is in module java.base of loader 'bootstrap') at org.apache.poi.openxml4j.opc.ZipPackage.saveImpl(ZipPackage.java:595) at org.apache.poi.openxml4j.opc.OPCPackage.save(OPCPackage.java:1539) at org.apache.poi.openxml4j.opc.OPCPackage.save(OPCPackage.java:1522) at org.apache.poi.openxml4j.opc.ZipPackage.closeImpl(ZipPackage.java:450) at org.apache.poi.openxml4j.opc.OPCPackage.close(OPCPackage.java:479) at com.alibaba.excel.analysis.ExcelAnalyserImpl.finish(ExcelAnalyserImpl.java:122) ... 68 more Caused by: java.lang.ClassCastException: class org.apache.poi.openxml4j.util.ZipSecureFile$ThresholdInputStream cannot be cast to class java.util.zip.ZipFile$ZipFileInputStream (org.apache.poi.openxml4j.util.ZipSecureFile$ThresholdInputStream is in unnamed module of loader 'app'; java.util.zip.ZipFile$ZipFileInputStream is in module java.base of loader 'bootstrap') at java.base/java.util.zip.ZipFile$ZipFileInflaterInputStream.available(ZipFile.java:479) at org.apache.poi.openxml4j.util.ZipSecureFile$ThresholdInputStream.available(ZipSecureFile.java:317) at org.apache.poi.openxml4j.opc.internal.marshallers.ZipPartMarshaller.marshall(ZipPartMarshaller.java:84) at org.apache.poi.openxml4j.opc.ZipPackagePart.save(ZipPackagePart.java:124) at org.apache.poi.openxml4j.opc.internal.marshallers.DefaultMarshaller.marshall(DefaultMarshaller.java:43) at org.apache.poi.openxml4j.opc.ZipPackage.saveImpl(ZipPackage.java:585) ... 73 more ```</body>
		<created>2019-09-24 15:00:54</created>
		<closed>2019-10-15 14:27:42</closed>
	</bug>
	<bug>
		<id>622</id>
		<title>easyexcel生成的excel无法居中</title>
		<body>**触发场景描述** 生成excel后，生成的excel无法居中 **触发Bug的代码** ```java ![image](https://user-images.githubusercontent.com/38496424/65404657-09fc1500-de0c-11e9-8fd7-9a39144a46c1.png)   ``` **提示的异常或者没有达到的效果** 无法居中</body>
		<created>2019-09-23 06:11:43</created>
		<closed>2019-09-23 12:05:03</closed>
	</bug>
	<bug>
		<id>612</id>
		<title>web中写文件，使用动态表头的写法，文件无法打开，提示错误</title>
		<body>**触发场景描述** web中写文件，使用动态表头的写法，用文档软件无法打开文件，提示遇到错误 **触发Bug的代码** ```java   EasyExcel.write(response.getOutputStream())                     .head(getHead())                     .sheet("数据明细")                     .table()                     .head(SmsEffectExportVO.class)                     .needHead(false)                     .doWrite(exportVOList);  private List&lt;List&lt;String&gt;&gt; getHead() {         List&lt;String&gt; headList = Arrays.asList("日期", "退款客户数(人)", "退款金额(元)", "客单价(元)", "退款订单数(笔)", "平均退款宝贝数(件)", "退款率(%)");         List&lt;String&gt; head0 = Collections.singletonList(headList.get(0));         List&lt;String&gt; head1 = Collections.singletonList(headList.get(1));         List&lt;String&gt; head2 = Collections.singletonList(headList.get(2));         List&lt;String&gt; head3 = Collections.singletonList(headList.get(3));         List&lt;String&gt; head4 = Collections.singletonList(headList.get(4));         List&lt;String&gt; head5 = Collections.singletonList(headList.get(5));         List&lt;String&gt; head6 = Collections.singletonList(headList.get(6));         return Arrays.asList(head0, head1, head2, head3, head4, head5, head6);     }   @Data public class SmsEffectExportVO extends BaseRowModel {     private String date;     private long customerCount;     private String amount;     private String unitPrice;     private long orderCount;     private long itemCount;     private String avgItemNum;     private String rate; } ``` **提示的异常或者没有达到的效果** 无异常信息。 </body>
		<created>2019-09-20 08:37:46</created>
		<closed>2019-09-20 09:40:45</closed>
	</bug>
	<bug>
		<id>610</id>
		<title>写excel 时poi依赖问题导致的失败 , 异常信息丢失</title>
		<body>**触发场景描述** 写excel 时 且poi依赖异常 **触发Bug的代码** ```java        public ByteArrayOutputStream convertToOutputStream(Class&lt;T&gt; clazz,List&lt;T&gt; data) {                   ByteArrayOutputStream outputStream = new ByteArrayOutputStream();          EasyExcel.write(outputStream,clazz).sheet().doWrite(data);                   return outputStream;       } ``` **提示的异常或者没有达到的效果** ExcelBuilderImpl   addContent 方法 第98行 异常信息被catch住且执行finish() 方法  导致原异常信息: java.lang.NoSuchMethodError: org.apache.poi.ss.usermodel.CellStyle.setVerticalAlignment(Lorg/apache/poi/ss/usermodel/VerticalAlignment;) 丢失 且抛出异常信息为: com.alibaba.excel.exception.ExcelGenerateException: Can not close IO  </body>
		<created>2019-09-19 12:00:49</created>
		<closed>2019-09-23 12:11:56</closed>
	</bug>
	<bug>
		<id>598</id>
		<title>设置了模板的情况下，默认加了一行头，如果在设置头，那样前面就会多出一空行</title>
		<body> public int getNewRowIndexAndStartDoWrite() {         // 'getLastRowNum' doesn't matter if it has one or zero,is's zero         int newRowIndex = 0;         switch (writeLastRowType) {             case TEMPLATE_EMPTY:                 if (parentWriteWorkbookHolder.getExcelType() == ExcelTypeEnum.XLSX) {                     if (parentWriteWorkbookHolder.getTemplateLastRowMap().containsKey(sheetNo)) {                         newRowIndex = parentWriteWorkbookHolder.getTemplateLastRowMap().get(sheetNo);                     }                 } else {                     newRowIndex = sheet.getLastRowNum();                 }                    newRowIndex++;//这里默认加了一行，导至我加入title后前面总是空一行                 break;             case HAS_DATA:                 newRowIndex = sheet.getLastRowNum();                 newRowIndex++;                 break;             default:                 break;         }         writeLastRowType = WriteLastRowType.HAS_DATA;         return newRowIndex;     } </body>
		<created>2019-09-18 03:33:53</created>
		<closed>2019-10-14 11:42:23</closed>
	</bug>
	<bug>
		<id>572</id>
		<title>@HeadRowHeight在动态表头时无效</title>
		<body>使用了动态表头，发现设置的@HeadRowHeight无效  @HeadRowHeight(50) @ContentRowHeight(20) @Data public class UserExportVO { }  EasyExcel.write(response.getOutputStream()).head(headers) .sheet(sheetName).table().head(clazz).needHead(false).doWrite(data);</body>
		<created>2019-09-11 08:37:39</created>
		<closed>2019-09-11 10:51:56</closed>
	</bug>
	<bug>
		<id>567</id>
		<title>导出会将Model类中final static字段也作为表头输出</title>
		<body>**触发场景描述** 导出会将Model类中final static字段也作为表头输出 ![image](https://user-images.githubusercontent.com/3170158/64592279-38c2c600-d3de-11e9-8226-7323bb18caf9.png)   **触发Bug的代码** 在测试Model中增加`private final static String TITLE = "主标题";` ```java @Data public class ComplexHeadData {     private final static String TITLE = "主标题";     @ExcelProperty({TITLE, "字符串标题"})     private String string;     @ExcelProperty({TITLE, "日期标题"})     private Date date;     @ExcelProperty({TITLE, "数字标题"})     private Double doubleData; } ``` 执行测试方法 WriteTest.complexHeadWrite  **提示的异常或者没有达到的效果** 无异常，需要过滤final static类型字段（属性）  </body>
		<created>2019-09-10 07:21:29</created>
		<closed>2019-10-21 12:48:58</closed>
	</bug>
	<bug>
		<id>549</id>
		<title>excel里的空行也被解析了导致业务抛空指针</title>
		<body>**触发场景描述** AnalysisEventListener的invoke方法读取了excel的空行，导致业务代码抛空指针 **触发Bug的代码** ```java    这里写代码 ``` **提示的异常或者没有达到的效果** </body>
		<created>2019-09-05 10:55:17</created>
		<closed>2019-09-05 10:55:59</closed>
	</bug>
	<bug>
		<id>540</id>
		<title>通过模板导出时传入list&lt;list&lt;object&gt;&gt;数据，导出的数据列数变少，且object为null时会空指针</title>
		<body>**触发场景描述** 使用模板导出 **触发Bug的代码**    for (int i = 0; i &lt; oneRowData.size() - dataIndex; i++) {//此处减去dataindex后遍历次数减少无法全部遍历出oneRowData中的数据             doAddBasicTypeToExcel(oneRowData, null, row, relativeRowIndex, dataIndex++, cellIndex++);         } private void doAddBasicTypeToExcel(List&lt;Object&gt; oneRowData, Head head, Row row, int relativeRowIndex, int dataIndex,         int cellIndex) {         beforeCellCreate(row, head, relativeRowIndex);         Cell cell = WorkBookUtil.createCell(row, cellIndex);         Object value = oneRowData.get(dataIndex); //此处value为null时会出现空指针         CellData cellData = converterAndSet(context.currentWriteHolder(), value.getClass(), cell, value, null);         afterCellCreate(head, cellData, cell, relativeRowIndex);     } ``` **提示的异常或者没有达到的效果** 无法导出全部列 </body>
		<created>2019-09-04 02:53:23</created>
		<closed>2019-09-08 11:00:03</closed>
	</bug>
	<bug>
		<id>539</id>
		<title>自动列宽无效</title>
		<body>&lt;version&gt;1.1.2-beta5&lt;/version&gt; 版本   sheet.setAutoWidth(true);设置自动列宽导出excel没有效果</body>
		<created>2019-09-04 02:35:38</created>
		<closed>2019-09-04 12:01:51</closed>
	</bug>
	<bug>
		<id>533</id>
		<title>2.0.0-beta3读取03版本的excel时指定的sheet不生效，读取07版本的时正常的</title>
		<body>**触发场景描述** 使用quickstart中的同步结合web读取指定sheetNo和sheetName中的数据,当上传07版本的excel会正确读取到指定sheet里的数据，但是如果上传03版本的excel时却读取了全部的数据  **触发Bug的代码** ```java     private int readExcel4Other(MultipartFile file) throws IOException {         List&lt;Object&gt; list = EasyExcel.read(file.getInputStream()).head(UploadData.class)                 .sheet(2,"Sheet3").doReadSync();          log.info("解析到的数据为{}条",list.size());         return list.size();     }  ``` **提示的异常或者没有达到的效果** 上传.xlsx后正确返回条数，但是上传.xls却是全部sheet的</body>
		<created>2019-09-03 12:08:01</created>
		<closed>2019-09-05 13:08:37</closed>
	</bug>
	<bug>
		<id>521</id>
		<title>当单元格换行的时候只能取到最后一行数据</title>
		<body>**触发场景描述** 单元格换行，测试数据如下 1.依次输入表头信息客户、业务员、仓库、付款方式(现结)、送货员、交易日期、备注 2.依次输入小包商品、大中小包商品、大小包商品 3.输入优惠金额、预收款金额 4.保存-&gt;审核 **触发Bug的代码** ```java     public int importCaseDoc(MultipartFile file) throws IOException {          ExcelReader excelReader = EasyExcel.read(file.getInputStream(), Case.class, new AnalysisEventListener&lt;Case&gt;() {              private final int BATCH_COUNT =1000;             //用来存储excel中的用例             List&lt;Case&gt; castList =  new ArrayList&lt;Case&gt;();             //创建时间任务调用时就是创建时间，这样同一批次导入的时间一致方便处理             Date nowTime=new Date();             @Override             public void invoke(Case caseobj, AnalysisContext analysisContext) {                 System.out.println(caseobj);                 caseobj.setCreateTime(nowTime);                 castList.add(caseobj);                 if(castList.size()&gt;=BATCH_COUNT) {                     saveData();                     castList.clear();                 }             }             @Override             public void doAfterAllAnalysed(AnalysisContext analysisContext) {                 System.out.println("最后几行");                 saveData();             }               private  int saveData(){                 return  caseDesignMapper.insertCase(castList);             }          }).build();          ReadSheet readSheet = EasyExcel.readSheet(0).build();         excelReader.read(readSheet);          return 0;     } ``` **提示的异常或者没有达到的效果**  ![image](https://user-images.githubusercontent.com/25531873/64085353-daa23d00-cd64-11e9-9aec-b767d29008c9.png)  </body>
		<created>2019-09-02 01:34:40</created>
		<closed>2019-09-02 13:43:58</closed>
	</bug>
	<bug>
		<id>520</id>
		<title>字符串为null和“”时转换成Integer会NumberFormatException</title>
		<body>**触发场景描述**  NumberUtils.parseInteger(String string, ExcelContentProperty contentProperty) ; 当string为null和""时，会抛java.lang.NumberFormatException。  **触发Bug的代码** ```java    public static Integer parseInteger(String string, ExcelContentProperty contentProperty) throws ParseException {         if (!hasFormat(contentProperty)) {             return Integer.valueOf(string);         }         return parse(string, contentProperty).intValue();     } ``` **提示的异常或者没有达到的效果** </body>
		<created>2019-09-01 13:08:30</created>
		<closed>2019-09-02 13:43:36</closed>
	</bug>
	<bug>
		<id>514</id>
		<title>最新版本导出多字段数据时候会抛异常</title>
		<body>com.alibaba.excel.exception.ExcelGenerateException: The index of erictionTorquePercentage and neutralSwitchStatus must be inconsistent at com.alibaba.excel.metadata.property.ExcelHeadProperty.initColumnProperties(ExcelHeadProperty.java:141) at com.alibaba.excel.metadata.property.ExcelHeadProperty.&lt;init&gt;(ExcelHeadProperty.java:75) at com.alibaba.excel.write.property.ExcelWriteHeadProperty.&lt;init&gt;(ExcelWriteHeadProperty.java:35) at com.alibaba.excel.write.metadata.holder.AbstractWriteHolder.&lt;init&gt;(AbstractWriteHolder.java:101) at com.alibaba.excel.write.metadata.holder.WriteWorkbookHolder.&lt;init&gt;(WriteWorkbookHolder.java:82) at com.alibaba.excel.context.WriteContextImpl.initCurrentWorkbookHolder(WriteContextImpl.java:103) at com.alibaba.excel.context.WriteContextImpl.&lt;init&gt;(WriteContextImpl.java:65) at com.alibaba.excel.write.ExcelBuilderImpl.&lt;init&gt;(ExcelBuilderImpl.java:55) at com.alibaba.excel.ExcelWriter.&lt;init&gt;(ExcelWriter.java:40) at com.alibaba.excel.write.builder.ExcelWriterBuilder.build(ExcelWriterBuilder.java:171) at com.alibaba.excel.write.builder.ExcelWriterBuilder.sheet(ExcelWriterBuilder.java:187) at com.alibaba.excel.write.builder.ExcelWriterBuilder.sheet(ExcelWriterBuilder.java:183) at com.saicmotor.maxus.status.handler.ExportEvgbHandler.exportD20VehSignal(ExportEvgbHandler.java:593) at com.saicmotor.maxus.status.server.ExportStatusServer.exportD20VehSignal(ExportStatusServer.java:81) </body>
		<created>2019-08-30 03:06:39</created>
		<closed>2019-08-30 06:35:46</closed>
	</bug>
</bugs>
