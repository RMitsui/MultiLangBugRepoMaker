<?xml version="1.0" encoding="ISO-8859-1"?>

<bugs>
	<bug>
		<id>930</id>
		<title>解析SQLExpr的有问题</title>
		<body>![image](https://user-images.githubusercontent.com/31977300/58193606-f7ef5600-7cf5-11e9-9ba6-d7101751bcb5.png)  我用的ES版本是5.2.2，使用range query给double类型的值70.1，解析后类却转变成了BigDecimal，而BigDecimal在ES中是不支持的，最后执行查询的时候ES源码中会校验值的类型，导致报错 @shi-yuan </body>
		<created>2019-05-22 17:02:09</created>
		<closed>2019-06-09 08:22:27</closed>
	</bug>
	<bug>
		<id>920</id>
		<title>Compare two field </title>
		<body>When i want compare two field, i have to use script query like that: `script('doc["first_field"].value == doc["second_field"].value')` So why elasticsearch-sql does not support  like sql : `where first_field = second_field` When i query:  ```sql SELECT first_field , second_field FROM index-*  WHERE first_field = second_field ```  Then response is ok  But when i add more condition:  ```sql SELECT first_field , second_field FROM index-*  WHERE first_field = second_field AND third_field =''  ```  then response error  ```json {     "error": {         "root_cause": [             {                 "type": "sql_parse_exception",                 "reason": "Cannot recoginze Sql identifer second_field"             }         ],         "type": "sql_parse_exception",         "reason": "Cannot recoginze Sql identifer second_field"     },     "status": 500 } ```</body>
		<created>2019-04-12 02:58:38</created>
		<closed>2019-06-09 14:04:35</closed>
	</bug>
	<bug>
		<id>855</id>
		<title>date_histogram空桶执行出错</title>
		<body>sql用法：date_histogram(field='aiops_timestamp','interval'='1d','alias'='aiops_timestamp','min_doc_count'='0','extended_bounds'='1547083500000:1547343000000') -------------------- 执行报错如下： ------------ log4j:WARN No appenders could be found for logger (com.alibaba.druid.pool.vendor.MySqlValidConnectionChecker). log4j:WARN Please initialize the log4j system properly. log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info. ERROR StatusLogger No log4j2 configuration file found. Using default configuration: logging only errors to the console. java.sql.SQLException: Error at com.alibaba.druid.pool.ElasticSearchDruidDataSource.handleConnectionException(ElasticSearchDruidDataSource.java:1109) at com.alibaba.druid.pool.DruidPooledConnection.handleException(DruidPooledConnection.java:127) at com.alibaba.druid.pool.DruidPooledStatement.checkException(DruidPooledStatement.java:68) at com.alibaba.druid.pool.ElasticSearchDruidPooledPreparedStatement.executeQuery(ElasticSearchDruidPooledPreparedStatement.java:61) at org.nlpcn.es4sql.Main2.main(Main2.java:90) Caused by: Failed to execute phase [query], all shards failed; shardFailures {[d0r7oc3TS6eR-sR9A_1_gA][aiops_log][0]: RemoteTransportException[[10.10.100.237][10.10.100.237:9300][indices:data/read/search[phase/query]]]; nested: ElasticsearchParseException[failed to parse date field [1547083500000] with format [yyyy-MM-dd HH:mm:ss]]; nested: IllegalArgumentException[Parse failure at index [9] of [1547083500000]]; }{[d0r7oc3TS6eR-sR9A_1_gA][aiops_log][1]: RemoteTransportException[[10.10.100.237][10.10.100.237:9300][indices:data/read/search[phase/query]]]; nested: ElasticsearchParseException[failed to parse date field [1547083500000] with format [yyyy-MM-dd HH:mm:ss]]; nested: IllegalArgumentException[Parse failure at index [9] of [1547083500000]]; }{[d0r7oc3TS6eR-sR9A_1_gA][aiops_log][2]: RemoteTransportException[[10.10.100.237][10.10.100.237:9300][indices:data/read/search[phase/query]]]; nested: ElasticsearchParseException[failed to parse date field [1547083500000] with format [yyyy-MM-dd HH:mm:ss]]; nested: IllegalArgumentException[Parse failure at index [9] of [1547083500000]]; }{[EGg0HOPrTByzU9egjW_fnw][aiops_log][3]: RemoteTransportException[[10.10.100.236][10.10.100.236:9300][indices:data/read/search[phase/query]]]; nested: ElasticsearchParseException[failed to parse date field [1547083500000] with format [yyyy-MM-dd HH:mm:ss]]; nested: IllegalArgumentException[Parse failure at index [9] of [1547083500000]]; }{[d0r7oc3TS6eR-sR9A_1_gA][aiops_log][4]: RemoteTransportException[[10.10.100.237][10.10.100.237:9300][indices:data/read/search[phase/query]]]; nested: ElasticsearchParseException[failed to parse date field [1547083500000] with format [yyyy-MM-dd HH:mm:ss]]; nested: IllegalArgumentException[Parse failure at index [9] of [1547083500000]]; } at org.elasticsearch.action.search.AbstractSearchAsyncAction.onInitialPhaseResult(AbstractSearchAsyncAction.java:223) at org.elasticsearch.action.search.AbstractSearchAsyncAction.access$100(AbstractSearchAsyncAction.java:58) at org.elasticsearch.action.search.AbstractSearchAsyncAction$1.onFailure(AbstractSearchAsyncAction.java:148) at org.elasticsearch.action.ActionListenerResponseHandler.handleException(ActionListenerResponseHandler.java:51) at org.elasticsearch.transport.TransportService$ContextRestoreResponseHandler.handleException(TransportService.java:1032) at org.elasticsearch.transport.TcpTransport.lambda$handleException$17(TcpTransport.java:1411) at org.elasticsearch.common.util.concurrent.EsExecutors$1.execute(EsExecutors.java:109) at org.elasticsearch.transport.TcpTransport.handleException(TcpTransport.java:1409) at org.elasticsearch.transport.TcpTransport.handlerResponseError(TcpTransport.java:1401) at org.elasticsearch.transport.TcpTransport.messageReceived(TcpTransport.java:1345) at org.elasticsearch.transport.netty4.Netty4MessageChannelHandler.channelRead(Netty4MessageChannelHandler.java:74) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:341) at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:293) at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:280) at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:396) at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349) at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:341) at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1334) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:363) at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:349) at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:926) at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:129) at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:642) at io.netty.channel.nio.NioEventLoop.processSelectedKeysPlain(NioEventLoop.java:527) at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:481) at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:441) at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:858) at java.lang.Thread.run(Thread.java:745) Caused by: RemoteTransportException[[10.10.100.237][10.10.100.237:9300][indices:data/read/search[phase/query]]]; nested: ElasticsearchParseException[failed to parse date field [1547083500000] with format [yyyy-MM-dd HH:mm:ss]]; nested: IllegalArgumentException[Parse failure at index [9] of [1547083500000]]; Caused by: ElasticsearchParseException[failed to parse date field [1547083500000] with format [yyyy-MM-dd HH:mm:ss]]; nested: IllegalArgumentException[Parse failure at index [9] of [1547083500000]]; at org.elasticsearch.common.joda.DateMathParser.parseDateTime(DateMathParser.java:213) at org.elasticsearch.common.joda.DateMathParser.parse(DateMathParser.java:66) at org.elasticsearch.search.DocValueFormat$DateTime.parseLong(DocValueFormat.java:170) at org.elasticsearch.search.aggregations.bucket.histogram.ExtendedBounds.parseAndValidate(ExtendedBounds.java:156) at org.elasticsearch.search.aggregations.bucket.histogram.DateHistogramAggregationBuilder.innerBuild(DateHistogramAggregationBuilder.java:329) at org.elasticsearch.search.aggregations.support.ValuesSourceAggregationBuilder.doBuild(ValuesSourceAggregationBuilder.java:291) at org.elasticsearch.search.aggregations.support.ValuesSourceAggregationBuilder.doBuild(ValuesSourceAggregationBuilder.java:39) at org.elasticsearch.search.aggregations.AbstractAggregationBuilder.build(AbstractAggregationBuilder.java:126) at org.elasticsearch.search.aggregations.AggregatorFactories$Builder.build(AggregatorFactories.java:333) at org.elasticsearch.search.SearchService.parseSource(SearchService.java:637) at org.elasticsearch.search.SearchService.createContext(SearchService.java:468) at org.elasticsearch.search.SearchService.createAndPutContext(SearchService.java:444) at org.elasticsearch.search.SearchService.executeQueryPhase(SearchService.java:252) at org.elasticsearch.action.search.SearchTransportService$6.messageReceived(SearchTransportService.java:331) at org.elasticsearch.action.search.SearchTransportService$6.messageReceived(SearchTransportService.java:328) at org.elasticsearch.transport.RequestHandlerRegistry.processMessageReceived(RequestHandlerRegistry.java:69) at org.elasticsearch.transport.TcpTransport$RequestHandler.doRun(TcpTransport.java:1488) at org.elasticsearch.common.util.concurrent.ThreadContext$ContextPreservingAbstractRunnable.doRun(ThreadContext.java:638) at org.elasticsearch.common.util.concurrent.AbstractRunnable.run(AbstractRunnable.java:37) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745) Caused by: java.lang.IllegalArgumentException: Parse failure at index [9] of [1547083500000] at org.elasticsearch.common.joda.DateMathParser.parseDateTime(DateMathParser.java:207) ... 21 more {"msg":"FAILURE","code":-1,"dataList":[]}  </body>
		<created>2019-01-13 15:01:14</created>
		<closed>2019-06-09 11:42:59</closed>
	</bug>
	<bug>
		<id>853</id>
		<title>inner_hits seems to be not working on 6.5.3 for nested array </title>
		<body>`SELECT * FROM myIndex where nested('comments', comments.message = 'hello' and comments.likes &gt; 3,'{"from":0}') `this doesn't return the inner hits for version 6.5.3</body>
		<created>2019-01-12 03:15:45</created>
		<closed>2019-01-15 12:14:39</closed>
	</bug>
	<bug>
		<id>635</id>
		<title>DATE_FORMAT is not supported</title>
		<body>HI Team, I was trying to convert the SQL query in ES ,here is my sql query   SELECT **DATE_FORMAT**(transaction_timestamp, '%Y-%m-%d %H') AS date_hour,partner_id,service_id, servicename,(CASE WHEN service_type=1 THEN 'PPU' WHEN service_type=2 THEN 'Subscription' END)  AS service_type,servicegroup,SUM(Counts) AS total_requests_count,SUM((CASE WHEN STATUS=0 THEN Counts ELSE 0 END))   AS Billing_Status_Success,SUM(CASE WHEN STATUS =1   THEN Counts ELSE 0 END)    AS Billing_Status_Failure FROM reports.diameter_in WHERE transaction_timestamp &gt;= '2018-03-21 00:00:00'  AND  transaction_timestamp &lt;= '2018-03-21 23:59:59'   ORDER BY date_hour DESC LIMIT 0,10    **DATE_FORMAT** is unable to handled by switch case</body>
		<created>2018-03-22 13:26:48</created>
		<closed>2018-10-02 01:59:16</closed>
	</bug>
	<bug>
		<id>62</id>
		<title>Support Elasticsearch 1.5</title>
		<body>We need to make the plugin support in elasticsearch 1.5.X. As described in #54 it currently not working... </body>
		<created>2015-05-30 09:42:12</created>
		<closed>2015-06-20 19:30:16</closed>
	</bug>
	<bug>
		<id>37</id>
		<title>Fix index name recognition</title>
		<body>When making a query, the sql parser should'nt evaluate the index name as expression, instead it should pick it up AS IS until the space. so the first word after the FROM should be recognized as index name.  The bug causing problems like described in issues #36 and #34  There is one exception, multiple indexes should be supported, So a query like this, should work:  ``` SELECT * FROM index1, index2, index3 ``` </body>
		<created>2015-02-06 21:55:06</created>
		<closed>2015-02-28 10:32:16</closed>
	</bug>
</bugs>
