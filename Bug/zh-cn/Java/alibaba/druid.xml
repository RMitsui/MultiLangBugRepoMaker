<?xml version="1.0" encoding="ISO-8859-1"?>

<bugs>
	<bug>
		<id>3230</id>
		<title>mybatis 3.51版本的LocalDateTime映射报SQLFeatureNotSupportedException</title>
		<body>DruidPooledResultSet这个类的getObject方法 public &lt;T&gt; T getObject(String columnLabel, Class&lt;T&gt; type) throws SQLException {         throw new SQLFeatureNotSupportedException();     } mybatis中的LocalDateTimeTypeHandler调用getNullableResult  public LocalDateTime getNullableResult(ResultSet rs, int columnIndex) throws SQLException {         return (LocalDateTime)rs.getObject(columnIndex, LocalDateTime.class);     }</body>
		<created>2019-05-14 08:25:23</created>
		<closed>2019-06-30 14:30:28</closed>
	</bug>
	<bug>
		<id>3194</id>
		<title>Caused by: java.sql.SQLFeatureNotSupportedException</title>
		<body>Environment： ``` mybatis-spring-boot-starter：2.0.1 druid-spring-boot-starter: 1.1.14 mysql-connector-java: 5.1.47 spring-boot-starter-parent: 2.1.4.RELEASE ```  Throws below exception when executed  a query sql statement by Mybatis.  ``` Caused by: java.sql.SQLFeatureNotSupportedException at com.alibaba.druid.pool.DruidPooledResultSet.getObject(DruidPooledResultSet.java:1771) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.ibatis.logging.jdbc.ResultSetLogger.invoke(ResultSetLogger.java:69) at com.sun.proxy.$Proxy94.getObject(Unknown Source) at org.apache.ibatis.type.LocalDateTimeTypeHandler.getNullableResult(LocalDateTimeTypeHandler.java:38) at org.apache.ibatis.type.LocalDateTimeTypeHandler.getNullableResult(LocalDateTimeTypeHandler.java:28) at org.apache.ibatis.type.BaseTypeHandler.getResult(BaseTypeHandler.java:81) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getPropertyMappingValue(DefaultResultSetHandler.java:472) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.applyPropertyMappings(DefaultResultSetHandler.java:441) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.getRowValue(DefaultResultSetHandler.java:404) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValuesForSimpleResultMap(DefaultResultSetHandler.java:354) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleRowValues(DefaultResultSetHandler.java:328) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSet(DefaultResultSetHandler.java:301) at org.apache.ibatis.executor.resultset.DefaultResultSetHandler.handleResultSets(DefaultResultSetHandler.java:194) at org.apache.ibatis.executor.statement.PreparedStatementHandler.query(PreparedStatementHandler.java:65) at org.apache.ibatis.executor.statement.RoutingStatementHandler.query(RoutingStatementHandler.java:79) at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:63) at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:324) at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:147) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:140) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:433) ... 51 more  ```  Mapper.xml: ```     &lt;resultMap type="io.github.yidasanqian.mybatisdemo.entity.Role" id="Role_ResultMap"&gt;         &lt;result property="id" column="id"/&gt;         &lt;result property="name" column="name"/&gt;         &lt;result property="createAt" column="create_at"/&gt;         &lt;result property="updateAt" column="update_at"/&gt;     &lt;/resultMap&gt; ``` Role.java ``` public class Role implements Serializable {     private static final long serialVersionUID = -50780509322421020L;          private Integer id;          private String name;          private LocalDateTime createAt;          private LocalDateTime updateAt;          // ignored getter &amp; setter } ```</body>
		<created>2019-04-19 10:29:56</created>
		<closed>2019-06-17 03:09:49</closed>
	</bug>
	<bug>
		<id>3091</id>
		<title>druid-1.1.13-flyway-5.2.4-postgres对“set role” 解析报错</title>
		<body>druid 1.1.13 flyway 5.2.4 postgres 9.6  ~~~java 2019-02-22 17:43:18.031 ERROR 13456 --- [           main] c.a.d.f.s.StatFilter                     : merge sql error, dbType postgresql, druid-1.1.13, sql : SET ROLE 'postgres'  com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'ROLE 'postgres'', expect LITERAL_CHARS, actual LITERAL_CHARS pos 19, line 1, column 9, token LITERAL_CHARS postgres at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:288) ~[druid-1.1.13.jar:1.1.13] at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:433) ~[druid-1.1.13.jar:1.1.13] at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:72) ~[druid-1.1.13.jar:1.1.13] at com.alibaba.druid.sql.visitor.ParameterizedOutputVisitorUtils.parameterize(ParameterizedOutputVisitorUtils.java:94) ~[druid-1.1.13.jar:1.1.13] at com.alibaba.druid.sql.visitor.ParameterizedOutputVisitorUtils.parameterize(ParameterizedOutputVisitorUtils.java:77) ~[druid-1.1.13.jar:1.1.13] at com.alibaba.druid.sql.visitor.ParameterizedOutputVisitorUtils.parameterize(ParameterizedOutputVisitorUtils.java:50) ~[druid-1.1.13.jar:1.1.13] at com.alibaba.druid.filter.stat.StatFilter.mergeSql(StatFilter.java:147) ~[druid-1.1.13.jar:1.1.13] at com.alibaba.druid.filter.stat.StatFilter.createSqlStat(StatFilter.java:648) ~[druid-1.1.13.jar:1.1.13] at com.alibaba.druid.filter.stat.StatFilter.statementPrepareAfter(StatFilter.java:311) ~[druid-1.1.13.jar:1.1.13] at com.alibaba.druid.filter.FilterEventAdapter.connection_prepareStatement(FilterEventAdapter.java:124) ~[druid-1.1.13.jar:1.1.13] at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:568) ~[druid-1.1.13.jar:1.1.13] ~~~</body>
		<created>2019-02-22 09:58:47</created>
		<closed>2019-02-27 04:08:22</closed>
	</bug>
	<bug>
		<id>3090</id>
		<title>格式化hive create语句，当库名为default时报错</title>
		<body>```java String dbType = JdbcConstants.HIVE; String sql = "CREATE TABLE IF NOT EXISTS default.create_test (id int COMMENT '学号', name string COMMENT '姓名');"; String sqlBeauty = SQLUtils.format(sql , dbType); System.out.println(sqlBeauty); ```  报错： ``` [2019-02-22 17:18:36,783] WARN          format error com.alibaba.druid.sql.parser.ParserException: error pos 34, line 1, column 27, token DEFAULT at com.alibaba.druid.sql.parser.SQLExprParser.name(SQLExprParser.java:1370) at com.alibaba.druid.sql.dialect.hive.parser.HiveCreateTableParser.parseCreateTable(HiveCreateTableParser.java:71) at com.alibaba.druid.sql.parser.SQLStatementParser.parseCreate(SQLStatementParser.java:2028) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:161) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:72) at com.alibaba.druid.sql.SQLUtils.format(SQLUtils.java:255) at com.alibaba.druid.sql.SQLUtils.format(SQLUtils.java:241) at com.inspur.tax.sjjggl.common.util.SqlParserUtil.main(SqlParserUtil.java:75) CREATE TABLE IF NOT EXISTS default.create_test (id int COMMENT '学号', name string COMMENT '姓名');  Process finished with exit code 0 ```  其他库名格式化正常 </body>
		<created>2019-02-22 09:20:53</created>
		<closed>2019-02-27 04:11:58</closed>
	</bug>
	<bug>
		<id>3085</id>
		<title>SQLASTOutputVisitor格式化有bug只拼了一半单引号导致生成的SQL语法不对</title>
		<body>我继承StatFilter将sql做了采样分析，采样的时候将sql进行格式化只会再次参数化处理，结果生产遇到问题 然后发现SQLASTOutputVisitor在拼sql的时候针对Reader等类型只拼了前半截单引号，没有后半截单引号就return了。   [https://github.com/alibaba/druid/blob/master/src/main/java/com/alibaba/druid/sql/visitor/SQLASTOutputVisitor.java#L2310](https://github.com/alibaba/druid/blob/master/src/main/java/com/alibaba/druid/sql/visitor/SQLASTOutputVisitor.java#L2310)   我的代码如下： ```java private static List&lt;Object&gt; getSqlParamObjetList(StatementProxy statement) {         List&lt;Object&gt; parameters = null;         int parametersSize = statement.getParametersSize();         if (parametersSize &gt; 0) {             parameters = new ArrayList&lt;&gt;(parametersSize);             for (int i = 0; i &lt; parametersSize; ++i) {                 JdbcParameter jdbcParam = statement.getParameter(i);                 Object param = jdbcParam != null ? jdbcParam.getValue() : null;                 if (param instanceof String) {                     String str = (String) param;                     if (str.length() &gt; 300) {// 超长文本做截取                         param = str.subSequence(0, 300) + ".........";                     }                 } //以下是为了兼容druid SQLASTOutputVisitor的bug,返回指定字符串                 if (param instanceof InputStream) {                     param = ("&lt; InputStream &gt;");                 }                 if (param instanceof Reader) {                     param = ("&lt; Reader &gt;");                 }                 if (param instanceof Blob) {                     param = ("&lt; Blob &gt;");                 }                 if (param instanceof NClob) {                     param = ("&lt; NClob &gt;");                 }                  if (param instanceof Clob) {                     param = ("&lt; Clob &gt;");                 }                 parameters.add(param);             }         }         return parameters;     }  private void trySamplingSql(String method, StatementProxy statement, String sql) {         String dbType = statement.getConnectionProxy().getDirectDataSource().getDbType();         List&lt;Object&gt; parameters = getSqlParamObjetList(statement);    String formattedSql = SQLUtils.format(sql, dbType, parameters);         String mergedSql = null;         try { //parameters里有Reader等类型就会出错了。             mergedSql = ParameterizedOutputVisitorUtils.parameterize(formattedSql, "mysql");         } catch (Exception e) {             if (LOG.isWarnEnabled()) {                 String msg = "doAsyncSqlSampling|buterr|" + (formattedSql);                 LOG.warn(msg, e);             }             return;         } //以mergedSql为基准每调采样10次。 } ```</body>
		<created>2019-02-20 12:30:22</created>
		<closed>2019-02-27 04:12:45</closed>
	</bug>
	<bug>
		<id>3081</id>
		<title>使用PagerUtils处理分页SQL,部分数据源分页查询有bug</title>
		<body>项目中使用最新的druid-1.1.13 目前已知数据源有SqlServer和SyBase sqlserver问题： SQL语句：SELECT t.name USER_NAME, t.xxx FROM t_sd_users t ORDER BY t.name ASC 异常信息：java.sql.SQLException: The function 'ROW_NUMBER' must have an OVER clause with ORDER BY. 问题定位： PageUtils 253行，select.getOrderBy() 为空，不过 SQLSelect.SQLSelectQuery 中是有orderBy的，但没有赋值给SQLSelect.SQLOrderBy， 导致上述异常  sybase问题与sqlserver类似，不再重复~ 请尽快解决 </body>
		<created>2019-02-19 09:57:34</created>
		<closed>2019-02-27 04:12:35</closed>
	</bug>
	<bug>
		<id>3080</id>
		<title>CAST函数与负号一起解析错误</title>
		<body>SELECT CAST(10 AS decimal(10, 2)) 可以解析 SELECT -CAST(10 AS decimal(10, 2)) 报错：ParserException: TODO : pos 12, line 1, column 9, token CAST 版本 1.1.4</body>
		<created>2019-02-19 07:42:45</created>
		<closed>2019-02-27 04:12:09</closed>
	</bug>
	<bug>
		<id>3074</id>
		<title>Druid与mariadb兼容性问题</title>
		<body>Springboot 2.0.4集成druid访问mysql数据库，服务运行过程中偶现如下错误： ERROR c.alibaba.druid.pool.DruidDataSource - recyle error java.sql.SQLException: Connection.clearWarnings cannot be called on a closed connection         at org.mariadb.jdbc.internal.util.exceptions.ExceptionMapper.getSqlException(ExceptionMapper.java:271)         at org.mariadb.jdbc.MariaDbConnection.clearWarnings(MariaDbConnection.java:1070)         at com.alibaba.druid.filter.FilterChainImpl.connection_clearWarnings(FilterChainImpl.java:165)         at com.alibaba.druid.filter.FilterAdapter.connection_clearWarnings(FilterAdapter.java:771)         at com.alibaba.druid.filter.FilterChainImpl.connection_clearWarnings(FilterChainImpl.java:161)         at com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl.clearWarnings(ConnectionProxyImpl.java:108)         at com.alibaba.druid.pool.DruidConnectionHolder.reset(DruidConnectionHolder.java:295)         at com.alibaba.druid.pool.DruidDataSource.recycle(DruidDataSource.java:1662)         at com.alibaba.druid.pool.DruidPooledConnection.recycle(DruidPooledConnection.java:323)         at com.alibaba.druid.filter.FilterChainImpl.dataSource_recycle(FilterChainImpl.java:4609)         at com.alibaba.druid.filter.stat.StatFilter.dataSource_releaseConnection(StatFilter.java:665)         at com.alibaba.druid.filter.FilterChainImpl.dataSource_recycle(FilterChainImpl.java:4605)         at com.alibaba.druid.pool.DruidPooledConnection.close(DruidPooledConnection.java:266)         at org.springframework.jdbc.datasource.DataSourceUtils.doCloseConnection(DataSourceUtils.java:354)         at org.springframework.jdbc.datasource.DataSourceUtils.doReleaseConnection(DataSourceUtils.java:341)         at org.springframework.jdbc.datasource.DataSourceUtils.releaseConnection(DataSourceUtils.java:307)         at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:618)         at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:657)         at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:688)         at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:700)         at org.springframework.jdbc.core.JdbcTemplate.queryForRowSet(JdbcTemplate.java:842)  druid配置如下： driver-class-name=org.mariadb.jdbc.Driver type=com.alibaba.druid.pool.DruidDataSource maxWait=180000 maxActive=20 minIdle=10 initialSize=10 timeBetweenEvictionRunsMillis=60000 minEvictableIdleTimeMillis=300000 validationQuery=select 'x' testWhileIdle=true testOnBorrow=false testOnReturn=false</body>
		<created>2019-02-15 06:28:34</created>
		<closed>2019-08-06 09:20:56</closed>
	</bug>
	<bug>
		<id>3058</id>
		<title>druid sqlparser卡住</title>
		<body>对于sql： ``` select job_names.job_name from cover_rage_job_org as org RIGHT JOIN (  select job_names.job_name as job_name     from (     SELECT '1' as job_name ) job_name_all) as job_names on job_names.job_name = org.job_name ``` ，sqlparser会卡住  `List&lt;SQLStatement&gt; sqlStatements = SQLUtils.parseStatements(sql, JdbcConstants.MYSQL);` `for (SQLStatement sqlStatement : sqlStatements) {` `                MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();` `                sqlStatement.accept(visitor);` `}`  在com.alibaba.druid.sql.visitor.SchemaStatVisitor unwrapExpr 这个表达式上会卡住， 建议在825行附近增加逻辑：   `if (selectItem != null) {` `  SQLExpr expr1 = selectItem.getExpr();` `  if (expr1.equals(expr)) {` `    break;` `  }` `  expr = expr1;` `  continue;` `}`  使用的是1.1.12的druid版本</body>
		<created>2019-01-31 02:57:57</created>
		<closed>2019-02-27 04:09:38</closed>
	</bug>
	<bug>
		<id>3045</id>
		<title>对Mysql8的XA支持中有一段代码没有做空指针检查 导致跳过Mysql8  XA创建逻辑</title>
		<body>![image](https://user-images.githubusercontent.com/9814110/51781334-4890e100-2152-11e9-9252-9a40f9d7570c.png) 这是代码请修复 method_6_getValue 该方法没有判断是否为空</body>
		<created>2019-01-26 02:08:20</created>
		<closed>2019-01-31 02:08:53</closed>
	</bug>
	<bug>
		<id>3044</id>
		<title>logExecutableSql方法好像少写了个isStatementLogEnabled判断</title>
		<body>https://github.com/alibaba/druid/blob/46062863f2fd0063488246dcece45ceeec0aba58/src/main/java/com/alibaba/druid/filter/logging/LogFilter.java#L548 ```java     private void logExecutableSql(StatementProxy statement, String sql) {         if (!isStatementExecutableSqlLogEnable()||!isStatementLogEnabled()) {// update here             return;         }          int parametersSize = statement.getParametersSize();         if (parametersSize == 0) {             statementLog("{conn-" + statement.getConnectionProxy().getId() + ", " + stmtId(statement) + "} executed. "                          + sql);             return;         }          List&lt;Object&gt; parameters = new ArrayList&lt;Object&gt;(parametersSize);         for (int i = 0; i &lt; parametersSize; ++i) {             JdbcParameter jdbcParam = statement.getParameter(i);             parameters.add(jdbcParam != null                     ? jdbcParam.getValue()                     : null);         }          String dbType = statement.getConnectionProxy().getDirectDataSource().getDbType();         String formattedSql = SQLUtils.format(sql, dbType, parameters, this.statementSqlFormatOption);         statementLog("{conn-" + statement.getConnectionProxy().getId() + ", " + stmtId(statement) + "} executed. "                      + formattedSql);     } ``` isStatementExecutableSqlLogEnable内部没有对日志级别做判断，因为出错时候也要判断是否打印参数，所以logExecutableSql方法要加上isStatementLogEnabled判断吧</body>
		<created>2019-01-25 11:27:56</created>
		<closed>2019-01-31 02:08:40</closed>
	</bug>
	<bug>
		<id>3018</id>
		<title>解析含有复杂数据结构的hql时报错</title>
		<body>麻烦请教， 含有复杂数据类型的sql解析报错，请问是目前不支持么？还是我的代码有问题 hql： select       field['id'].string_type as banner_id            ,field['index'].string_type as banner_index       ,field['pageName'].string_type as pageName      from  bdm_book.midu_xcx_web_main_log where day = '2019-01-09' and eventid = '151' and cmd in ('26002','26003') group by  field['id'].string_type       ,field['index'].string_type       ,field['pageName'].string_type ;   java 代码： HiveStatementParser parser = new HiveStatementParser(hql);  List&lt;SQLStatement&gt; stmtList = parser.parseStatementList();  第二行java代码抛异常： com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'    field['id'].string_type as ban', expect LBRACKET, actual LBRACKET pos 20, line 2, column 12, token LBRACKET   </body>
		<created>2019-01-10 03:08:07</created>
		<closed>2019-01-31 02:09:00</closed>
	</bug>
	<bug>
		<id>3009</id>
		<title>建议默认禁止druid-springboot-starter中的stat-view监控页面，防止DB信息可能泄露</title>
		<body># druid-springboot-starter默认启用内置监控页面，且不开启任何安全措施，如登录页面、访问IP等。 ```java @ConditionalOnProperty(name = "spring.datasource.druid.stat-view-servlet.enabled", havingValue = "true", matchIfMissing = true) public class DruidStatViewServletConfiguration {}  @ConditionalOnProperty(name = "spring.datasource.druid.web-stat-filter.enabled", havingValue = "true", matchIfMissing = true) public class DruidWebStatFilterConfiguration {} ``` # 可能产生的后果 * 开发不注意，导致监控页面在公网露出，监控页面中包含：DB的IP、用户名、库名、表名、字段名及字段值等，进而导致信息泄露。  # 建议 * 禁用监控页面 如果禁用监控页面StatFilter注册感觉也是多余的，可以等用户需要配置日志、慢sql的时候，再启用 ```java     @Bean     @ConfigurationProperties(FILTER_STAT_PREFIX)     @ConditionalOnProperty(prefix = FILTER_STAT_PREFIX, name = "enabled", matchIfMissing = true)     @ConditionalOnMissingBean     public StatFilter statFilter() {         return new StatFilter();     } ``` * 或默认配置登录页面及allow策略 </body>
		<created>2019-01-04 01:36:53</created>
		<closed>2019-01-31 02:06:20</closed>
	</bug>
	<bug>
		<id>2989</id>
		<title>mysql 语句解析问题</title>
		<body> `SQLUtils.parseStatements（“select id, distinct name from a", "mysql");`  Druid解析没有报错， mysql cmdline 报错  ``` mysql&gt; select id,distinct name from a; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'distinct name from a' at line 1 ```  ``` &lt;dependency&gt;             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;             &lt;artifactId&gt;druid&lt;/artifactId&gt;             &lt;version&gt;1.1.12&lt;/version&gt;         &lt;/dependency&gt; ```</body>
		<created>2018-12-22 10:11:19</created>
		<closed>2019-01-31 02:07:50</closed>
	</bug>
	<bug>
		<id>2985</id>
		<title>DruidDataSourceStatLoggerImpl中生成日志时的bug</title>
		<body>public void log(DruidDataSourceStatValue statValue)方法中存在如下bug： ![selection_003](https://user-images.githubusercontent.com/10007891/50321267-0baa4c80-050b-11e9-981b-018a40c94250.png)     if (sqlStat.getFetchRowCount() &gt; 0) {                     sqlStatMap.put("fetchRowCount", sqlStat.getFetchRowCount());                     sqlStatMap.put("fetchRowCount", sqlStat.getFetchRowCountMax());                     sqlStatMap.put("fetchRowHistogram", rtrim(sqlStat.getFetchRowHistogram()));     } 在if语句块的第二行，显然，"fetchRowCount"应为"fetchRowCountMax" </body>
		<created>2018-12-21 02:32:13</created>
		<closed>2018-12-26 07:00:49</closed>
	</bug>
	<bug>
		<id>2984</id>
		<title>sql解析INTERVAL -"5" 错误</title>
		<body>select id,orderId,taskType,taskData,retryCount,extJson,businessId from task_0029  where taskStatus=0 and taskType='29' AND createDate &lt; DATE_ADD(utc_date(), INTERVAL -'5' DAY) limit 0,1000;    com.alibaba.druid.sql.parser.ParserException: TODO : pos 170, line 1, column 168, token LITERAL_CHARS 5  把 -"5" 改成"-5" 才行</body>
		<created>2018-12-20 09:18:17</created>
		<closed>2019-01-31 02:05:57</closed>
	</bug>
	<bug>
		<id>2980</id>
		<title>多个线程调用DruidDataSource.init()， 会出现‘死锁’情况</title>
		<body>项目正在启动中，尚未加载过DriverManager类, `此时，外部有一个定时任务的调度中心正在往此项目发布多个调度任务，Thread-1获取到init()方法中的可重入锁之后执行后续代码，运行到this.id = DruidDriver.createDataSourceId();时会加载DruidDriver类，运行static块中的registerDriver(Driver driver)，进而执行代码段DriverManager.registerDriver(driver)。Thread-2也进入init()方法，此时，Thread-2若被interrupted，则会进入throw new SQLException("interrupt", e)，而SQLException的构造方法中有 if (DriverManager.getLogWriter() != null)，进而执行DriverManager中的static块，应该是static块中的loadInitialDrivers会用到DruidDriver，而加载DruidDriver的线程Thread-1会用到DriverManager，两个线程相互等待，最终会导致两个线程永远不会结束。实际上就是两个线程分别进入了两个类的static块中，而static块中的都需要对方的资源，最终程序会出现‘死锁’的状态，jvisualvm无法检测到这种死锁。本人目前是新手兼菜鸟，如有说的不对的地方，烦请大神指点指点，谢谢。  下面代码可以复现这个问题，可以使用打断点的方式，也可以多运行几次。 `public class DruidDataSourceTestForDeadLock {      private static DruidDataSource source = new DruidDataSource();     private static void init() {         try {             source.init();         } catch (Exception e) {             e.printStackTrace();         }     }      public static void main(String[] args) {         Thread t1 = new Thread(() -&gt; init());         Thread t2 = new Thread(() -&gt; init());         t1.start();         t2.start();         t2.interrupt();     } }`    上述程序可能会出现两个结果： 1 两个线程卡住，程序无法自动结束 2 程序正常结束，会报错，因为没有设置如数据库url之类的，这是正常的  这是上面这个程序在结果1的情况下dump下来的线程栈： `"Thread-2" #15 prio=5 os_prio=0 tid=0x000000001d046000 nid=0x5b944 in Object.wait() [0x000000001ed9d000]    java.lang.Thread.State: RUNNABLE at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:422) at java.lang.Class.newInstance(Class.java:442) at java.util.ServiceLoader$LazyIterator.nextService(ServiceLoader.java:380) at java.util.ServiceLoader$LazyIterator.next(ServiceLoader.java:404) at java.util.ServiceLoader$1.next(ServiceLoader.java:480) at java.sql.DriverManager$2.run(DriverManager.java:603) at java.sql.DriverManager$2.run(DriverManager.java:583) at java.security.AccessController.doPrivileged(Native Method) at java.sql.DriverManager.loadInitialDrivers(DriverManager.java:583) at java.sql.DriverManager.&lt;clinit&gt;(DriverManager.java:101) at java.sql.SQLException.&lt;init&gt;(SQLException.java:190) at com.alibaba.druid.pool.DruidDataSource.init(DruidDataSource.java:746) at DruidDeadLock.init(DruidDeadLock.java:14) at DruidDeadLock.lambda$1(DruidDeadLock.java:22) at DruidDeadLock$$Lambda$2/191382150.run(Unknown Source) at java.lang.Thread.run(Thread.java:745)     Locked ownable synchronizers: - None  "Thread-1" #14 prio=5 os_prio=0 tid=0x000000001d045800 nid=0xd2cc at breakpoint[0x000000001e09d000]    java.lang.Thread.State: RUNNABLE at com.alibaba.druid.proxy.DruidDriver.registerDriver(DruidDriver.java:92) at com.alibaba.druid.proxy.DruidDriver$1.run(DruidDriver.java:84) at java.security.AccessController.doPrivileged(Native Method) at com.alibaba.druid.proxy.DruidDriver.&lt;clinit&gt;(DruidDriver.java:81) at com.alibaba.druid.pool.DruidDataSource.init(DruidDataSource.java:757) at DruidDeadLock.init(DruidDeadLock.java:14) at DruidDeadLock.lambda$0(DruidDeadLock.java:21) at DruidDeadLock$$Lambda$1/997110508.run(Unknown Source) at java.lang.Thread.run(Thread.java:745)     Locked ownable synchronizers: - &lt;0x000000076b9d7ae0&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)  ` </body>
		<created>2018-12-19 12:03:31</created>
		<closed>2019-01-31 02:06:09</closed>
	</bug>
	<bug>
		<id>2847</id>
		<title>Lexer-1.1.11发现的小瑕疵</title>
		<body>Lexer-1.1.11发现的小瑕疵 ![image](https://user-images.githubusercontent.com/20451356/46659473-93a8d780-cbe7-11e8-967d-b6388c83c3d3.png) </body>
		<created>2018-10-09 09:20:55</created>
		<closed>2019-01-31 02:05:32</closed>
	</bug>
	<bug>
		<id>2817</id>
		<title>sqlserver2008使用druid，页面【sql监控】功能报错。</title>
		<body>druid 开发者们、gtihub大神们，你们好！ # 错误信息      我在使用druid集成到 我自己的项目，页面上【sql监控】功能报错，错误图片如下 ![页面报错信息sql.html](http://ov19xq7pe.bkt.clouddn.com/druiderror.png) 若看不到图片请访问该http://ov19xq7pe.bkt.clouddn.com/druiderror.png 提示的错误信息如下 ```java java.lang.NullPointerException at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:701) at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:578) at com.alibaba.druid.wall.WallFilter.checkInternal(WallFilter.java:785) at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:780) at com.alibaba.druid.wall.WallFilter.statement_execute(WallFilter.java:413) at com.alibaba.druid.filter.FilterChainImpl.statement_execute(FilterChainImpl.java:2956) at com.alibaba.druid.filter.FilterAdapter.statement_execute(FilterAdapter.java:2473) at com.alibaba.druid.filter.FilterEventAdapter.statement_execute(FilterEventAdapter.java:188) at com.alibaba.druid.filter.FilterChainImpl.statement_execute(FilterChainImpl.java:2956) at com.alibaba.druid.proxy.jdbc.StatementProxyImpl.execute(StatementProxyImpl.java:147) at com.alibaba.druid.pool.vendor.MSSQLValidConnectionChecker.isValidConnection(MSSQLValidConnectionChecker.java:50) at com.alibaba.druid.pool.DruidAbstractDataSource.validateConnection(DruidAbstractDataSource.java:1346) at com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1633) at com.alibaba.druid.pool.DruidDataSource$CreateConnectionThread.run(DruidDataSource.java:2468) ```  # 配置信息 SpringBoot：2.0.5.RELEASE Jdk：1.8 druid版本：druid-spring-boot-starter  1.1.10 数据库：SQL Server 2008 R2 (SP3) - 10.50.6220.0 (X64)  配置文件： ```yml spring:   datasource:     type: com.alibaba.druid.pool.DruidDataSource     url: jdbc:sqlserver://localhost:1433;DatabaseName=***     username: sa     password: sa     druid:       validationQueryTimeout: 1       validationQuery: select 1       min-idle: 10       web-stat-filter:         url-pattern: /*         exclusions: '*.gif,*.png,*.jpg,*.html,*.js,*.css,*.ico,/druid/*'         enabled: true       max-active: 20       filters: stat,wall       poolPreparedStatements: true       max-wait: 10       filter:         stat:           slow-sql-millis: 5000           log-slow-sql: true       maxPoolPreparedStatementPerConnectionSize: 20       testWhileIdle: true       testOnBorrow: false       stat-view-servlet:         url-pattern: /druid/*         login-password: admin         reset-enable: false         login-username: admin         enabled: true       minEvictableIdleTimeMillis: 300000       timeBetweenEvictionRunsMillis: 60000       testOnReturn: false       initial-size: 5 ```</body>
		<created>2018-09-19 09:22:39</created>
		<closed>2018-09-20 05:48:27</closed>
	</bug>
	<bug>
		<id>2759</id>
		<title>Druid Spring Boot Starter 文档中有单词拼写错误</title>
		<body>@GetMapping("/durid/stat") 正确应是： @GetMapping("/druid/stat")</body>
		<created>2018-08-15 04:51:59</created>
		<closed>2018-09-03 01:15:19</closed>
	</bug>
	<bug>
		<id>2718</id>
		<title>Parser引用死循环</title>
		<body>```java import com.alibaba.druid.wall.WallProvider; import com.alibaba.druid.wall.WallCheckResult; import com.alibaba.druid.wall.WallConfig; import com.alibaba.druid.wall.spi.MySqlWallProvider; import com.alibaba.druid.wall.Violation;  import junit.framework.TestCase;  import java.util.List;  public class testDruid extends TestCase {      public void test_false() throws Exception{ //        String sql = "SELECT name, '******',user(),version(),system(),@@basedir,sleep(1) createTime from mysql.user where name like 'admin' AND (CASE WHEN (7885=7885) THEN 1 ELSE 0 END);select 1 from dual;"; //        String sql = "select sleep(1),char(22) from user where name like 'admin' AND '1'='1'";         String sql = "update task_info set priority = 1, content = 'x渓螼h\u0013[\u0014\u0006饆蜭�)漉=灔�\u000B\u0011\u0011u�\uE06A圥Z[\u0017殞c怈﹝櫃&amp;c摍0\u007Fj璟\u0004]JWRb峌膮埜\u0014譢\"瓺\\\\塼!.D牡玕\"邥\t� 佥篼緖.W=Rw4�\u001E3\t玭YF螭�\u0004�);\u0011�I\u0017�%\u0017谦漜f*\bm梄恀拒t)/�I�\"uSP蟉�\u0006I3\\\"�\u0016敐\f\\Z殷觀n\\\"餭讖;祵Y換g\uE5B7&amp;柋\u0017�\u0011﹗A欍媞(I=\u0010�x鐹�\u000B!蜿\u0006\u0013�lQw�(33毳圳倀!\uE324=&amp;释烃襲�&amp;b\uE1EF�\u0013mm孺L\u0014嚍_MS7湏痘笫滴;y鶲\b爱骤求秩G-\u001By~殿揀\uE222�\u0003鮝[�Dqo:蟎'~=裼�\u001F垴蟵\\rY�\u0013.\uE3F9R\u000E�\u0012滂燶n鑲�\u0002贛龎=\u0010ミ�\u0007/%�\u001C癳c�\u000E\\Z旊\u001B�\u000B2栣玄岜�#cc吜\uE6C5�\u001B嚮醽nx�\u001B巘肅輕4E鎊\u0018E\u0018跴欱貯i\u0007蘉渚秘\u0007c\u00129狓\u0004F\u001F\f\u0013�觠3\u000B��-XS8�\u0010�\u0019V\u001E諭餸�\u000Fk\\r|\u0014V\u0005躒_A彙?E�*�\u0015琔�\u001Ep共\u000B�\u0006Z\u001F�%楳�\u001D\u001C玾郳\"\uE26B\u0011�\u0006Jｊ\u0016h\u0005�\u001C�\u0002�\u0002�\u0004j貌`.�\u0001�\u0005韁\"�\u0006z佉\u0012�\u001CxQ�\u0007\u0017@呃-斵曼\\0k砛0k\u0003鬨Z\uE5E9\u007F\u0006^�\u000Es\u0005欳B�\f\\0\\0��+僜'�', attribute = 0, create_time = from_unixtime(1531714297) where id = 2726633030";          WallProvider provider = null;         provider = new MySqlWallProvider();          WallConfig config = provider.getConfig();          provider.getConfig().setConditionAndAlwayTrueAllow(false); //        provider.getConfig().setStrictSyntaxCheck(false);         provider.getConfig().setMultiStatementAllow(true);         provider.getConfig().setMultiStatementAllow(true);         provider.getConfig().setConditionAndAlwayFalseAllow(true);         provider.getConfig().setNoneBaseStatementAllow(true);         provider.getConfig().setLimitZeroAllow(true);         provider.getConfig().setConditionDoubleConstAllow(true);  //        provider.getConfig().setCommentAllow(true); //        provider.getConfig().setHintAllow(true);         provider.getConfig().setSelectIntoOutfileAllow(false);          try{             WallCheckResult result = provider.check(sql);  //            System.out.println(result.getViolations().toArray().toString());             List&lt;Violation&gt; list = result.getViolations();             for(Violation l:list){                 System.out.println("----------");                 System.out.println(l.toString());                 System.out.println("message:"+l.getMessage()+"\ncode:"+l.getErrorCode());             }              if (result.getViolations().size() &gt; 0)             {                 System.out.println("true");             }             else             {                 System.out.println("false");             }         }         catch(Exception e)         {             System.out.println("error");          }     } } ``` ![image](https://user-images.githubusercontent.com/7778764/42934401-aa8fe172-8b79-11e8-8d21-62611e1ee126.png)   </body>
		<created>2018-07-19 09:35:04</created>
		<closed>2018-07-26 06:03:17</closed>
	</bug>
	<bug>
		<id>2593</id>
		<title>mysql执行正常但是com.alibaba.druid.sql.parser.ParserException</title>
		<body>我的Sql：  select   product.brand_id,   product.lang_id,   product.product_id,   product.url_key,   product.model,   product.sku,   product.asin,   product.product_name,   product.short_name,   product.product_img,   product.status,   product.title,   product.keywords,   product.seo_desc,   product.description,   product.more_color,   product.master_color,   product.hot_flag,   product.new_flag,   product.deals_flag,   product.amz_desc,   product.amz_keywords,   product.amz_reviews,   product.amz_avg_star,   product.abtest,   product.sort,   product.old_product_id,   product.old_url_key,   categoryProduct.category_id from catalog_product as product, catalog_category_product as categoryProduct where product.brand_id = categoryProduct.brand_id and product.lang_id = categoryProduct.lang_id and       product.product_id = categoryProduct.product_id and product.brand_id = ? and product.lang_id = ? and       categoryProduct.category_id = ? and product.status = 1 and       product.more_color between (0 AND 1) and product.master_color = 1 order by product.sort asc  报错： com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'duct.master_color = 1 order by prod',expect EQ, actual EQ master_color  原因：between (0 AND 1)  between 0 AND 1 不带括号查询差别很大 </body>
		<created>2018-05-24 06:58:59</created>
		<closed>2018-05-27 13:28:45</closed>
	</bug>
	<bug>
		<id>2591</id>
		<title>MySQL Parse提示异常</title>
		<body>在使用Druid的语法解析器时，跑以下代码时：  ` @Test      public void getParseModifySqlTask() {             try {                 MySqlStatementParser parser = new MySqlStatementParser("ALTER TABLE `result` ADD INDEX `index_code` (`code`) USING BTREE;");                 parser.parseStatementList();             } catch (ParserException e) {                 e.printStackTrace();             }     } `  报出如下错误信息：  `  com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'SING BTREE;', expect IDENTIFIER, actual IDENTIFIER pos 58, line 1, column 59, token IDENTIFIER BTREE at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:423) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:72) at com.test.SqlUtilTest.getParseModifySqlTask(SqlUtilTest.java:44) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) ` 使用了1.1.7 和 1.1.9  都跑了一遍，问题依然存在。分析应该是在SQL解析时出现问题导致的。 删除后面的 USING BTREE，再跑一遍后错误不出现。  该条SQL是可以在MySQL上执行成功的。</body>
		<created>2018-05-22 07:51:53</created>
		<closed>2018-05-27 13:28:38</closed>
	</bug>
	<bug>
		<id>2588</id>
		<title>java.lang.ClassCastException: com.alibaba.druid.proxy.jdbc.ClobProxyImpl cannot be cast to oracle.sql.CLOB</title>
		<body>项目使用JPA 的hibernate实现，在进行EntityManager.merge时报错： `Caused by: java.lang.ClassCastException: com.alibaba.druid.proxy.jdbc.ClobProxyImpl cannot be cast to oracle.sql.CLOB at oracle.jdbc.driver.OraclePreparedStatement.setClob(OraclePreparedStatement.java:6805) at oracle.jdbc.driver.OraclePreparedStatementWrapper.setClob(OraclePreparedStatementWrapper.java:162) at com.alibaba.druid.filter.FilterChainImpl.preparedStatement_setClob(FilterChainImpl.java:3100) at com.alibaba.druid.filter.FilterAdapter.preparedStatement_setClob(FilterAdapter.java:1217) at com.alibaba.druid.filter.FilterChainImpl.preparedStatement_setClob(FilterChainImpl.java:3097) at com.alibaba.druid.filter.FilterAdapter.preparedStatement_setClob(FilterAdapter.java:1217) at com.alibaba.druid.filter.FilterChainImpl.preparedStatement_setClob(FilterChainImpl.java:3097) at com.alibaba.druid.proxy.jdbc.PreparedStatementProxyImpl.setClob(PreparedStatementProxyImpl.java:328) at com.alibaba.druid.pool.DruidPooledPreparedStatement.setClob(DruidPooledPreparedStatement.java:614) ... 34 more`</body>
		<created>2018-05-21 07:52:02</created>
		<closed>2018-05-27 13:28:26</closed>
	</bug>
	<bug>
		<id>2582</id>
		<title>SQL解析异常；MySQL drop多个字段，带有after关键字的语句，添加字段同时添加主键 报错！</title>
		<body>Version:1.1.9  API：  ```java SQLUtils.parseStatements(sql, JdbcConstants.MYSQL); ```  ------  sql1:  ```mysql ALTER TABLE test.student DROP Column9, DROP Column10; ```  exception1:  ```java com.alibaba.druid.sql.parser.ParserException: error pos 43, line 1, column 39, token DROP  at com.alibaba.druid.sql.parser.SQLExprParser.name(SQLExprParser.java:1348) at com.alibaba.druid.sql.parser.SQLExprParser.names(SQLExprParser.java:1237) at com.alibaba.druid.sql.parser.SQLExprParser.names(SQLExprParser.java:1218) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlterDrop(MySqlStatementParser.java:4104) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlterTable(MySqlStatementParser.java:3438) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlter(MySqlStatementParser.java:2789) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:191) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:72) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:464) ```  ------  sq2:  ```mysql ALTER TABLE `user_movement_log` ADD COLUMN GatewayId INT NOT NULL DEFAULT 0 AFTER `Regionid`; ```  exception2:  ```java com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'LT 0 AFTER `Regionid`;', expect IDENTIFIER, actual IDENTIFIER pos 81, line 1, column 76, token IDENTIFIER AFTER  at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:423) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:72) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:464) ```  ------  sql3:  ```mysql ALTER TABLE `user_movement_log` CHANGE `GatewayId` `GatewayId` INT NOT NULL DEFAULT 0 AFTER RegionID; ```  exception3:  ```java com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'ANGE `GatewayId` `GatewayId` INT NO', expect COLUMN, actual IDENTIFIER pos 50, line 1, column 39, token IDENTIFIER `GatewayId`  at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) at com.alibaba.druid.sql.parser.SQLParser.accept(SQLParser.java:292) at com.alibaba.druid.sql.parser.SQLStatementParser.parseAlter(SQLStatementParser.java:1180) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:191) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:72) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:464) ```  ------  sql4:  ```mysql ALTER TABLE test.student ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT, ADD PRIMARY KEY (c); ALTER TABLE test.student ADD c INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY; ```  exception4:  ```java com.alibaba.druid.sql.parser.ParserException: syntax error, error in :' INT UNSIGNED NOT NULL AUTO_INCREME', expect IDENTIFIER, actual IDENTIFIER pos 43, line 1, column 35, token IDENTIFIER UNSIGNED  at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:423) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:72) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:464) ```  </body>
		<created>2018-05-16 09:29:07</created>
		<closed>2018-05-27 13:28:51</closed>
	</bug>
	<bug>
		<id>2555</id>
		<title>H2数据库 Merge 语法解析异常</title>
		<body> @wenshao   2018-05-07 20:42:16,051 [Quartz Scheduler [adminQuartzScheduler]] INFO  o.s.scheduling.quartz.SchedulerFactoryBean -[SchedulerFactoryBean.java:708]- Starting Quartz Scheduler now, after delay of 10 seconds 2018-05-07 20:42:16,097 [Quartz Scheduler [adminQuartzScheduler]] ERROR com.alibaba.druid.filter.stat.StatFilter -[StatFilter.java:149]- merge sql error, dbType h2, druid-1.1.8, sql : SELECT * FROM QRTZ_LOCKS WHERE SCHED_NAME = 'adminQuartzScheduler' AND LOCK_NAME = ? FOR UPDATE com.alibaba.druid.sql.parser.ParserException: syntax error, error in :' = ? FOR UPDATE', expect FOR, actual FOR pos 88, line 1, column 85, token FOR at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:423) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:72) at com.alibaba.druid.sql.visitor.ParameterizedOutputVisitorUtils.parameterize(ParameterizedOutputVisitorUtils.java:88) at com.alibaba.druid.sql.visitor.ParameterizedOutputVisitorUtils.parameterize(ParameterizedOutputVisitorUtils.java:50) at com.alibaba.druid.filter.stat.StatFilter.mergeSql(StatFilter.java:147) at com.alibaba.druid.filter.stat.StatFilter.createSqlStat(StatFilter.java:648) at com.alibaba.druid.filter.stat.StatFilter.statementPrepareAfter(StatFilter.java:311) at com.alibaba.druid.filter.FilterEventAdapter.connection_prepareStatement(FilterEventAdapter.java:124) at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:473) at com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl.prepareStatement(ConnectionProxyImpl.java:342) at com.alibaba.druid.pool.DruidPooledConnection.prepareStatement(DruidPooledConnection.java:349) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.quartz.impl.jdbcjobstore.AttributeRestoringConnectionInvocationHandler.invoke(AttributeRestoringConnectionInvocationHandler.java:73) at com.sun.proxy.$Proxy140.prepareStatement(Unknown Source) at org.quartz.impl.jdbcjobstore.StdRowLockSemaphore.executeSQL(StdRowLockSemaphore.java:88) at org.quartz.impl.jdbcjobstore.DBSemaphore.obtainLock(DBSemaphore.java:113) at org.quartz.impl.jdbcjobstore.JobStoreSupport.doCheckin(JobStoreSupport.java:3320) at org.quartz.impl.jdbcjobstore.JobStoreSupport$ClusterManager.manage(JobStoreSupport.java:3920) at org.quartz.impl.jdbcjobstore.JobStoreSupport$ClusterManager.initialize(JobStoreSupport.java:3905) at org.quartz.impl.jdbcjobstore.JobStoreSupport.schedulerStarted(JobStoreSupport.java:692) at org.quartz.core.QuartzScheduler.start(QuartzScheduler.java:539) at org.quartz.impl.StdScheduler.start(StdScheduler.java:142) at org.springframework.scheduling.quartz.SchedulerFactoryBean$1.run(SchedulerFactoryBean.java:711) 2018-05-07 20:42:16,129 [Quartz Scheduler [adminQuartzScheduler]] INFO  o.s.scheduling.quartz.LocalDataSourceJobStore -[JobStoreSupport.java:3629]- ClusterManager: detected 1 failed or restarted instances. 2018-05-07 20:42:16,129 [Quartz Scheduler [adminQuartzScheduler]] INFO  o.s.scheduling.quartz.LocalDataSourceJobStore -[JobStoreSupport.java:3488]- ClusterManager: Scanning for instance "Jeping-PC1525681694826"'s failed in-progress jobs. 2018-05-07 20:42:16,144 [Quartz Scheduler [adminQuartzScheduler]] INFO  org.quartz.core.QuartzScheduler -[QuartzScheduler.java:547]- Scheduler adminQuartzScheduler_$_jiaenping1525696922924 started.</body>
		<created>2018-05-07 13:08:12</created>
		<closed>2018-05-28 02:09:35</closed>
	</bug>
	<bug>
		<id>2549</id>
		<title>Oracle分页查询下一页时出现语法解析错误  com.alibaba.druid.sql.parser.ParserException: syntax error, expect FIRST, actual NEXT, pos 1173, line 1, column 1169, token NEXT</title>
		<body>运行语句是：SELECT specialact0_. ID AS id1_14_, specialact0_.gmt_create AS gmt_create2_14_, specialact0_.gmt_modified AS gmt_modified3_14_, specialact0_.issuer AS issuer4_14_, specialact0_.prisonarea AS prisonarea5_14_, specialact0_.prisonarea_code AS prisonarea_code6_14_, specialact0_. NAME AS name7_14_, specialact0_.prison AS prison8_14_, specialact0_.synopsis AS synopsis9_14_, specialact0_.sys_orgcode AS sys_orgcode10_14_, specialact0_.sys_orgname AS sys_orgname11_14_, specialact0_.sys_permname AS sys_permname12_14_, specialact0_.sys_perrmcode AS sys_perrmcode13_14_, specialact0_. TIMES AS times14_14_ FROM hs_special_activities specialact0_ WHERE 1 = 1 offset ? ROWS FETCH NEXT ? ROWS ONLY</body>
		<created>2018-05-03 06:57:32</created>
		<closed>2018-05-27 13:29:09</closed>
	</bug>
	<bug>
		<id>2548</id>
		<title>使用SQL拦截和解析遇见的一些问题</title>
		<body>SQL拦截 配置项 : AlterTableAllow 是否允许执行Alter Table语句    Mysql 语句可以过 拦截生效  db2 语法解析未通过TODO pos 58, line 1, column 54, token IDENTIFIER data   SQL语句: alter table audit.SQLHIS alter column  EXPLAINMSG set data type VARCHAR(255)  配置项 : ReplaceAllow 是否允许执行REPLACE语句 语法解析通过  拦截不生效 SQL语句: select replace(name,'li','lili') from a.test;  配置项 :   SelectWhereAlwayTrueCheck  UpdateWhereAlayTrueCheck    拦截WHERE为永真条件         语法解析通过  拦截不生效 SQL语句: select * from A where 1 = 1 ; update audit.USER2 SET  TEL='110' WHERE 100=100;  配置项 :     SelectUnionCheck检测SELECT UNION 语法解析通过  拦截不生效 select name from china_employees union select name from usa_employees;  配置项 :SelectMinusCheck检测SELECT MINUS 语法解析通过  拦截不生效 SQL语句:SELECT Date FROM Store_Information MINUS SELECT Date FROM Internet_Sales;  配置项 :SelectExceptCheck检测SELECT EXCEPT         语法解析通过  拦截不生效 SQL语句:select * from a except select * form b;  配置项 :SelectIntersectCheck检测SELECT INTERSECT         语法解析通过  拦截不生效 SQL语句:SELECT Txn_Date FROM Store_Information INTERSECT SELECT Txn_Date FROM Internet_Sales;  配置项 :ConditionDoubleConstAllow查询条件中是否允许连续两个常量运算表达式         语法解析通过  拦截不生效 SQL语句:SELECT FID = 3 - 1，ID = 3 - 1 from A;  (下列  疑问   具体怎么使用) NoneBaseStatementAllow是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽DDL。 CommitAllow是否允许执行commit操作 RollbackAllow是否允许执行roll back操作 ConditionOpBitwseAllow查询条件中是否允许有'&amp;'、'~'、'|'、'^'运算符。  SQL解析 语句 SQL merge intoSQL解析GG MERGE INTO EMPLOYE AS EM   USING MANAGER AS MA  ON EM.EMPLOYEID=MA.MANAGERID  WHEN MATCHED AND EM.SALARY&lt;MA.SALARY THEN UPDATE SET EM.SALARY=MA.SALARY  WHEN MATCHED AND EM.SALARY&gt;MA.SALARY THEN SIGNAL SQLSTATE '70001' SET MESSAGE_TEXT = 'EM.SALARY&gt;MA.SALARY' WHEN NOT MATCHED THEN INSERT VALUES (MA.MANAGERID,MA.NAME,MA.SALARY)  ELSE IGNORE;  语句 SQL limitSQL解析GG select * from Customer LIMIT 10;</body>
		<created>2018-05-03 06:27:22</created>
		<closed>2018-05-27 13:29:02</closed>
	</bug>
	<bug>
		<id>2546</id>
		<title>support statistics for executeQuery/execute/executeUpdate/executeBatch</title>
		<body>I need to get each execution count of executeQuery, execute, executeUpdate and executeBatch</body>
		<created>2018-05-02 09:07:51</created>
		<closed>2018-05-27 13:29:19</closed>
	</bug>
	<bug>
		<id>2544</id>
		<title>使用wall过滤器后，出现sql injection violation错误</title>
		<body>版本信息 ```        &lt;dependency&gt;             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;             &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;             &lt;version&gt;1.1.9&lt;/version&gt;         &lt;/dependency&gt; ```  sql语句如下 ``` select count(0) from (SELECT * FROM auth_tenant WHERE type = 'tenant' AND name LIKE ?"%") tmp_count  ```  错误如下 ``` ### Error querying database.  Cause: java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'name LIKE ?"%") tmp_count', expect RPAREN, actual LITERAL_ALIAS pos 162, line 8, column 29, token LITERAL_ALIAS "%" : select count(0) from (SELECT             *         FROM             auth_tenant         WHERE             type = 'tenant'                       AND name LIKE ?"%") tmp_count ```  以及部分异常堆栈信息 ``` Caused by: java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'name LIKE ?"%") tmp_count', expect RPAREN, actual LITERAL_ALIAS pos 162, line 8, column 29, token LITERAL_ALIAS "%" : select count(0) from (SELECT             *         FROM             auth_tenant         WHERE             type = 'tenant'                       AND name LIKE ?"%") tmp_count at com.alibaba.druid.wall.WallFilter.checkInternal(WallFilter.java:798) at com.alibaba.druid.wall.WallFilter.connection_prepareStatement(WallFilter.java:251) at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:473) at com.alibaba.druid.filter.FilterAdapter.connection_prepareStatement(FilterAdapter.java:929) at com.alibaba.druid.filter.FilterEventAdapter.connection_prepareStatement(FilterEventAdapter.java:122) at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:473) at com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl.prepareStatement(ConnectionProxyImpl.java:342) at com.alibaba.druid.pool.DruidPooledConnection.prepareStatement(DruidPooledConnection.java:349) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.ibatis.logging.jdbc.ConnectionLogger.invoke(ConnectionLogger.java:55) at com.sun.proxy.$Proxy162.prepareStatement(Unknown Source) at org.apache.ibatis.executor.statement.PreparedStatementHandler.instantiateStatement(PreparedStatementHandler.java:87) at org.apache.ibatis.executor.statement.BaseStatementHandler.prepare(BaseStatementHandler.java:88) at org.apache.ibatis.executor.statement.RoutingStatementHandler.prepare(RoutingStatementHandler.java:59) at org.apache.ibatis.executor.SimpleExecutor.prepareStatement(SimpleExecutor.java:85) at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:62) at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:326) at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109) at com.github.pagehelper.PageInterceptor.executeAutoCount(PageInterceptor.java:201) at com.github.pagehelper.PageInterceptor.intercept(PageInterceptor.java:113) at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:61) at com.sun.proxy.$Proxy161.query(Unknown Source) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:433) ... 81 common frames omitted Caused by: com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'name LIKE ?"%") tmp_count', expect RPAREN, actual LITERAL_ALIAS pos 162, line 8, column 29, token LITERAL_ALIAS "%" at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) at com.alibaba.druid.sql.parser.SQLParser.accept(SQLParser.java:292) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlSelectParser.parseTableSource(MySqlSelectParser.java:229) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlSelectParser.parseFrom(MySqlSelectParser.java:75) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlSelectParser.query(MySqlSelectParser.java:174) at com.alibaba.druid.sql.parser.SQLSelectParser.select(SQLSelectParser.java:59) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseSelect(MySqlStatementParser.java:113) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:149) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:83) at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:624) at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:578) at com.alibaba.druid.wall.WallFilter.checkInternal(WallFilter.java:785) ... 113 common frames omitted  ```  </body>
		<created>2018-05-02 03:17:19</created>
		<closed>2018-05-27 13:29:14</closed>
	</bug>
	<bug>
		<id>2512</id>
		<title>不支持Mysql8.0.11的XA</title>
		<body>`Caused by: java.sql.SQLFeatureNotSupportedException: null    at com.alibaba.druid.util.MySqlUtils.createXAConnection(MySqlUtils.java:165)   at com.alibaba.druid.pool.xa.DruidXADataSource.createPhysicalXAConnection(DruidXADataSource.java:72)   at com.alibaba.druid.pool.xa.DruidXADataSource.getXAConnection(DruidXADataSource.java:48)   at com.atomikos.jdbc.AtomikosXAConnectionFactory.createPooledConnection(AtomikosXAConnectionFactory.java:43)`</body>
		<created>2018-04-20 02:14:01</created>
		<closed>2018-04-23 00:39:45</closed>
	</bug>
	<bug>
		<id>2510</id>
		<title>SchemaStatVisitor 解析hive 多路输出表，部分列缺失表明。</title>
		<body>FROM sale_detail INSERT OVERWRITE TABLE sale_detail_multi partition (sale_date='2010', region='china' ) SELECT shop_name, customer_id, total_price INSERT OVERWRITE TABLE sale_detail_multi partition (sale_date='2010', region='china' ) SELECT shop_name, customer_id, total_price;  输出列信息：[sale_detail_multi.sale_date, sale_detail_multi.region, UNKNOWN.shop_name, UNKNOWN.customer_id, UNKNOWN.total_price]</body>
		<created>2018-04-19 11:42:29</created>
		<closed>2018-05-27 13:29:54</closed>
	</bug>
	<bug>
		<id>2509</id>
		<title>SchemaStatVisitor 解析query 语句，保留 * 信息</title>
		<body>做sql 列权限校验，需要知道所有查询的列，例如这个sql： select * from table1 a left outer join table2 b on a.id=b.id 会读取两个表的所有列，columns中能够加上table1.* , table2.*</body>
		<created>2018-04-19 11:38:01</created>
		<closed>2018-05-27 13:29:49</closed>
	</bug>
	<bug>
		<id>2497</id>
		<title>解析Oracle SQL报错</title>
		<body>Druid Version: 1.1.9  SQL： SELECT J01.COL_A, J01.COL_B, "SUM"(J01.COL_C) OVER ( PARTITION BY J01.COL_A ORDER BY J01.COL_B NULLS FIRST ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW ) AS COL_C FROM TAB_A J01  java： package com.xiaolong.druid;  import com.alibaba.druid.sql.ast.SQLStatement; import com.alibaba.druid.sql.dialect.oracle.parser.OracleStatementParser; import com.alibaba.druid.sql.dialect.oracle.visitor.OracleSchemaStatVisitor; import com.alibaba.druid.sql.parser.SQLStatementParser;  // 测试druid public class Test_Druid_Sql {  public static void main(String[] args) { String sql = "SELECT\r\n" +  "J01.COL_A,\r\n" +  "J01.COL_B,\r\n" +  "\"SUM\"(J01.COL_C) OVER (\r\n" +  "PARTITION BY J01.COL_A ORDER BY J01.COL_B NULLS FIRST ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\r\n" +  ") AS COL_C\r\n" +  "FROM\r\n" +  "TAB_A J01\r\n" +  "";  // 新建 ORACLE Parser SQLStatementParser parser = new OracleStatementParser(sql);  // 使用Parser解析生成AST，这里SQLStatement就是AST SQLStatement statement = parser.parseStatement();  // 使用visitor来访问AST OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor(); statement.accept(visitor);  System.out.println(visitor.getTables()); }  }  报错： Exception in thread "main" com.alibaba.druid.sql.parser.ParserException: ERROR. pos 138, line 5, column 64, token BETWEEN at com.alibaba.druid.sql.parser.SQLExprParser.primary(SQLExprParser.java:793) at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.primary(OracleExprParser.java:462) at com.alibaba.druid.sql.parser.SQLExprParser.expr(SQLExprParser.java:86) at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.parseAggregateExpr(OracleExprParser.java:834) at com.alibaba.druid.sql.parser.SQLExprParser.methodRest(SQLExprParser.java:1051) at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.methodRest(OracleExprParser.java:500) at com.alibaba.druid.sql.parser.SQLExprParser.primaryRest(SQLExprParser.java:960) at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.primaryRest(OracleExprParser.java:668) at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.primary(OracleExprParser.java:314) at com.alibaba.druid.sql.parser.SQLExprParser.expr(SQLExprParser.java:86) at com.alibaba.druid.sql.parser.SQLExprParser.parseSelectItem(SQLExprParser.java:3061) at com.alibaba.druid.sql.parser.SQLSelectParser.parseSelectList(SQLSelectParser.java:508) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.query(OracleSelectParser.java:299) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.select(OracleSelectParser.java:75) at com.alibaba.druid.sql.parser.SQLStatementParser.parseSelect(SQLStatementParser.java:2412) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatement(SQLStatementParser.java:2686) at com.xiaolong.druid.Test_Druid_Sql.main(Test_Druid_Sql.java:26) </body>
		<created>2018-04-17 02:22:58</created>
		<closed>2018-05-27 13:29:25</closed>
	</bug>
	<bug>
		<id>2489</id>
		<title>语法解析，DB2 建表语句解析失败</title>
		<body>版本：1.1.9 语句： ` SQLUtils.parseStatements(" CREATE TABLE AUDIT.test ( ID INTEGER NOT NULL GENERATED ALWAYS AS IDENTITY (START WITH 1, INCREMENT BY 1 ))", JdbcConstants.DB2); ` 异常信息： `Exception in thread "main" com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'NULL GENERATED ALWAYS AS IDENTITY (', expect RPAREN, actual IDENTIFIER pos 56, line 1, column 47, token IDENTIFIER GENERATED at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) at com.alibaba.druid.sql.parser.SQLParser.accept(SQLParser.java:292) at com.alibaba.druid.sql.dialect.db2.parser.DB2CreateTableParser.parseCreateTable(DB2CreateTableParser.java:113) at com.alibaba.druid.sql.parser.SQLStatementParser.parseCreate(SQLStatementParser.java:2025) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:161) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:72) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:464)` </body>
		<created>2018-04-13 08:34:09</created>
		<closed>2018-05-27 13:30:05</closed>
	</bug>
	<bug>
		<id>2488</id>
		<title>druid+postgres，不支持窗口函数</title>
		<body>版本: 1.1.9  sql语句： select a.*, (a.swanav-lead(a.swanav,1,null::numeric) over w)/lead(a.swanav,1,null::numeric) over w as roe_lag  from ffund.ffund_eval_prod_nv a  where a.prod_id='D20171206191156525S0034R234'  and a.stat_date&gt;='0000-00-00'  and a.stat_date&lt;='9999-99-99'  and a.nav&gt;0 and a.swanav&gt;0  window w as (order by a.stat_date desc) 报错信息： syntax error: syntax error, expect LPAREN, actual IDENTIFIER pos 145, line 1, column 145, token IDENTIFIER w</body>
		<created>2018-04-13 08:25:23</created>
		<closed>2018-05-27 13:30:11</closed>
	</bug>
	<bug>
		<id>2487</id>
		<title>语法解析，DB2 不支持 SELECT INTO</title>
		<body>版本1.1.9 如下语句解析出错 `SQLUtils.parseStatements("SELECT * INTO Persons_backup FROM Persons", JdbcConstants.DB2);` 异常 `Exception in thread "main" com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'CT * INTO Persons_backup FROM Perso', expect INTO, actual INTO pos 13, line 1, column 9, token INTO at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:423) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:72) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:464)`</body>
		<created>2018-04-13 08:21:42</created>
		<closed>2018-05-27 13:30:00</closed>
	</bug>
	<bug>
		<id>2484</id>
		<title>postgresql 中 string_agg(pd.f_dic_name, ',' order by pd.f_dic_name)的语法不支持</title>
		<body></body>
		<created>2018-04-12 06:49:16</created>
		<closed>2018-05-27 13:30:25</closed>
	</bug>
	<bug>
		<id>2483</id>
		<title>sql解析报错</title>
		<body>druid-spring-boot-starter.version&gt;1.1.6 h2.version&gt;1.4.193 sql: ` alter table ACT_GE_BYTEARRAY     add constraint ACT_FK_BYTEARR_DEPL      foreign key (DEPLOYMENT_ID_)      references ACT_RE_DEPLOYMENT (ID_); ` exception: ` 2018-04-12 14:20:25.904 [main] ERROR o.a.engine.impl.db.DbSqlSession - problem during schema create, statement alter table ACT_GE_BYTEARRAY  add constraint ACT_FK_BYTEARR_DEPL  foreign key (DEPLOYMENT_ID_)  references ACT_RE_DEPLOYMENT  java.sql.SQLException: sql injection violation, syntax error: syntax error, expect LPAREN, actual EOF pos 124, line 4, column 30, token EOF : alter table ACT_GE_BYTEARRAY  add constraint ACT_FK_BYTEARR_DEPL  foreign key (DEPLOYMENT_ID_)  references ACT_RE_DEPLOYMENT at com.alibaba.druid.wall.WallFilter.checkInternal(WallFilter.java:798) at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:780) at com.alibaba.druid.wall.WallFilter.statement_execute(WallFilter.java:413) at com.alibaba.druid.filter.FilterChainImpl.statement_execute(FilterChainImpl.java:2598) at com.alibaba.druid.filter.FilterAdapter.statement_execute(FilterAdapter.java:2473) at com.alibaba.druid.filter.FilterEventAdapter.statement_execute(FilterEventAdapter.java:188) at com.alibaba.druid.filter.FilterChainImpl.statement_execute(FilterChainImpl.java:2598) at com.alibaba.druid.proxy.jdbc.StatementProxyImpl.execute(StatementProxyImpl.java:147) at com.alibaba.druid.pool.DruidPooledStatement.execute(DruidPooledStatement.java:558) at org.activiti.engine.impl.db.DbSqlSession.executeSchemaResource(DbSqlSession.java:1216) at org.activiti.engine.impl.db.DbSqlSession.executeSchemaResource(DbSqlSession.java:1138) at org.activiti.engine.impl.db.DbSqlSession.executeMandatorySchemaResource(DbSqlSession.java:897) at org.activiti.engine.impl.db.DbSqlSession.dbSchemaCreateEngine(DbSqlSession.java:874) at org.activiti.engine.impl.db.DbSqlSession.dbSchemaUpdate(DbSqlSession.java:952) at org.activiti.engine.impl.db.DbSqlSession.performSchemaOperationsProcessEngineBuild(DbSqlSession.java:1318) at org.activiti.engine.impl.SchemaOperationsProcessEngineBuild.execute(SchemaOperationsProcessEngineBuild.java:28) at org.activiti.engine.impl.interceptor.CommandInvoker$1.run(CommandInvoker.java:37) at org.activiti.engine.impl.interceptor.CommandInvoker.executeOperation(CommandInvoker.java:78) at org.activiti.engine.impl.interceptor.CommandInvoker.executeOperations(CommandInvoker.java:57) at org.activiti.engine.impl.interceptor.CommandInvoker.execute(CommandInvoker.java:42) at org.activiti.engine.impl.interceptor.TransactionContextInterceptor.execute(TransactionContextInterceptor.java:48) at org.activiti.engine.impl.interceptor.CommandContextInterceptor.execute(CommandContextInterceptor.java:63) at org.activiti.spring.SpringTransactionInterceptor$1.doInTransaction(SpringTransactionInterceptor.java:47) at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:133) at org.activiti.spring.SpringTransactionInterceptor.execute(SpringTransactionInterceptor.java:45) at org.activiti.engine.impl.interceptor.LogInterceptor.execute(LogInterceptor.java:29) at org.activiti.engine.impl.cfg.CommandExecutorImpl.execute(CommandExecutorImpl.java:44) at org.activiti.engine.impl.ProcessEngineImpl.&lt;init&gt;(ProcessEngineImpl.java:81) at org.activiti.engine.impl.cfg.ProcessEngineConfigurationImpl.buildProcessEngine(ProcessEngineConfigurationImpl.java:665) at org.activiti.spring.SpringProcessEngineConfiguration.buildProcessEngine(SpringProcessEngineConfiguration.java:65) at org.activiti.spring.ProcessEngineFactoryBean.getObject(ProcessEngineFactoryBean.java:57) at org.activiti.spring.ProcessEngineFactoryBean.getObject(ProcessEngineFactoryBean.java:32) at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:168) at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.getObjectFromFactoryBean(FactoryBeanRegistrySupport.java:103) at org.springframework.beans.factory.support.AbstractBeanFactory.getObjectForBeanInstance(AbstractBeanFactory.java:1634) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:317) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:208) at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1138) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066) at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:835) at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:741) at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:467) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1173) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1067) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:208) at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1138) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066) at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:835) at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:741) at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:467) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1173) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1067) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:519) at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeansOfType(DefaultListableBeanFactory.java:508) at org.springframework.context.support.AbstractApplicationContext.getBeansOfType(AbstractApplicationContext.java:1189) at org.springframework.beans.factory.BeanFactoryUtils.beansOfTypeIncludingAncestors(BeanFactoryUtils.java:261) at org.springframework.boot.actuate.endpoint.mvc.MvcEndpoints.afterPropertiesSet(MvcEndpoints.java:59) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1687) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1624) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197) at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:381) at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration$$EnhancerBySpringCGLIB$$f74c0752.mvcEndpoints(&lt;generated&gt;) at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration.endpointHandlerMapping(EndpointWebMvcManagementContextConfiguration.java:82) at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration$$EnhancerBySpringCGLIB$$f74c0752.CGLIB$endpointHandlerMapping$1(&lt;generated&gt;) at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration$$EnhancerBySpringCGLIB$$f74c0752$$FastClassBySpringCGLIB$$2656fb8d.invoke(&lt;generated&gt;) at org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:228) at org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:356) at org.springframework.boot.actuate.autoconfigure.EndpointWebMvcManagementContextConfiguration$$EnhancerBySpringCGLIB$$f74c0752.endpointHandlerMapping(&lt;generated&gt;) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162) at org.springframework.beans.factory.support.ConstructorResolver.instantiateUsingFactoryMethod(ConstructorResolver.java:588) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateUsingFactoryMethod(AbstractAutowireCapableBeanFactory.java:1173) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1067) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:208) at org.springframework.beans.factory.support.DefaultListableBeanFactory.addCandidateEntry(DefaultListableBeanFactory.java:1309) at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1275) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveMultipleBeans(DefaultListableBeanFactory.java:1180) at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1096) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066) at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:835) at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:741) at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1193) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1095) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:208) at org.springframework.beans.factory.support.DefaultListableBeanFactory.addCandidateEntry(DefaultListableBeanFactory.java:1309) at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1275) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveMultipleBeans(DefaultListableBeanFactory.java:1180) at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1096) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066) at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:835) at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:741) at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1193) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1095) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:866) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542) at org.springframework.boot.context.embedded.EmbeddedWebApplicationContext.refresh(EmbeddedWebApplicationContext.java:122) at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:762) at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:372) at org.springframework.boot.SpringApplication.run(SpringApplication.java:316) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1187) at org.springframework.boot.SpringApplication.run(SpringApplication.java:1176) at com.lawu.eshop.workflow.engine.srv.WorkflowEngineSrvApplication.main(WorkflowEngineSrvApplication.java:21) Caused by: com.alibaba.druid.sql.parser.ParserException: syntax error, expect LPAREN, actual EOF pos 124, line 4, column 30, token EOF at com.alibaba.druid.sql.parser.SQLExprParser.accept(SQLExprParser.java:2453) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlExprParser.parseForeignKey(MySqlExprParser.java:798) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlterTable(MySqlStatementParser.java:3483) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlter(MySqlStatementParser.java:2758) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:189) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:81) at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:624) at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:578) at com.alibaba.druid.wall.WallFilter.checkInternal(WallFilter.java:785) ... 143 common frames omitted `</body>
		<created>2018-04-12 06:32:08</created>
		<closed>2018-05-27 13:30:18</closed>
	</bug>
	<bug>
		<id>2474</id>
		<title>这个SQL可以在sql客户端执行 , 不知道拦截是因为效率还是因为解析SQL出错. </title>
		<body>最新的jar包: druid:1.1.9 &lt;pre&gt; SELECT id,   MAX(myRank) area FROM   (SELECT t2.id ,     wmsys.wm_concat(t2.name) over (partition BY t2.id order by to_number(t2.cc) ASC ) myRank   FROM     (SELECT adr.name,       t1.*     FROM       (SELECT t.id,         t.addresscode,         regexp_substr(t.addresscode, '[^_]+', 1, x.n) cc       FROM         ( SELECT id,addresscode FROM srm1.CONSIGNEE_ADDRESS ca         ) t,         (SELECT ROWNUM n FROM dual CONNECT BY ROWNUM &lt;= 5         ) x       ORDER BY 1       ) t1     LEFT JOIN srm1.address adr     ON adr.id    = t1.cc     WHERE t1.cc IS NOT NULL     ) t2   ) GROUP BY id &lt;/pre&gt;  一个列转行  然后 关联翻译 最后wm_concat再行转列 加入 over  partition by 是为了正确的排序  例如: 16_1303_1312_48816  福建,福州市,罗源县,罗源湾    这个SQL可以在sql客户端执行 , 不知道拦截是因为效率还是因为解析SQL出错.     PS:这段只是一部分. 由主表根据ID来JOIN.    Caused by: com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'ame) over (partition by t2.id order',expect RPAREN, actual OVER over at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:230) at com.alibaba.druid.sql.parser.SQLParser.accept(SQLParser.java:239) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.parseTableSource(OracleSelectParser.java:717) at com.alibaba.druid.sql.parser.SQLSelectParser.parseFrom(SQLSelectParser.java:316) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.query(OracleSelectParser.java:272) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.select(OracleSelectParser.java:88) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.parseTableSource(OracleSelectParser.java:711) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.parseTableSourceRest(OracleSelectParser.java:954) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.parseTableSourceRest(OracleSelectParser.java:966) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.parseTableSourceRest(OracleSelectParser.java:966) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.parseTableSourceRest(OracleSelectParser.java:966) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.parseTableSourceRest(OracleSelectParser.java:966) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.parseTableSource(OracleSelectParser.java:741) at com.alibaba.druid.sql.parser.SQLSelectParser.parseFrom(SQLSelectParser.java:316) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.query(OracleSelectParser.java:272) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.select(OracleSelectParser.java:88) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.parseTableSource(OracleSelectParser.java:711) at com.alibaba.druid.sql.parser.SQLSelectParser.parseFrom(SQLSelectParser.java:316) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.query(OracleSelectParser.java:272) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.select(OracleSelectParser.java:88) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.parseTableSource(OracleSelectParser.java:711) at com.alibaba.druid.sql.parser.SQLSelectParser.parseFrom(SQLSelectParser.java:316) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.query(OracleSelectParser.java:272) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.select(OracleSelectParser.java:88) at com.alibaba.druid.sql.dialect.oracle.parser.OracleStatementParser.parseStatementList(OracleStatementParser.java:164) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:121) at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:620) at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:574) at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:699) ... 85 more </body>
		<created>2018-04-10 03:50:04</created>
		<closed>2018-05-27 13:30:34</closed>
	</bug>
	<bug>
		<id>2460</id>
		<title>关于Druid运算操作符优先级的错误</title>
		<body>Mysql官网上对运算操作符优先级是如下定义的 ![image](https://user-images.githubusercontent.com/12388190/38245342-4f563a70-3770-11e8-850f-7f9469b9bcdf.png) 我测试如下条件 ![image](https://user-images.githubusercontent.com/12388190/38245383-750fe32e-3770-11e8-8922-259ad22d2094.png) 在druid解析出来之后发现 ![image](https://user-images.githubusercontent.com/12388190/38245447-b171a79e-3770-11e8-9e05-56b6f7ee9221.png) xor的优先级应该比or要高的，不知道druid是如何考虑的。</body>
		<created>2018-04-03 10:57:00</created>
		<closed>2018-05-27 13:30:58</closed>
	</bug>
	<bug>
		<id>2458</id>
		<title>db2数据库解析CURRENT DATE异常 </title>
		<body>使用版本1.1.9 解析这个是异常的 SELECT CURRENT DATE FROM SYSIBM.SYSDUMMY1 解析这个是正常的(加了下划线) SELECT CURRENT_DATE FROM SYSIBM.SYSDUMMY1 希望可以兼容下，谢谢</body>
		<created>2018-04-03 07:58:03</created>
		<closed>2018-04-08 03:45:54</closed>
	</bug>
	<bug>
		<id>2452</id>
		<title>sql parser 对mysql字符串支持不够</title>
		<body>/com/alibaba/druid/sql/parser/Lexer.java的 1、scanString2_d()方法 1251行判断字符串结束好像有问题，感觉应该用双引号才对？ 2、scanString 方法对 mysql的支持不全，mysql里面 \ 也是可以转义的。</body>
		<created>2018-04-01 14:14:46</created>
		<closed>2018-05-27 13:30:52</closed>
	</bug>
	<bug>
		<id>2446</id>
		<title>PostgreSQL内存表解析报错</title>
		<body>druid 1.1.9  PostgreSQL用到内存表的SQL解析会报错，比如： `String sql = "delete from account a using (values (1), (7)) as tmp(id) WHERE a.id = tmp.id";`  `String sql = "update student a set grade = tmp.grade from (values (1, 'A')) as tmp(id, grade) where a.id = tmp.id";`</body>
		<created>2018-03-30 02:17:53</created>
		<closed>2018-05-27 13:31:08</closed>
	</bug>
	<bug>
		<id>2444</id>
		<title>union语句经解析后，和原来的语句的语义不一样了。</title>
		<body>原语句：select a, b from a1 union select a, b from b1 order by a   解析后：SELECT a, b FROM a1 UNION (SELECT a, b FROM b1 ORDER BY a)</body>
		<created>2018-03-30 01:50:57</created>
		<closed>2018-05-27 13:31:18</closed>
	</bug>
	<bug>
		<id>2443</id>
		<title>SQL 解析错误</title>
		<body>18:22:57.610 [main] ERROR com.alibaba.druid.filter.stat.StatFilter - merge sql error, dbType clickhouse, druid-1.1.9, sql : SELECT date, transactionChannel, tranactionType FROM preComp_3All_20180322  limit 1,10 com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'imit 1,10', expect LITERAL_INT, actual LITERAL_INT pos 83, line 1, column 82, token LITERAL_INT at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) ~[druid-1.1.9.jar:1.1.9]</body>
		<created>2018-03-29 10:44:35</created>
		<closed>2018-05-27 13:31:13</closed>
	</bug>
	<bug>
		<id>2433</id>
		<title>druid不支持解析阿里的drds分库分表语法！！！</title>
		<body>## 如下，为一个drds数据库分库分表的建表语句：  _create table ARCHIVE_ERR_RECORD (    SUBS_ORDER_ID        numeric(18,0) not null comment '订单编号',    ERR_MSG              text comment '失败的消息结构',    ERR_REASON           varchar(255) comment '失败原因',    PART_ID              integer not null comment '分区标识（取订单编号中的月份）' ) DBPARTITION BY HASH(SUBS_ORDER_ID) TBPARTITION BY UNI_HASH(PART_ID) TBPARTITIONS 12;_  ## 调用druid的sql解析方法： List&lt;SQLStatement&gt; stmtList = SQLUtils.parseStatements(sql, JdbcConstants.ALIYUN_DRDS);  ## 执行抛出异常：  Exception in thread "main" com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'）' ) DBPARTITION BY HASH(SUBS_ORDER', expect IDENTIFIER, actual IDENTIFIER pos 278, line 7, column 3, token IDENTIFIER DBPARTITION at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:423) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:72) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:464) at org.dts.test.TestSql.splitSql(TestSql.java:27) at org.dts.test.TestSql.main(TestSql.java:40)  </body>
		<created>2018-03-26 10:06:58</created>
		<closed>2018-05-27 13:31:03</closed>
	</bug>
	<bug>
		<id>2424</id>
		<title>DB2驱动名问题</title>
		<body>com.alibaba.druid.util.JdbcConstants.DB2_DRIVER="COM.ibm.db2.jdbc.app.DB2Driver";  应该改成：com.ibm.db2.jcc.DB2Driver 谢谢！</body>
		<created>2018-03-22 08:13:51</created>
		<closed>2018-04-02 07:15:29</closed>
	</bug>
	<bug>
		<id>2422</id>
		<title>BUG，visitor.getConditions()解析出来缺少 DATE_FORMAT(add_time, '%Y-%m-%d')</title>
		<body>SQL:  ```sql SELECT id AS id, activity_code AS activityCode, activity_name AS activityName, start_time AS startTime, end_time AS endTime, `state`, bonus_type AS bonusType, send_num AS sendNum, points, exchange_flag AS exchangeFlag, exchange_points AS exchangePoints, auth_code_key AS authCodeKey, auth_code_key_repeat AS authCodeKeyRepeat, `type`, mobile_flag AS mobileFlag, activity_code_list AS activityCodeList, register_product_id AS registerProductId, add_user AS addUser, add_time AS addTime, mod_user AS modUser, delete_flag AS deleteFlag FROM tb_activity WHERE id != 1 AND id NOT IN (1, 2) and DATE_FORMAT(add_time, '%Y-%m-%d') = '2018-08-08'; ```  ```java  List&lt;SQLStatement&gt; stmtList = SQLUtils.parseStatements(sql, JdbcConstants.MYSQL);  SQLStatement stmt = stmtList.get(0); MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor(); stmt.accept(visitor); List&lt;TableStat.Condition&gt; conditions = visitor.getConditions(); ``` BUG： visitor.getConditions()解析出来缺少 DATE_FORMAT(add_time, '%Y-%m-%d')</body>
		<created>2018-03-22 05:44:53</created>
		<closed>2018-03-22 11:24:44</closed>
	</bug>
	<bug>
		<id>2417</id>
		<title>com.alibaba.druid.sql.parser.ParserException: TODO : DOT su1</title>
		<body>[ERROR] 2018-03-19 16:12:07,470 com.alibaba.druid.filter.stat.StatFilter.mergeSql(StatFilter.java:147) - merge sql error, dbType oracle, sql : select CONNECT_BY_ROOT(su1.id) as id from sys_unit su1 where EXISTS (select 1 from sys_user suu where su1.id=suu.unitid and suu.id='b84f830ccc9e46e6a6c4add795c423ac') start with su1.type='sch' connect by prior  su1.id=su1.parentid com.alibaba.druid.sql.parser.ParserException: TODO : DOT su1 at com.alibaba.druid.sql.dialect.oracle.parser.OracleStatementParser.parseStatementList(OracleStatementParser.java:462) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:79) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:74) at com.alibaba.druid.sql.visitor.ParameterizedOutputVisitorUtils.parameterize(ParameterizedOutputVisitorUtils.java:50) at com.alibaba.druid.filter.stat.StatFilter.mergeSql(StatFilter.java:145) at com.alibaba.druid.filter.stat.StatFilter.createSqlStat(StatFilter.java:629) at com.alibaba.druid.filter.stat.StatFilter.internalBeforeStatementExecute(StatFilter.java:397) at com.alibaba.druid.filter.stat.StatFilter.statementExecuteQueryBefore(StatFilter.java:335) at com.alibaba.druid.filter.FilterEventAdapter.statement_executeQuery(FilterEventAdapter.java:299) at com.alibaba.druid.filter.FilterChainImpl.statement_executeQuery(FilterChainImpl.java:2360) at com.alibaba.druid.proxy.jdbc.StatementProxyImpl.executeQuery(StatementProxyImpl.java:211) at com.alibaba.druid.pool.DruidPooledStatement.executeQuery(DruidPooledStatement.java:140) at org.nutz.dao.impl.sql.run.NutDaoExecutor._runSelect(NutDaoExecutor.java:246) at org.nutz.dao.impl.sql.run.NutDaoExecutor.exec(NutDaoExecutor.java:53) at org.nutz.plugins.cache.dao.CachedNutDaoExecutor._exec(CachedNutDaoExecutor.java:317) at org.nutz.plugins.cache.dao.CachedNutDaoExecutor.exec(CachedNutDaoExecutor.java:111) at org.nutz.dao.DaoInterceptorChain.doChain(DaoInterceptorChain.java:66) at org.nutz.dao.impl.interceptor.DaoLogInterceptor.filter(DaoLogInterceptor.java:22) at org.nutz.dao.DaoInterceptorChain.doChain(DaoInterceptorChain.java:64) </body>
		<created>2018-03-19 08:23:21</created>
		<closed>2018-05-27 13:31:48</closed>
	</bug>
	<bug>
		<id>2411</id>
		<title>Mysql union all 进行分页（PageHelper） 出现java.lang.UnsupportedOperationException</title>
		<body>Caused by: java.lang.UnsupportedOperationException at com.alibaba.druid.sql.PagerUtils.limit(PagerUtils.java:100) at com.alibaba.druid.wall.spi.MySqlWallVisitor.visit(MySqlWallVisitor.java:190) at com.alibaba.druid.sql.ast.statement.SQLSelectStatement.accept0(SQLSelectStatement.java:63) at com.alibaba.druid.sql.ast.SQLObjectImpl.accept(SQLObjectImpl.java:42) at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:659) at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:574) at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:712) at com.alibaba.druid.wall.WallFilter.connection_prepareStatement(WallFilter.java:253) at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:473) at com.alibaba.druid.filter.FilterAdapter.connection_prepareStatement(FilterAdapter.java:929) at com.alibaba.druid.filter.FilterEventAdapter.connection_prepareStatement(FilterEventAdapter.java:122) at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:473) at com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl.prepareStatement(ConnectionProxyImpl.java:342) at com.alibaba.druid.pool.DruidPooledConnection.prepareStatement(DruidPooledConnection.java:350) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at net.bull.javamelody.JdbcWrapper$ConnectionInvocationHandler.invoke(JdbcWrapper.java:197) at net.bull.javamelody.JdbcWrapper$DelegatingInvocationHandler.invoke(JdbcWrapper.java:294) at com.sun.proxy.$Proxy124.prepareStatement(Unknown Source) at org.apache.ibatis.executor.statement.PreparedStatementHandler.instantiateStatement(PreparedStatementHandler.java:87) at org.apache.ibatis.executor.statement.BaseStatementHandler.prepare(BaseStatementHandler.java:88) ... 124 more</body>
		<created>2018-03-15 06:24:09</created>
		<closed>2018-05-27 13:31:41</closed>
	</bug>
	<bug>
		<id>2409</id>
		<title>Druid start 1.1.9 结合springboot 1.5.10 在jdk1.7下不能启动</title>
		<body> 由于com.alibaba.druid.spring.boot.autoconfigure.properties.DruidStatProperties在jdk1.8以上编译的  Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanDefinitionStoreException: Failed to process import candidates for configuration class [com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure]; nested exception is java.lang.ClassCastException: java.lang.UnsupportedClassVersionError cannot be cast to [Ljava.lang.Object;</body>
		<created>2018-03-14 06:58:43</created>
		<closed>2018-05-27 13:31:55</closed>
	</bug>
	<bug>
		<id>2407</id>
		<title>in...SQL语句解析问题</title>
		<body>druid 1.1.9  SQL： `String sql = "SELECT name FROM employee WHERE no in ('1', '2');";` `String sql = "SELECT name FROM employee WHERE no in (1, 2);";`  解析结果： `coditions : [employee.no IN (1, 2)]`  存在的问题： 以上两个SQL中in列表元素不一样但是解析出的coditions却一样。解析结果中in列表元素去掉了引号，导致无法辨别原SQL中的in列表元素是否使用了引号。  修改意见： 解析结果in列表元素应保留原始格式。</body>
		<created>2018-03-13 06:38:01</created>
		<closed>2018-05-27 13:31:34</closed>
	</bug>
	<bug>
		<id>2396</id>
		<title>springboot2.0不兼容</title>
		<body>ClassNotFoundException DataSourcePoolMetadataProvider</body>
		<created>2018-03-10 05:12:35</created>
		<closed>2018-03-11 14:46:04</closed>
	</bug>
	<bug>
		<id>2392</id>
		<title>依赖的 springboot 版本 2.0.0.RC1 在 mavne 仓库中不存在，目前版本为 2.0.0.RELEASE</title>
		<body>依赖的 springboot 版本 2.0.0.RC1 在 mavne 仓库中不存在，目前版本为 2.0.0.RELEASE</body>
		<created>2018-03-09 07:02:05</created>
		<closed>2018-03-13 08:32:54</closed>
	</bug>
	<bug>
		<id>2390</id>
		<title>Postgresql  IN (VALUES (''),('')) 查询语法不支持</title>
		<body>Druid版本：1.1.5 SQL示例： select * from a where a.id in (VALUES (4096), (4097)) 数据库：Postgresql</body>
		<created>2018-03-09 06:06:43</created>
		<closed>2018-03-11 14:44:31</closed>
	</bug>
	<bug>
		<id>2388</id>
		<title>字符'\'解析问题</title>
		<body>版本:1.1.8 描述：   在字符'\\'之后一位的字符如果不能和'\\'形成转义会丢失 举例：    INSERT INTO SUNTEST(ID,NAME) VALUES(1,'\\_ASDFASDF') 在通过 解析器解析之后会变成   INSERT INTO SUNTEST(ID,NAME) VALUES(1,'_ASDFASDF')</body>
		<created>2018-03-08 09:50:45</created>
		<closed>2018-03-11 14:46:08</closed>
	</bug>
	<bug>
		<id>2380</id>
		<title>v1.1.8 解析mysqltable中枚举类型字段错误</title>
		<body>```sql `CREATE TABLE `procs_priv` (   `Host` char(60) COLLATE utf8_bin NOT NULL DEFAULT '',   `Db` char(64) COLLATE utf8_bin NOT NULL DEFAULT '',   `User` char(32) COLLATE utf8_bin NOT NULL DEFAULT '',   `Routine_name` char(64) CHARACTER SET utf8 NOT NULL DEFAULT '',   `Routine_type` enum('FUNCTION','PROCEDURE') COLLATE utf8_bin NOT NULL,   `Grantor` char(93) COLLATE utf8_bin NOT NULL DEFAULT '',   `Proc_priv` set('Execute','Alter Routine','Grant') CHARACTER SET utf8 NOT NULL DEFAULT '',   `Timestamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,   PRIMARY KEY (`Host`,`Db`,`User`,`Routine_name`,`Routine_type`),   KEY `Grantor` (`Grantor`) ) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='Procedure privileges' ``` com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'RE') COLLATE utf8_bin NOT NULL,   `', expect RPAREN, actual IDENTIFIER pos 313, line 6, column 47, token IDENTIFIER COLLATE at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) ~[druid-1.1.8.jar:1.1.8] at com.alibaba.druid.sql.parser.SQLParser.accept(SQLParser.java:292) ~[druid-1.1.8.jar:1.1.8] at com.alibaba.druid.sql.dialect.mysql.parser.MySqlCreateTableParser.parseCreateTable(MySqlCreateTableParser.java:217) ~[druid-1.1.8.jar:1.1.8] at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseCreate(MySqlStatementParser.java:243) ~[druid-1.1.8.jar:1.1.8] at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:161) ~[druid-1.1.8.jar:1.1.8] at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:72) ~[druid-1.1.8.jar:1.1.8] at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:464) ~[druid-1.1.8.jar:1.1.8] at com.alibaba.druid.sql.repository.SchemaRepository.console(SchemaRepository.java:297) ~[druid-1.1.8.jar:1.1.8]`</body>
		<created>2018-03-06 05:44:24</created>
		<closed>2018-03-11 14:45:55</closed>
	</bug>
	<bug>
		<id>2378</id>
		<title>update语句解析后获取where条件</title>
		<body>windows/jar 版本1.1.8 ```java final String dbType = JdbcConstants.MYSQL; // ORACLE or POSTGRESQL or SQL_SERVER or HIVE or ODPS //String sql = "update b set (ClientName) = (SELECT name FROM a WHERE b.id = a.id)"; String sql = "update students set name='test' where id in (select stu_id from score where s &lt;100)"; SQLStatementParser parser = SQLParserUtils.createSQLStatementParser(sql, dbType); SQLUpdateStatement stmt = (SQLUpdateStatement) parser.parseStatement(); System.out.println(stmt.getWhere());` ``` 上面的代码拿到的结果是： `SELECT stu_id FROM score WHERE s &lt; 100` 而当把sql语句改为 `update students set name='test' where id in (select stu_id from score where s &lt;100) and name = 'test2'` 代码拿到的结果变成了： `id IN ( SELECT stu_id FROM score WHERE s &lt; 100 ) AND name = 'test2'`  为什么第一次获取where 条件没能拿到id 这个column和in这个operator呢？而添加一个and name = 'test2'的条件却能拿到。</body>
		<created>2018-03-05 10:52:34</created>
		<closed>2018-03-11 14:45:59</closed>
	</bug>
	<bug>
		<id>2357</id>
		<title>db2:alter table T_ORG alter column ORG_NAME set not null解析出错</title>
		<body>如题： 测试代码： public void  testSetSchema(){ DB2StatementParser parser = new DB2StatementParser( "alter table T_ORG alter column ORG_NAME set not null"); List&lt;SQLStatement&gt; statementList = parser.parseStatementList(); System.out.println(statementList.get(0).toString()); } 错误信息： com.alibaba.druid.sql.parser.ParserException: TODO pos 47, line 1, column 44, token NOT at com.alibaba.druid.sql.parser.SQLStatementParser.parseAlter(SQLStatementParser.java:1233) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:191) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:72) at com.alibaba.druid.SqlParserTest.testSetSchema(SqlParserTest.java:47) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at junit.framework.TestCase.runTest(TestCase.java:176) at junit.framework.TestCase.runBare(TestCase.java:141) at junit.framework.TestResult$1.protect(TestResult.java:122) at junit.framework.TestResult.runProtected(TestResult.java:142) at junit.framework.TestResult.run(TestResult.java:125) at junit.framework.TestCase.run(TestCase.java:129) at junit.framework.TestSuite.runTest(TestSuite.java:252) at junit.framework.TestSuite.run(TestSuite.java:247) at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50) at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192) </body>
		<created>2018-02-26 08:36:23</created>
		<closed>2018-03-11 14:45:38</closed>
	</bug>
	<bug>
		<id>2355</id>
		<title>MySQL delete...from...join...语句解析异常</title>
		<body>druid：1.1.8  `String sql = "delete a.* from teacher_1 a join teacher_2 b on a.teacher_id = b.teacher_id where a.day &lt; b.day";`  解析结果： Tables : {teacher_1=Delete, teacher_2=Delete, a.*=Delete}  存在的问题： 1）不应该解析出a.*； 2）表teacher_2视为Delete不合适吧； </body>
		<created>2018-02-26 03:28:35</created>
		<closed>2018-03-11 14:45:31</closed>
	</bug>
	<bug>
		<id>2346</id>
		<title>unable to parse mssql create table statement with primary key cluster syntax</title>
		<body>the following create table statement on mssql will cause parser error ```sql CREATE TABLE [dbo].[users2]( [id] [bigint] IDENTITY(1,1) NOT NULL, [email] [varchar](255) NOT NULL, [name] [varchar](255) NOT NULL, PRIMARY KEY CLUSTERED  ( [id] ASC ) ) ```</body>
		<created>2018-02-19 18:02:52</created>
		<closed>2018-03-11 14:44:39</closed>
	</bug>
	<bug>
		<id>2340</id>
		<title>1.1.7后，sql解析仍然存在一些问题</title>
		<body>#2262 中的sql仍然报错：  sql: ``` CREATE DEFINER=`root`@`%` FUNCTION `hello`(s CHAR(20)) RETURNS char(50) CHARSET big5     DETERMINISTIC RETURN CONCAT('Hello, ',s,'!') ```  exception: ``` com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'@`%` FUNCTION `hello`(s CHAR(20)) R', expect PROCEDURE, actual FUNCTION pos 34, line 1, column 26, token FUNCTION at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) at com.alibaba.druid.sql.parser.SQLParser.accept(SQLParser.java:292) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseCreateProcedure(MySqlStatementParser.java:4354) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseCreate(MySqlStatementParser.java:323) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:161) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:72) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:464) at name.jacktang.JsqlparserTest.parse(JsqlparserTest.java:31) at name.jacktang.JsqlparserTest.access$000(JsqlparserTest.java:17) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:24) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:21) at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3522) at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2315) at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2278) at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2193) ... 5 more ```  #2267 中的sql仍然报错:  sql: ``` CREATE TABLE IF NOT EXISTS srcTable (   `id` BIGINT(20) NOT NULL,   `queue_id` BIGINT(20) NOT NULL DEFAULT '-1',   `status` TINYINT(4) NOT NULL DEFAULT '1',   PRIMARY KEY (`id`) ) ENGINE=INNODB AUTO_INCREMENT 10 AVG_ROW_LENGTH 10 DEFAULT CHARACTER SET=utf8 DEFAULT COLLATE = utf8_general_ci CHECKSUM=0 COMPRESSION='NONE' CONNECTION = 'connect_string'  DELAY_KEY_WRITE = 0 ENCRYPTION 'N' INSERT_METHOD FIRST MAX_ROWS 1000 MIN_ROWS=10 PACK_KEYS DEFAULT PASSWORD '12345678' STATS_AUTO_RECALC 0 STATS_PERSISTENT 0  STATS_SAMPLE_PAGES 10 ```  exception: ``` com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'UM=0 COMPRESSION='NONE' CONNECTION ', expect IDENTIFIER, actual IDENTIFIER pos 313, line 8, column 24, token IDENTIFIER COMPRESSION at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:423) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:72) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:464) at name.jacktang.JsqlparserTest.parse(JsqlparserTest.java:31) at name.jacktang.JsqlparserTest.access$000(JsqlparserTest.java:17) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:24) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:21) at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3522) at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2315) at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2278) at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2193) ... 5 more ```  sql: ``` CREATE TABLE IF NOT EXISTS ttable ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT, `queue_id` varchar(20) NOT NULL DEFAULT '-1', `status` TINYINT(4) NOT NULL DEFAULT '1', `geometry` geometry not null, CONSTRAINT PRIMARY KEY (`id`), CONSTRAINT UNIQUE KEY `uk_queue_id` USING BTREE (`queue_id`) KEY_BLOCK_SIZE=10, FULLTEXT KEY `ft_status` (`queue_id`), spatial index `spatial` (`geometry`), CONSTRAINT FOREIGN KEY `fk_test`(`queue_id`) REFERENCES `test`(`id`) ) ENGINE=INNODB ```  exception: ``` com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'id`) KEY_BLOCK_SIZE=10, FULLTEXT KE', expect RPAREN, actual IDENTIFIER pos 301, line 8, column 62, token IDENTIFIER KEY_BLOCK_SIZE at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) at com.alibaba.druid.sql.parser.SQLParser.accept(SQLParser.java:292) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlCreateTableParser.parseCreateTable(MySqlCreateTableParser.java:217) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseCreate(MySqlStatementParser.java:243) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:161) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:72) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:464) at name.jacktang.JsqlparserTest.parse(JsqlparserTest.java:31) at name.jacktang.JsqlparserTest.access$000(JsqlparserTest.java:17) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:24) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:21) at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3522) at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2315) at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2278) at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2193) ... 5 more ```</body>
		<created>2018-02-12 08:11:20</created>
		<closed>2018-03-11 14:45:26</closed>
	</bug>
	<bug>
		<id>2338</id>
		<title>grant option 解析问题</title>
		<body>druid grant语句存在点问题，看源码解析顺序为ON TO [WITH resource_option(MAX_QUERIES_PER_HOUR,MAX_UPDATES_PER_HOUR)] [ADMIN OPTION] [IDENTIFIED BY] [WITH GRANT OPTION] 。With字段是顺序与现mysql的不一致，目前mysql 会将with 选项的resource_option放在最后一项，而druid grant 将无法解析出MAX_QUERIES_PER_HOUR参数。 还有一个，grant 语句toString 输出，不会将这些可选项携带输出，是否做完整输出更合适。</body>
		<created>2018-02-12 03:11:40</created>
		<closed>2018-03-11 14:45:15</closed>
	</bug>
	<bug>
		<id>2337</id>
		<title>REVOKE语句输出出错</title>
		<body>输出为ROVOKE了</body>
		<created>2018-02-12 01:37:53</created>
		<closed>2018-03-11 14:45:10</closed>
	</bug>
	<bug>
		<id>2332</id>
		<title>DB2数据库下执行set schema DB2ADMIN出错</title>
		<body>1.1.7版本，测试代码： public void  testSetSchema(){ DB2StatementParser parser = new DB2StatementParser( "set schema DB2ADMIN"); List&lt;SQLStatement&gt; statementList = parser.parseStatementList(); System.out.println(statementList.get(0).toString()); } 错误堆栈 ![image](https://user-images.githubusercontent.com/26472867/36068676-98b8f500-0f15-11e8-9858-59057696f6da.png)  </body>
		<created>2018-02-11 02:23:30</created>
		<closed>2018-02-11 09:25:52</closed>
	</bug>
	<bug>
		<id>2330</id>
		<title>配置aop-patterns之后导致@EnableTransactionManagement的属性proxyTargetClass设置无效</title>
		<body>设置Spring监控AOP切入点 spring.datasource.druid.aop-patterns=xxx  导致@EnableTransactionManagement的属性proxyTargetClass设置无效  `Consider injecting the bean as one of its interfaces or forcing the use of CGLib-based proxies by setting proxyTargetClass=true on @EnableAsync and/or @EnableCaching.`  必须设置spring.aop.proxy-target-class=true才得以解决这个问题</body>
		<created>2018-02-09 07:09:16</created>
		<closed>2018-02-11 09:26:09</closed>
	</bug>
	<bug>
		<id>2327</id>
		<title>hello，我遇到一个parameter解析bug</title>
		<body>final String dbType = JdbcConstants.MYSQL; List&lt;Object&gt; outParameters = new ArrayList&lt;Object&gt;(); String sql = "select count(0) from (select id from auth WHERE 1=1 AND/**/b=2  ORDER BY create_time DESC) as total"; String psql = ParameterizedOutputVisitorUtils.parameterize(sql, dbType, null, outParameters, VisitorFeature.OutputParameterizedQuesUnMergeInList); System.out.println(outParameters); &lt;img width="920" alt="qq20180208-162517 2x" src="https://user-images.githubusercontent.com/6389808/35962515-af01d0be-0cec-11e8-8de7-61668b74be6a.png"&gt;</body>
		<created>2018-02-08 08:25:48</created>
		<closed>2018-02-11 09:27:04</closed>
	</bug>
	<bug>
		<id>2326</id>
		<title>一个alter语句中同时存在add、drop、change、rename操作，解析不完整</title>
		<body>```sql ALTER TABLE `datacompute`.`users_quan`  DROP COLUMN `address`, CHANGE COLUMN `name` `username` VARCHAR(255) NULL DEFAULT 'username' , ADD COLUMN `age` VARCHAR(45) NULL DEFAULT 'age' AFTER `username`, ADD UNIQUE INDEX `idx_username` (`username` ASC), RENAME TO  `datacompute`.`users_dc` ; ``` 解析只能获取RENAME 信息</body>
		<created>2018-02-08 06:22:59</created>
		<closed>2018-02-11 09:27:12</closed>
	</bug>
	<bug>
		<id>2320</id>
		<title>1.1.6 -&gt;1.1.7 </title>
		<body>使用1.16正常,使用1.17启动报: java.lang.ClassNotFoundException: org.springframework.boot.actuate.endpoint.mvc.AbstractMvcEndpoint</body>
		<created>2018-02-07 06:15:22</created>
		<closed>2018-02-11 09:26:52</closed>
	</bug>
	<bug>
		<id>2319</id>
		<title>1.1.7 sql 复杂后,MySqlSchemaStatVisitor 的orderByColumns 的table为UNKOWN</title>
		<body>sql语句如下:select coach_id, tournament_name ,tournament_id, season_id, season, count(1) as num, sum(case when wdl = 0 then 1 else 0 end) as loss, sum(case when wdl = 1 then 1 else 0 end) as draw, sum(case when wdl = 3 then 1 else 0 end) as win  from ( select a.coach_id,b.team_id, a.home_team_id, a.away_team_id,a.tournament_id, a.tournament_name, a.season_id,a.season, a.result, case  when b.team_id = a.home_team_id then (case  WHEN CONVERT(SUBSTRING(a.result, 1, LOCATE(':',a.result)-1), SIGNED) &gt; CONVERT(SUBSTRING(a.result, LOCATE(':',a.result)+1, CHAR_LENGTH(a.result)), SIGNED)  THEN 3 WHEN CONVERT(SUBSTRING(a.result, 1, LOCATE(':',a.result)-1), SIGNED) &lt; CONVERT(SUBSTRING(a.result, LOCATE(':',a.result)+1, CHAR_LENGTH(a.result)), SIGNED)  THEN 0 else 1 end )  when b.team_id = a.away_team_id then (case  WHEN CONVERT(SUBSTRING(a.result, 1, LOCATE(':',a.result)-1), SIGNED) &gt; CONVERT(SUBSTRING(a.result, LOCATE(':',a.result)+1, CHAR_LENGTH(a.result)), SIGNED)  THEN 0 WHEN CONVERT(SUBSTRING(a.result, 1, LOCATE(':',a.result)-1), SIGNED) &lt; CONVERT(SUBSTRING(a.result, LOCATE(':',a.result)+1, CHAR_LENGTH(a.result)), SIGNED)  THEN 3 else 1 end ) end as wdl from p_coach_match_detail as a left join p_coach_career b on a.match_date &gt; b.appoint_time and a.match_date &lt; b.until_time and a.coach_id = b.coach_id and b.function = 'Manager' ) a  where season_id &gt;= 2017 and coach_id = 5075 group by coach_id, tournament_name ,tournament_id, season_id, season ORDER BY season_id DESC</body>
		<created>2018-02-06 08:58:53</created>
		<closed>2018-05-27 13:32:11</closed>
	</bug>
	<bug>
		<id>2318</id>
		<title>1.1.7 Error processing condition on com.alibaba.druid.spring.boot.autoconfigure.actuator.ActuatorConfiguration.druidDataSourceMvcEndpoint</title>
		<body>after update to 1.1.7, the following error occurred:  Error processing condition on com.alibaba.druid.spring.boot.autoconfigure.actuator.ActuatorConfiguration.druidDataSourceMvcEndpoint  1.1.6 is ok</body>
		<created>2018-02-06 08:55:13</created>
		<closed>2018-02-11 09:26:01</closed>
	</bug>
	<bug>
		<id>2314</id>
		<title>com.alibaba.druid.benckmark.sql.MySqlParameterizedBenchmark failed to compile</title>
		<body>class `SqlHolder` didnt has the public variable selectcache</body>
		<created>2018-02-05 02:01:49</created>
		<closed>2018-02-11 02:42:25</closed>
	</bug>
	<bug>
		<id>2313</id>
		<title>H2 分页错误</title>
		<body>H2 分页的时候报错，SQL 语句的解析应该有点问题，在解析 H2 SQL 的时候并没有把 SQLSelectQueryBlock 解析为 MySqlSelectQueryBlock。 测试了 1.1.4 - 1.1.6，都有这个问题。  ` PagerUtils.limit("SELECT * FROM test", JdbcUtils.H2, 0, 10); `  报类型转换错误  ``` java.lang.ClassCastException: com.alibaba.druid.sql.ast.statement.SQLSelectQueryBlock cannot be cast to com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlSelectQueryBlock at com.alibaba.druid.sql.PagerUtils.limitQueryBlock(PagerUtils.java:108) at com.alibaba.druid.sql.PagerUtils.limit(PagerUtils.java:97) at com.alibaba.druid.sql.PagerUtils.limit(PagerUtils.java:76) at com.alibaba.druid.sql.PagerUtils.limit(PagerUtils.java:72) ```</body>
		<created>2018-02-02 12:20:48</created>
		<closed>2018-02-04 07:46:10</closed>
	</bug>
	<bug>
		<id>2310</id>
		<title>pgsql：ALTER TABLE t_user ADD column aaa VARCHAR(10)</title>
		<body>主线版本：PGSQLStatementParser解析sql：ALTER TABLE t_user ADD column aaa VARCHAR(10)，最后变成了：ALTER TABLE t_user ADD (aaa VARCHAR(10))。 测试代码:    public void  testAlterColumnAdd(){ PGSQLStatementParser parser = new PGSQLStatementParser( "ALTER TABLE t_user ADD column aaa VARCHAR(10)"); List&lt;SQLStatement&gt; statementList = parser.parseStatementList(); System.out.println(statementList.get(0).toString());  } 输出的信息：ALTER TABLE t_user ADD (aaa VARCHAR(10)) </body>
		<created>2018-02-02 01:32:37</created>
		<closed>2018-02-04 07:28:17</closed>
	</bug>
	<bug>
		<id>2306</id>
		<title>MYSQL between 条件问题</title>
		<body>最新的druid 1.1.6 版本 between 条件解析问题 select * from travelrecord a where a.createtime between date_sub(now(),interval 1 day) and now(); conditions解析为：[travelrecord.createtime BETWEEN (null, Wed Jan 31 18:23:34 CST 2018)]</body>
		<created>2018-01-31 10:30:58</created>
		<closed>2018-02-04 07:46:00</closed>
	</bug>
	<bug>
		<id>2304</id>
		<title>db2：SET CURRENT SCHEMA = 'PAYROLL'语句解析不支持</title>
		<body>master版本，db2解析器执行SET CURRENT SCHEMA = 'PAYROLL'语句出错，测试代码: ![image](https://user-images.githubusercontent.com/26472867/35613819-1a2e0902-06a8-11e8-9217-6e2ffdabd49c.png) 异常信息： ![image](https://user-images.githubusercontent.com/26472867/35613895-4455b69e-06a8-11e8-8bee-d8333bf522ee.png) </body>
		<created>2018-01-31 09:00:45</created>
		<closed>2018-02-04 07:13:49</closed>
	</bug>
	<bug>
		<id>2303</id>
		<title>MYSQL反引号的小问题</title>
		<body>最新版本druid 1.1.6 一个带SCHEMA名和反引号的简单的查询：select * from \`db1\`.\`travelrecord\` a where a.id=1; 解析的表 : {db1\`.\`travelrecord=Select} 这个反引号没处理好呀，只要 schema名字带上"\`"和带上"\`"的表名同时出现,就会解析如上所示问题</body>
		<created>2018-01-31 08:00:15</created>
		<closed>2018-02-04 05:59:25</closed>
	</bug>
	<bug>
		<id>2301</id>
		<title>SQLUtils.formatSQLServer格式化“ALTER TABLE”结果错误</title>
		<body>原始SQL： `ALTER TABLE kpiTarget ADD deleted tinyint DEFAULT 0` 预期格式化后：`ALTER TABLE kpiTarget\n\tADD deleted tinyint DEFAULT 0` 用druid格式化：`ALTER TABLE kpiTarget ADD (deleted tinyint DEFAULT 0)`  已经明显改变了语义。 druid版本：1.1.6 (2018.1.30更新最新版也是一样)</body>
		<created>2018-01-30 10:09:45</created>
		<closed>2018-01-31 03:03:21</closed>
	</bug>
	<bug>
		<id>2295</id>
		<title>db2：select rtrim(current_server), rtrim(current schema), rtrim(current_user) from sysibm.sysdummy1</title>
		<body>主线版本，db2 sql解析失败，执行语句：select rtrim(current_server), rtrim(current schema), rtrim(current_user) from sysibm.sysdummy1 `测试代码： public void  testRtrim(){ DB2StatementParser parser = new DB2StatementParser( "select rtrim(current_server), rtrim(current schema), rtrim(current_user) from sysibm.sysdummy1"); List&lt;SQLStatement&gt; statementList = parser.parseStatementList(); System.out.println(statementList.get(0).toString()); }` 抛出的异常: ![image](https://user-images.githubusercontent.com/26472867/35502967-abd6a0ac-0519-11e8-8749-ef1523988e5d.png)  </body>
		<created>2018-01-29 09:27:34</created>
		<closed>2018-02-04 08:13:46</closed>
	</bug>
	<bug>
		<id>2285</id>
		<title>SQLUtils无法解析 postgresql的 jsonb操作: select '[1,2,3]'::jsonb ?| array['1']</title>
		<body>## 环境 jdk 8 PostgreSQL 10.1 postgresql(驱动) 9.4.1212.jre7   ## SQL `select '[1,2,3]'::jsonb ?| array['1']`  ## 在psql中可以正常运行，结果 ``` test=# select '[1,2,3]'::jsonb ?| array['1'];  ?column? ----------  f (1 row) ``` ## 测试代码 ```         String sql = "select '[1,2,3]'::jsonb ?| array['1']";         String dbType = JdbcConstants.POSTGRESQL;         String result = SQLUtils.format(sql, dbType); ```  ## 异常内容 16:26:50.813 [main] WARN com.alibaba.druid.sql.SQLUtils - format error com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'3]'::jsonb ?| array['1']',expect QUES, actual QUES jsonb at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:230) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:324) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:120) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:115) at com.alibaba.druid.sql.SQLUtils.toStatementList(SQLUtils.java:216) at com.alibaba.druid.sql.SQLUtils.format(SQLUtils.java:229) at com.alibaba.druid.sql.SQLUtils.format(SQLUtils.java:224) at org.beiyu.study.parser_test.DruidParserTest.main(DruidParserTest.java:22) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147) select '[1,2,3]'::jsonb ?| array['1']  请确认下是否为bug，谢谢！ </body>
		<created>2018-01-25 08:27:21</created>
		<closed>2018-02-04 07:28:49</closed>
	</bug>
	<bug>
		<id>2283</id>
		<title>【alter table t_org drop primary key】oracle、db2下解析失败</title>
		<body>如题：【alter table t_org drop primary key】这个语句在oracle、db2下解析失败，但很奇怪，mysql却能正常解析 ![image](https://user-images.githubusercontent.com/32063277/35373554-f2cdbe20-01d9-11e8-8b54-cf9c5f5796e3.png) </body>
		<created>2018-01-25 06:14:40</created>
		<closed>2018-02-04 07:11:49</closed>
	</bug>
	<bug>
		<id>2281</id>
		<title>driud wall 误报sql注入？</title>
		<body>driud 版本 1.1.6 postgres 版本 10.1 连接池配置： `spring.datasource.filters=stat,wall,log4j spring.datasource.connectionProperties=druid.stat.mergeSql=false;druid.stat.slowSqlMillis=5000   ` 查询语句： `select array_to_string(array ( select jsonb_array_elements ( '[{"aa":"123","bb":"123"},{"aa":"12356","bb":"12356"}]') -&gt;&gt; 'aa' )  ,',') as aa` 现象：filter不配置wall，mergeSql=false，可正常执行； 配置filter=wall，mergeSql=false，误报SQL注入。 日志： `org.springframework.jdbc.UncategorizedSQLException:  Error querying database.  Cause: java.sql.SQLException: sql injection violation, syntax error: syntax error, expect LBRACKET, actual LPAREN pos 30, line 1, column 29, token LPAREN : select array_to_string(array ( select jsonb_array_elements ( '[{"aa":"123","bb":"123"},{"aa":"12356","bb":"12356"}]') -&gt;&gt; 'aa' )  ,',') as aa  The error occurred while executing a query SQL: select array_to_string(array ( select jsonb_array_elements ( '[{"aa":"123","bb":"123"},{"aa":"12356","bb":"12356"}]') -&gt;&gt; 'aa'  )  ,',') as aa Cause: java.sql.SQLException: sql injection violation, syntax error: syntax error, expect LBRACKET, actual LPAREN pos 30, line 1, column 29, token LPAREN : select array_to_string(array ( select jsonb_array_elements ( '[{"aa":"123","bb":"123"},{"aa":"12356","bb":"12356"}]') -&gt;&gt; 'aa' )  ,',') as aa ; uncategorized SQLException for SQL []; SQL state [null]; error code [0]; sql injection violation, syntax error: syntax error, expect LBRACKET, actual LPAREN pos 30, line 1, column 29, token LPAREN : select array_to_string(array ( select jsonb_array_elements ( '[{"aa":"123","bb":"123"},{"aa":"12356","bb":"12356"}]') -&gt;&gt; 'aa' )  ,',') as aa; nested exception is java.sql.SQLException: sql injection violation, syntax error: syntax error, expect LBRACKET, actual LPAREN pos 30, line 1, column 29, token LPAREN : select array_to_string(array ( select jsonb_array_elements ( '[{"aa":"123","bb":"123"},{"aa":"12356","bb":"12356"}]') -&gt;&gt; 'aa' )  ,',') as aa at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:84) at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81) at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81) at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:73) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:446) at com.sun.proxy.$Proxy101.selectList(Unknown Source) at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:230) at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:137) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:75) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:59) at com.sun.proxy.$Proxy924.findEnterPersonPistPage(Unknown Source) at cn.net.hylink.data.controller.EnterPersonRegisterController.findPersonList(EnterPersonRegisterController.java:162) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:133) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872) at javax.servlet.http.HttpServlet.service(HttpServlet.java:661) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at ch.qos.logback.classic.helpers.MDCInsertingServletFilter.doFilter(MDCInsertingServletFilter.java:49) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at cn.net.hylink.data.filter.SessionFilter.doFilterInternal(SessionFilter.java:75) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at cn.net.hylink.data.filter.CorsFilter.doFilter(CorsFilter.java:19) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:208) at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:177) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:262) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:105) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:478) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:80) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:799) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1455) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745) Caused by: java.sql.SQLException: sql injection violation, syntax error: syntax error, expect LBRACKET, actual LPAREN pos 30, line 1, column 29, token LPAREN : select array_to_string(array ( select jsonb_array_elements ( '[{"aa":"123","bb":"123"},{"aa":"12356","bb":"12356"}]') -&gt;&gt; 'aa' )  ,',') as aa at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:725) at com.alibaba.druid.wall.WallFilter.connection_prepareStatement(WallFilter.java:253) at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:473) at com.alibaba.druid.filter.FilterAdapter.connection_prepareStatement(FilterAdapter.java:929) at com.alibaba.druid.filter.FilterEventAdapter.connection_prepareStatement(FilterEventAdapter.java:122) at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:473) at com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl.prepareStatement(ConnectionProxyImpl.java:342) at com.alibaba.druid.pool.DruidPooledConnection.prepareStatement(DruidPooledConnection.java:350) at org.apache.ibatis.executor.statement.PreparedStatementHandler.instantiateStatement(PreparedStatementHandler.java:87) at org.apache.ibatis.executor.statement.BaseStatementHandler.prepare(BaseStatementHandler.java:88) at org.apache.ibatis.executor.statement.RoutingStatementHandler.prepare(RoutingStatementHandler.java:59) at sun.reflect.GeneratedMethodAccessor710.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.ibatis.plugin.Invocation.proceed(Invocation.java:49) at cn.net.hylink.plugin.PagePlugin.intercept(PagePlugin.java:117) at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:61) at com.sun.proxy.$Proxy176.prepare(Unknown Source) at org.apache.ibatis.executor.SimpleExecutor.prepareStatement(SimpleExecutor.java:85) at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:62) at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:324) at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) at sun.reflect.GeneratedMethodAccessor709.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:433) ... 80 more Caused by: com.alibaba.druid.sql.parser.ParserException: syntax error, expect LBRACKET, actual LPAREN pos 30, line 1, column 29, token LPAREN at com.alibaba.druid.sql.parser.SQLExprParser.accept(SQLExprParser.java:1963) at com.alibaba.druid.sql.dialect.postgresql.parser.PGExprParser.primary(PGExprParser.java:78) at com.alibaba.druid.sql.parser.SQLExprParser.expr(SQLExprParser.java:86) at com.alibaba.druid.sql.parser.SQLExprParser.exprList(SQLExprParser.java:1003) at com.alibaba.druid.sql.parser.SQLExprParser.methodRest(SQLExprParser.java:870) at com.alibaba.druid.sql.parser.SQLExprParser.primaryRest(SQLExprParser.java:827) at com.alibaba.druid.sql.dialect.postgresql.parser.PGExprParser.primaryRest(PGExprParser.java:238) at com.alibaba.druid.sql.parser.SQLExprParser.parseSelectItem(SQLExprParser.java:2344) at com.alibaba.druid.sql.parser.SQLSelectParser.parseSelectList(SQLSelectParser.java:373) at com.alibaba.druid.sql.dialect.postgresql.parser.PGSelectParser.query(PGSelectParser.java:107) at com.alibaba.druid.sql.parser.SQLSelectParser.select(SQLSelectParser.java:59) at com.alibaba.druid.sql.dialect.postgresql.parser.PGSQLStatementParser.parseSelect(PGSQLStatementParser.java:321) at com.alibaba.druid.sql.dialect.postgresql.parser.PGSQLStatementParser.parseSelect(PGSQLStatementParser.java:43) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:143) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:93) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:89) at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:620) at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:574) at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:712) ... 109 more`     配置   filter不配置wall，mergeSql=true 报错 日志： `2018-01-23 20:16:42.378 ERROR 3980 --- [nio-7500-exec-6] c.alibaba.druid.filter.stat.StatFilter   : merge sql error, dbType postgresql, sql : select array_to_string(array ( select jsonb_array_elements ( '[{"aa":"123","bb":"123"},{"aa":"12356","bb":"12356"}]') -&gt;&gt; 'aa' )  ,',') as aa  com.alibaba.druid.sql.parser.ParserException: syntax error, expect LBRACKET, actual LPAREN pos 30, line 1, column 29, token LPAREN at com.alibaba.druid.sql.parser.SQLExprParser.accept(SQLExprParser.java:1963) at com.alibaba.druid.sql.dialect.postgresql.parser.PGExprParser.primary(PGExprParser.java:78) at com.alibaba.druid.sql.parser.SQLExprParser.expr(SQLExprParser.java:86) at com.alibaba.druid.sql.parser.SQLExprParser.exprList(SQLExprParser.java:1003) at com.alibaba.druid.sql.parser.SQLExprParser.methodRest(SQLExprParser.java:870) at com.alibaba.druid.sql.parser.SQLExprParser.primaryRest(SQLExprParser.java:827) at com.alibaba.druid.sql.dialect.postgresql.parser.PGExprParser.primaryRest(PGExprParser.java:238) at com.alibaba.druid.sql.parser.SQLExprParser.parseSelectItem(SQLExprParser.java:2344) at com.alibaba.druid.sql.parser.SQLSelectParser.parseSelectList(SQLSelectParser.java:373) at com.alibaba.druid.sql.dialect.postgresql.parser.PGSelectParser.query(PGSelectParser.java:107) at com.alibaba.druid.sql.parser.SQLSelectParser.select(SQLSelectParser.java:59) at com.alibaba.druid.sql.dialect.postgresql.parser.PGSQLStatementParser.parseSelect(PGSQLStatementParser.java:321) at com.alibaba.druid.sql.dialect.postgresql.parser.PGSQLStatementParser.parseSelect(PGSQLStatementParser.java:43) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:143) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:78) at com.alibaba.druid.sql.visitor.ParameterizedOutputVisitorUtils.parameterize(ParameterizedOutputVisitorUtils.java:43) at com.alibaba.druid.filter.stat.StatFilter.mergeSql(StatFilter.java:146) at com.alibaba.druid.filter.stat.StatFilter.createSqlStat(StatFilter.java:634) at com.alibaba.druid.filter.stat.StatFilter.statementPrepareAfter(StatFilter.java:310) at com.alibaba.druid.filter.FilterEventAdapter.connection_prepareStatement(FilterEventAdapter.java:124) at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:473) at com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl.prepareStatement(ConnectionProxyImpl.java:342) at com.alibaba.druid.pool.DruidPooledConnection.prepareStatement(DruidPooledConnection.java:350) at org.apache.ibatis.executor.statement.PreparedStatementHandler.instantiateStatement(PreparedStatementHandler.java:87) at org.apache.ibatis.executor.statement.BaseStatementHandler.prepare(BaseStatementHandler.java:88) at org.apache.ibatis.executor.statement.RoutingStatementHandler.prepare(RoutingStatementHandler.java:59) at sun.reflect.GeneratedMethodAccessor710.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.apache.ibatis.plugin.Invocation.proceed(Invocation.java:49) at cn.net.hylink.plugin.PagePlugin.intercept(PagePlugin.java:117) at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:61) at com.sun.proxy.$Proxy176.prepare(Unknown Source) at org.apache.ibatis.executor.SimpleExecutor.prepareStatement(SimpleExecutor.java:85) at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:62) at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:324) at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) at sun.reflect.GeneratedMethodAccessor709.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:433) at com.sun.proxy.$Proxy101.selectList(Unknown Source) at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:230) at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:137) at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:75) at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:59) at com.sun.proxy.$Proxy948.findEnterPersonPistPage(Unknown Source) at cn.net.hylink.data.controller.EnterPersonRegisterController.findPersonList(EnterPersonRegisterController.java:162) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:133) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872) at javax.servlet.http.HttpServlet.service(HttpServlet.java:661) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) at javax.servlet.http.HttpServlet.service(HttpServlet.java:742) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at ch.qos.logback.classic.helpers.MDCInsertingServletFilter.doFilter(MDCInsertingServletFilter.java:49) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at cn.net.hylink.data.filter.SessionFilter.doFilterInternal(SessionFilter.java:75) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at cn.net.hylink.data.filter.CorsFilter.doFilter(CorsFilter.java:19) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:208) at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:177) at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:346) at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:262) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:105) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:478) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:80) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:799) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1455) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745) `</body>
		<created>2018-01-23 12:18:05</created>
		<closed>2018-02-04 07:12:43</closed>
	</bug>
	<bug>
		<id>2280</id>
		<title>druid解析SQL中表名的BUG</title>
		<body>SELECT   (SELECT count(*) FROM warn_condition_strategy WHERE user_id = 2510701 AND is_delete = 0 AND strategy_state IN                                                                                               (1, 2, 6)) AS monitorNum,   (SELECT count(*) FROM warn_condition_trade_history WHERE user_id = 2510701 AND date_sub(curdate(), INTERVAL 7 DAY) &lt;= date(create_date)) AS recentEntrustNum,   (SELECT count(*) FROM warn_condition_strategy WHERE user_id = 2510701 AND (is_delete = 1 OR strategy_state IN (3, 4, 5))) AS historyNum,   (SELECT count(*) FROM warn_condition_trade_history WHERE user_id = 2510701 AND status = 1) AS unreadEntrustNum   这种SQL查询通过druid解析不出表名warn_condition_strategy ,必须改成group by 方式才可解析出来!</body>
		<created>2018-01-23 08:32:13</created>
		<closed>2018-02-04 07:28:54</closed>
	</bug>
	<bug>
		<id>2275</id>
		<title>wallfilter 启用时，执行alter sequence 会报错，即使打开了设置noneBaseStatementAllow也不行</title>
		<body>主要报错如下： Caused by: java.sql.SQLException: sql injection violation, syntax error: TODO : pos 14, line 1, column 6, token SEQUENCE : ALTER SEQUENCE SEQ_XXX INCREMENT BY 2 at com.alibaba.druid.wall.WallFilter.checkInternal(WallFilter.java:798) at com.alibaba.druid.wall.WallFilter.connection_prepareStatement(WallFilter.java:251) at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:473) at com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl.prepareStatement(ConnectionProxyImpl.java:342) at com.alibaba.druid.pool.DruidPooledConnection.prepareStatement(DruidPooledConnection.java:350) at com.jfinal.plugin.activerecord.DbPro.update(DbPro.java:283) at com.jfinal.plugin.activerecord.DbPro.update(DbPro.java:302) ... 47 more Caused by: com.alibaba.druid.sql.parser.ParserException: TODO : pos 14, line 1, column 6, token SEQUENCE at com.alibaba.druid.sql.dialect.oracle.parser.OracleStatementParser.parserAlter(OracleStatementParser.java:1414) at com.alibaba.druid.sql.dialect.oracle.parser.OracleStatementParser.parseStatementList(OracleStatementParser.java:140) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:81) at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:622) at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:576) at com.alibaba.druid.wall.WallFilter.checkInternal(WallFilter.java:785) ... 53 more</body>
		<created>2018-01-22 09:17:00</created>
		<closed>2018-01-23 01:20:50</closed>
	</bug>
	<bug>
		<id>2271</id>
		<title>解析create table sql 失败</title>
		<body>解析create table sql 失败: ParserException: error KEY  ```sql CREATE TABLE `dc_job_instance` (   `id` int(11) NOT NULL AUTO_INCREMENT,   `code` varchar(45) NOT NULL,   `name` varchar(512) DEFAULT NULL,   `cluster_code` varchar(64) DEFAULT NULL,   `engine_inst_code` varchar(45) DEFAULT NULL,   `dependent_code` varchar(1024) DEFAULT NULL COMMENT '依赖上一个实例code',   `concurrent_rely` varchar(1024) DEFAULT NULL COMMENT '并发依赖',   `job_text` longtext,   `project_code` varchar(45) DEFAULT NULL COMMENT '项目code',   `job_name` varchar(128) DEFAULT NULL COMMENT 'job名称',   `job_code` varchar(45) DEFAULT NULL,   `job_id` int(11) DEFAULT NULL,   `job_type` varchar(45) DEFAULT NULL,   `type` varchar(45) NOT NULL DEFAULT 'test' COMMENT '开发实例：dev\n调度实例：schedule\n测试实例：test\n补数据实例：supplement',   `version` int(11) NOT NULL DEFAULT '0',   `status` int(11) NOT NULL DEFAULT '0' COMMENT '1：等待运行，3：等待资源，5：运行中，7：运行失败，9：运行成功， 11：暂停， 13：终止',   `schedule_start` datetime DEFAULT NULL COMMENT '调度开始时间',   `run_start` datetime DEFAULT NULL COMMENT '运行开始时间',   `run_end` datetime DEFAULT NULL COMMENT '运行结束时间',   `owner` varchar(64) NOT NULL,   `bizdate` varchar(64) DEFAULT NULL COMMENT '业务日期：yyyy-MM-dd\n',   `rundate` varchar(64) DEFAULT NULL COMMENT '运行日期：yyyy-MM-dd',   `run_mode` varchar(45) DEFAULT NULL COMMENT '运行模式：jobserver, thriftserver, phoenix、tidb',   `runtimes` int(16) DEFAULT '0' COMMENT '运行时间，单位秒',   `res_cu` decimal(20,5) DEFAULT '0.00000' COMMENT '计算消耗资源，单位cu',   `retry_count` int(11) DEFAULT '0',   `failure_count` int(11) DEFAULT NULL COMMENT '失败次数',   `last_notify_time` datetime DEFAULT NULL COMMENT '最新一次告警通知时间',   `alarm_count` int(11) DEFAULT '0' COMMENT '告警次数',   `error_type` varchar(45) DEFAULT NULL COMMENT '系统异常：sys\n作业异常：job',   `spark_application_id` varchar(128) DEFAULT 'spark app id',   `spark_group_id` varchar(128) DEFAULT NULL COMMENT 'Spark group id',   `spark_web_url` varchar(256) DEFAULT NULL,   `gmt_created` datetime NOT NULL,   `gmt_modified` datetime DEFAULT NULL,   `creater` varchar(45) NOT NULL,   `modifier` varchar(45) DEFAULT NULL,   PRIMARY KEY (`id`),   UNIQUE KEY `code_UNIQUE` (`code`),   KEY `project_code_index` (`project_code`),   KEY `job_code_index` (`job_code`),   KEY `type_index` (`type`),   KEY `spark_app_id_index` (`spark_application_id`),   FULLTEXT KEY `ft_job_text` (`job_text`,`spark_application_id`) ) ENGINE=InnoDB AUTO_INCREMENT=23185 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT; ```</body>
		<created>2018-01-19 02:53:26</created>
		<closed>2018-02-04 07:46:21</closed>
	</bug>
	<bug>
		<id>2267</id>
		<title>SQLUtils解析mysql创建表语句报错</title>
		<body>sql: ``` CREATE TABLE IF NOT EXISTS testTable (   `id` BIGINT(20) NOT NULL,   `queue_id` BIGINT(20) NOT NULL DEFAULT '-1',   `status` TINYINT(4) NOT NULL DEFAULT '1',   PRIMARY KEY (`id`) ) ENGINE=INNODB AUTO_INCREMENT 10 AVG_ROW_LENGTH 10 DEFAULT CHARACTER SET=utf8 DEFAULT COLLATE = utf8_general_ci CHECKSUM=0 CONNECTION = 'connect_string'  DELAY_KEY_WRITE = 0 ENCRYPTION='N' INSERT_METHOD FIRST MAX_ROWS 1000 MIN_ROWS=10 PACK_KEYS DEFAULT PASSWORD '12345678' STATS_AUTO_RECALC 0 STATS_PERSISTENT 0  STATS_SAMPLE_PAGES 10 ``` error: ``` com.alibaba.druid.sql.parser.ParserException: syntax error, error in :' = 0 ENCRYPTION='N' INSERT_METHOD F',expect IDENTIFIER, actual IDENTIFIER pos 364, line 8, column 74, token IDENTIFIER ENCRYPTION at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:280) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:385) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:78) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:419) at name.jacktang.JsqlparserTest.parse(JsqlparserTest.java:31) at name.jacktang.JsqlparserTest.access$000(JsqlparserTest.java:17) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:24) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:21) at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3522) at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2315) at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2278) at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2193) ... 4 more ```  sql: ``` CREATE TABLE IF NOT EXISTS srcTable (   `id` BIGINT(20) NOT NULL,   `queue_id` BIGINT(20) NOT NULL DEFAULT '-1',   `status` TINYINT(4) NOT NULL DEFAULT '1',   PRIMARY KEY (`id`) ) ENGINE=INNODB AUTO_INCREMENT 10 AVG_ROW_LENGTH 10 DEFAULT CHARACTER SET=utf8 DEFAULT COLLATE = utf8_general_ci CHECKSUM=0 COMPRESSION='NONE' CONNECTION = 'connect_string'  DELAY_KEY_WRITE = 0 ENCRYPTION 'N' INSERT_METHOD FIRST MAX_ROWS 1000 MIN_ROWS=10 PACK_KEYS DEFAULT PASSWORD '12345678' STATS_AUTO_RECALC 0 STATS_PERSISTENT 0  STATS_SAMPLE_PAGES 10 ``` error: ``` com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'UM=0 COMPRESSION='NONE' CONNECTION ',expect IDENTIFIER, actual IDENTIFIER pos 313, line 8, column 24, token IDENTIFIER COMPRESSION at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:280) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:385) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:78) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:419) at name.jacktang.JsqlparserTest.parse(JsqlparserTest.java:31) at name.jacktang.JsqlparserTest.access$000(JsqlparserTest.java:17) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:24) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:21) at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3522) at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2315) at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2278) at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2193) ... 4 more ```</body>
		<created>2018-01-16 09:26:38</created>
		<closed>2018-02-04 07:45:05</closed>
	</bug>
	<bug>
		<id>2264</id>
		<title>SchemaRepository Wildcard sql resolve 不能</title>
		<body>當由多於一個表內select wildcard 的時候 SchemaRepository 不能正確地expand columns ```java //借用wenshao 的test case 作展示 public class OracleJoinResolveTest extends TestCase {     protected SchemaRepository repository = new SchemaRepository(JdbcConstants.ORACLE);      public void test_for_issue() throws Exception {         repository.console("create table t_user (uid number(20, 0), gid number(20, 0), name varchar2(20))");         repository.console("create table t_group (id number(20, 0), name varchar2(20))");          assertEquals("SELECT a.uid, a.gid, a.name, b.id, b.name\n" +                 "FROM t_user a\n" +                 "\tINNER JOIN t_group b\n" +                 "WHERE a.uid = b.id"                 , repository.resolve("select * from t_user a inner join t_group b where a.uid = id"));     } } ```  Actual return ```sql SELECT * FROM t_user a INNER JOIN t_group b WHERE a.uid = b.id ```</body>
		<created>2018-01-16 03:07:33</created>
		<closed>2018-02-04 07:44:56</closed>
	</bug>
	<bug>
		<id>2263</id>
		<title>SQLUtils解析mysql partition相关操作报错</title>
		<body>sql: ``` ALTER TABLE src.`part_tab` DISCARD PARTITION p10 TABLESPACE ``` error: ``` com.alibaba.druid.sql.parser.ParserException: syntax error, error in :' p10 TABLESPACE',expect TABLESPACE, actual TABLESPACE pos 59, line 1, column 49, token TABLESPACE at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:280) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:385) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:78) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:419) at name.jacktang.JsqlparserTest.parse(JsqlparserTest.java:31) at name.jacktang.JsqlparserTest.access$000(JsqlparserTest.java:17) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:24) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:21) at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3522) at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2315) at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2278) at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2193) ... 4 more ```  sql: ``` ALTER TABLE src.`part_tab` EXCHANGE PARTITION p9 WITH TABLE test_create_table without validation ``` error: ``` com.alibaba.druid.sql.parser.ParserException: TODO pos 35, line 1, column 27, token IDENTIFIER EXCHANGE at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlterTable(MySqlStatementParser.java:2779) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlter(MySqlStatementParser.java:2429) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:185) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:78) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:419) at name.jacktang.JsqlparserTest.parse(JsqlparserTest.java:31) at name.jacktang.JsqlparserTest.access$000(JsqlparserTest.java:17) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:24) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:21) at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3522) at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2315) at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2278) at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2193) ... 4 more ```</body>
		<created>2018-01-15 09:50:02</created>
		<closed>2018-02-04 07:32:53</closed>
	</bug>
	<bug>
		<id>2262</id>
		<title>SQLUtils解析mysql create procedure以及create function报错</title>
		<body>sql: ``` CREATE DEFINER=`root`@`%` PROCEDURE `load_part_tab`() BEGIN  DECLARE v INT DEFAULT 0;  WHILE v &lt; 1 DO  INSERT INTO part_tab  VALUES (v,'testing partitions',ADDDATE('1995-01-01',(RAND(v)*36520) MOD 3652));  SET v = v + 1;  END WHILE;  END ``` error: ``` com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'root`@`%` PROCEDURE `load_part_tab`',expect PROCEDURE, actual VARIANT pos 25, line 1, column 22, token VARIANT at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:280) at com.alibaba.druid.sql.parser.SQLParser.accept(SQLParser.java:288) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseCreateProcedure(MySqlStatementParser.java:3266) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseCreate(MySqlStatementParser.java:355) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:155) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:78) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:419) at name.jacktang.JsqlparserTest.parse(JsqlparserTest.java:31) at name.jacktang.JsqlparserTest.access$000(JsqlparserTest.java:17) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:24) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:21) at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3522) at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2315) at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2278) at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2193) ... 4 more ```  sql: ``` CREATE DEFINER=`root`@`%` FUNCTION `hello`(s CHAR(20)) RETURNS char(50) CHARSET big5     DETERMINISTIC RETURN CONCAT('Hello, ',s,'!') ``` error: ``` com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'root`@`%` FUNCTION `hello`(s CHAR(2',expect PROCEDURE, actual VARIANT pos 25, line 1, column 22, token VARIANT at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:280) at com.alibaba.druid.sql.parser.SQLParser.accept(SQLParser.java:288) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseCreateProcedure(MySqlStatementParser.java:3266) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseCreate(MySqlStatementParser.java:355) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:155) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:78) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:419) at name.jacktang.JsqlparserTest.parse(JsqlparserTest.java:31) at name.jacktang.JsqlparserTest.access$000(JsqlparserTest.java:17) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:24) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:21) at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3522) at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2315) at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2278) at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2193) ... 4 more ```</body>
		<created>2018-01-15 09:21:24</created>
		<closed>2018-02-04 07:33:01</closed>
	</bug>
	<bug>
		<id>2260</id>
		<title>sql parse不支持 mysql set数据类型</title>
		<body>druid version 1.1.6:  ```java public class DruidTest {      public static void main(String[] args) {         String sql = "create table t(id int, name set('a','b','c') not null default 'a' );";         List&lt;SQLStatement&gt; sqlStatements = SQLUtils.parseStatements(sql, JdbcConstants.MYSQL);         for (SQLStatement statement : sqlStatements) {             System.out.println(statement);         }     } } ```  报错:  ```java Exception in thread "main" com.alibaba.druid.sql.parser.ParserException: error pos 31, line 1, column 28, token SET at com.alibaba.druid.sql.parser.SQLExprParser.name(SQLExprParser.java:1334) at com.alibaba.druid.sql.parser.SQLExprParser.parseDataType(SQLExprParser.java:2310) at com.alibaba.druid.sql.parser.SQLExprParser.parseDataType(SQLExprParser.java:2301) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlExprParser.parseColumn(MySqlExprParser.java:493) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlCreateTableParser.parseCreateTable(MySqlCreateTableParser.java:115) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseCreate(MySqlStatementParser.java:244) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:159) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:70) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:464) at DruidTest.main(DruidTest.java:11)  ``` </body>
		<created>2018-01-15 08:11:51</created>
		<closed>2018-02-04 07:32:49</closed>
	</bug>
	<bug>
		<id>2259</id>
		<title>SQLUtils解析mysql add primary key语句报错</title>
		<body>sql: ``` ALTER TABLE test.table ADD PRIMARY KEY test_pk(id); ```  error: ``` com.alibaba.druid.sql.parser.ParserException: syntax error, expect LPAREN, actual IDENTIFIER pos 46, line 1, column 39, token IDENTIFIER test_pk at com.alibaba.druid.sql.parser.SQLExprParser.accept(SQLExprParser.java:1963) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlExprParser.parsePrimaryKey(MySqlExprParser.java:788) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlExprParser.parsePrimaryKey(MySqlExprParser.java:62) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlterTable(MySqlStatementParser.java:2476) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlter(MySqlStatementParser.java:2429) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:185) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:78) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:419) at name.jacktang.JsqlparserTest.parse(JsqlparserTest.java:31) at name.jacktang.JsqlparserTest.access$000(JsqlparserTest.java:17) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:24) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:21) at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3522) at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2315) at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2278) at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2193) ... 4 more ```  sql: ``` ALTER TABLE test.table ADD CONSTRAINT PRIMARY KEY test_pk(id); ```  error: ``` com.alibaba.druid.sql.parser.ParserException: error pos 45, line 1, column 38, token PRIMARY at com.alibaba.druid.sql.parser.SQLExprParser.name(SQLExprParser.java:1081) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlterTable(MySqlStatementParser.java:2487) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlter(MySqlStatementParser.java:2429) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:185) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:78) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:419) at name.jacktang.JsqlparserTest.parse(JsqlparserTest.java:31) at name.jacktang.JsqlparserTest.access$000(JsqlparserTest.java:17) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:24) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:21) at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3522) at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2315) at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2278) at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2193) ... 4 more ```</body>
		<created>2018-01-15 06:54:05</created>
		<closed>2018-02-04 07:32:39</closed>
	</bug>
	<bug>
		<id>2258</id>
		<title>SQLUtils解析mysql alter database、create schema、alter schema报错</title>
		<body>sql: ``` alter database test CHARACTER SET='big5' COLLATE='big5_chinese_ci' ``` error: ``` com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'CTER SET='big5' COLLATE='big5_chine',expect IDENTIFIER, actual IDENTIFIER pos 29, line 1, column 30, token IDENTIFIER SET at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:280) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:385) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:78) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:419) at name.jacktang.JsqlparserTest.parse(JsqlparserTest.java:31) at name.jacktang.JsqlparserTest.access$000(JsqlparserTest.java:17) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:24) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:21) at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3522) at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2315) at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2278) at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2193) ... 4 more ```  sql: ``` create schema src ``` error: ``` com.alibaba.druid.sql.parser.ParserException: TODO pos 13, line 1, column 7, token SCHEMA at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseCreate(MySqlStatementParser.java:365) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:155) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:78) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:419) at name.jacktang.JsqlparserTest.parse(JsqlparserTest.java:31) at name.jacktang.JsqlparserTest.access$000(JsqlparserTest.java:17) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:24) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:21) at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3522) at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2315) at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2278) at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2193) ... 4 more ```  sql: ``` ALTER schema src CHARACTER SET='big5' COLLATE='big5_chinese_ci' ``` error: ``` com.alibaba.druid.sql.parser.ParserException: TODO pos 12, line 1, column 6, token SCHEMA at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlter(MySqlStatementParser.java:2436) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:185) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:78) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:419) at name.jacktang.JsqlparserTest.parse(JsqlparserTest.java:31) at name.jacktang.JsqlparserTest.access$000(JsqlparserTest.java:17) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:24) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:21) at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3522) at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2315) at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2278) at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2193) ... 4 more ```</body>
		<created>2018-01-15 03:19:12</created>
		<closed>2018-02-04 07:46:26</closed>
	</bug>
	<bug>
		<id>2255</id>
		<title>解析编码异常</title>
		<body>在建表时解析 ``` CREATE TABLE `f_product` (   `id` int(200) NOT NULL AUTO_INCREMENT,  `type` enum('market','land','enterprise') CHARACTER SET utf8 DEFAULT NULL COMMENT 'comment',  PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=1DEFAULT CHARSET=utf8mb4 ``` 与 修改表 ` `type` enum('market','land','enterprise') CHARACTER SET utf8 CHARSET utf8mb4 DEFAULT NULL COMMENT 'comment',` 时报错,估计是在MySqlExprParser 解析中未判断 CHARACTER</body>
		<created>2018-01-12 10:38:50</created>
		<closed>2018-02-04 07:32:34</closed>
	</bug>
	<bug>
		<id>2251</id>
		<title>解析mysql重命名索引语句报错</title>
		<body>sql： ``` alter table test.table rename index idx_status to idx_status_2 ```  exception： ``` com.alibaba.druid.sql.parser.ParserException: error pos 35, line 1, column 30, token INDEX at com.alibaba.druid.sql.parser.SQLExprParser.name(SQLExprParser.java:1081) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlterTable(MySqlStatementParser.java:2651) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlter(MySqlStatementParser.java:2429) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:185) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:78) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:419) at name.jacktang.JsqlparserTest.parse(JsqlparserTest.java:31) at name.jacktang.JsqlparserTest.access$000(JsqlparserTest.java:17) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:24) at name.jacktang.JsqlparserTest$1.load(JsqlparserTest.java:21) at com.google.common.cache.LocalCache$LoadingValueReference.loadFuture(LocalCache.java:3522) at com.google.common.cache.LocalCache$Segment.loadSync(LocalCache.java:2315) at com.google.common.cache.LocalCache$Segment.lockedGetOrLoad(LocalCache.java:2278) at com.google.common.cache.LocalCache$Segment.get(LocalCache.java:2193) ... 4 more ```</body>
		<created>2018-01-11 09:11:02</created>
		<closed>2018-02-04 07:49:46</closed>
	</bug>
	<bug>
		<id>2226</id>
		<title>双引号包裹的字符串解析为SQLIdentifierExpr</title>
		<body>`select * from t where op_date = date_format(DATE_ADD('2017-12-27', Interval -1 year), '%Y-%m-%d 00:00:00') `  如上的sql，用单引号包裹的字符串，生成ast后，被解析为SQLCharExpr，如果改成双引号，则全部识别为SQLIdentifierExpr  使用的druid版本：1.1.6 @wenshao </body>
		<created>2017-12-28 08:27:26</created>
		<closed>2018-02-04 07:22:30</closed>
	</bug>
	<bug>
		<id>2222</id>
		<title>数字值超过Long.MAX_VALUE后，druid反向生成SQL时错误</title>
		<body>原始SQL: `SELECT a from b where c &lt;&gt; 1  LIMIT 0, 18446744073709551615` 经过druid识别为语法树，然后再遍历语法树生成SQL时变为: `SELECT a FROM b WHERE c &lt;&gt; 1 LIMIT 0, -1`  复现代码:  ```java String sql = "SELECT a from b where c &lt;&gt; 1  LIMIT 0, 18446744073709551615"; List&lt;SQLStatement&gt; sqlStatements = SQLUtils.parseStatements(sql, JdbcConstants.MYSQL); StringBuilder sb = new StringBuilder(); MySqlOutputVisitor visitor = new MySqlOutputVisitor(sb); visitor.setPrettyFormat(false); sqlStatements.get(0).accept(visitor); System.out.println(sb); ``` 输出结果: ` SELECT a FROM b WHERE c &lt;&gt; 1 LIMIT 0, -1 `  [问题代码](https://github.com/alibaba/druid/blob/master/src/main/java/com/alibaba/druid/sql/visitor/SQLASTOutputVisitor.java#L1317) 调用`x.getNumber().longValue()` 时，如果数字值超过Long.MAX_VALUE将会得到未预期的赋值，而数据库是存在`unsigned bigint`类型的  @wenshao 有空修吗？ 没时间的话，我可以提PR。</body>
		<created>2017-12-27 04:01:55</created>
		<closed>2018-02-11 08:18:57</closed>
	</bug>
	<bug>
		<id>2220</id>
		<title>mysql parser不支持对enum的解析</title>
		<body> CREATE TABLE `public_history` (   `id` int(10) NOT NULL AUTO_INCREMENT COMMENT 'ID',   `v_id` int(11) DEFAULT NULL COMMENT 'version ID',   `name` char(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL COMMENT '名称',   `type` enum('日策略','周策略') CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL COMMENT '类型策略',   `update_uid` int(10) NOT NULL,   `update_time` datetime DEFAULT NULL,   `create_uid` int(11) NOT NULL,   `create_time` datetime NOT NULL,   PRIMARY KEY (`id`),   UNIQUE KEY `name` (`name`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COMMENT='历史' com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'策略') CHARACTER SET utf8 COLLATE utf', expect RPAREN, actual IDENTIFIER pos 327, line 5, column 49, token IDENTIFIER CHARACTER at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) ~[druid-1.1.6.jar:1.1.6] at com.alibaba.druid.sql.parser.SQLParser.accept(SQLParser.java:292) ~[druid-1.1.6.jar:1.1.6] at com.alibaba.druid.sql.dialect.mysql.parser.MySqlCreateTableParser.parseCreateTable(MySqlCreateTableParser.java:191) ~[druid-1.1.6.jar:1.1.6] at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseCreate(MySqlStatementParser.java:244) ~[druid-1.1.6.jar:1.1.6] at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:159) ~[druid-1.1.6.jar:1.1.6] at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:70) ~[druid-1.1.6.jar:1.1.6] at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:464) ~[druid-1.1.6.jar:1.1.6] at com.alibaba.druid.sql.repository.SchemaRepository.console(SchemaRepository.java:295) ~[druid-1.1.6.jar:1.1.6]</body>
		<created>2017-12-26 10:43:19</created>
		<closed>2018-02-04 07:14:08</closed>
	</bug>
	<bug>
		<id>2215</id>
		<title>语法解析错误：exists关键字问题</title>
		<body>测试代码如下: ```java                 String sql = "select * from ttt where exist (select max(id) from ttt);";         System.out.println("------------------------------------------------");         List&lt;SQLStatement&gt; sqlStatements = SQLUtils.parseStatements(sql, JdbcConstants.MYSQL);         for (SQLStatement sqlStatement : sqlStatements) {             // output is: SELECT * FROM ttt WHERE exist(( SELECT MAX(id) FROM ttt ));             // expect is: ERROR 1305 (42000): FUNCTION test1.exist does not exist              System.out.println(sqlStatement);         } ``` 这里的是**exist**而不是**exists**关键字,在实际的MySQL中执行抛出的是ERROR 1305,期望这里抛出语法解析异常</body>
		<created>2017-12-25 10:35:18</created>
		<closed>2018-02-04 08:08:25</closed>
	</bug>
	<bug>
		<id>2211</id>
		<title>MATERIALIZED VIEW无法解析</title>
		<body>SQLUtils.parseStatements("DROP MATERIALIZED VIEW ATOM_MVIEW.NONAUTO_CLAIM_FOLDER_T;", "oracle");  Exception in thread "main" com.alibaba.druid.sql.parser.ParserException: TODO : pos 17, line 1, column 5, token IDENTIFIER MATERIALIZED</body>
		<created>2017-12-22 06:47:06</created>
		<closed>2018-02-04 07:13:05</closed>
	</bug>
	<bug>
		<id>2210</id>
		<title>1.1.6版本Druid连接MSSQLServer 2008 R2报错The query timeout value -1 is not valid.</title>
		<body>1.1.6版本Druid连接MSSQL Server 2008 R2报错：com.microsoft.sqlserver.jdbc.SQLServerException: The query timeout value -1 is not valid.经测试1.1.5版本的Druid无此问题；而1.1.6版本Druid连接MySQL数据库也没有问题。以下是完整的错误日志： com.microsoft.sqlserver.jdbc.SQLServerException: The query timeout value -1 is not valid. at com.microsoft.sqlserver.jdbc.SQLServerException.makeFromDriverError(SQLServerException.java:227) at com.microsoft.sqlserver.jdbc.SQLServerStatement.setQueryTimeout(SQLServerStatement.java:1112) at com.alibaba.druid.pool.vendor.MSSQLValidConnectionChecker.isValidConnection(MSSQLValidConnectionChecker.java:47) at com.alibaba.druid.pool.DruidAbstractDataSource.validateConnection(DruidAbstractDataSource.java:1304) at com.alibaba.druid.pool.DruidAbstractDataSource.createPhysicalConnection(DruidAbstractDataSource.java:1585) at com.alibaba.druid.pool.DruidDataSource.init(DruidDataSource.java:854) at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:1221) at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:1217)</body>
		<created>2017-12-21 07:51:43</created>
		<closed>2018-02-11 09:26:26</closed>
	</bug>
	<bug>
		<id>2194</id>
		<title>SQLUtils.toStatementList 解析 CREATE INDEX LOCAL ONLINE失败</title>
		<body>SQLUtils.toStatementList 解析create index idx_id on t2(id) local online; 时会将此语句解析成"create index idx_id on t2(id) local" 和 "online" 两个语句 导致执行失败</body>
		<created>2017-12-15 04:05:49</created>
		<closed>2018-02-04 07:25:17</closed>
	</bug>
	<bug>
		<id>2183</id>
		<title>建触发器语句报错</title>
		<body>错误信息是：【Exception in thread "main" com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'_app`@`%` TRIGGER `xxxxx', expect TRIGGER, actual VARIANT pos 30, line 1, column 27, token VARIANT】 是不是不支持DEFINER子句?</body>
		<created>2017-12-12 06:12:39</created>
		<closed>2018-02-04 08:14:00</closed>
	</bug>
	<bug>
		<id>2182</id>
		<title>PostgreSQL &amp; MySQL 无法识别BEGIN 语法</title>
		<body>**BEGIN** 语法是PostgreSQL的方言，[语法说明](https://www.postgresql.org/docs/9.6/static/sql-begin.html)  复现代码 ```java PGSQLStatementParser parser = new PGSQLStatementParser("BEGIN"); List&lt;SQLStatement&gt; statements = parser.parseStatementList(); ``` 直接抛错 ``` Exception in thread "main" com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'BEGIN;', expect BEGIN, actual BEGIN pos 5, line 1, column 1, token BEGIN at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:421) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:70) ```  这是很基础的语法，PostgreSQL JDBC开启事务就是使用的**BEGIN**而不是**START TRANSACTION** 期待支持。</body>
		<created>2017-12-12 03:46:17</created>
		<closed>2018-02-11 09:26:34</closed>
	</bug>
	<bug>
		<id>2180</id>
		<title>SQL解析简单HIVE语句出错：INSERT OVERWRITE TABLE events SELECT a.* FROM profiles a</title>
		<body>示例代码 :   ``` public static void main(String [] args){         final String dbType = JdbcConstants.HIVE; //        String sql = "insert overwrite table userinfo select id,age,name from userinfos";         String sql = "INSERT OVERWRITE TABLE events SELECT a.* FROM profiles a";         List&lt;SQLStatement&gt; stmtList = SQLUtils.parseStatements(sql, dbType);         int listLen = stmtList.size();     } ``` 运行报错 :  `com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'SERT OVERWRITE TABLE events SELECT ', expect IDENTIFIER, actual IDENTIFIER pos 16, line 1, column 7, token IDENTIFIER OVERWRITE`  请问这是我的问题还是项目代码本身有问题？谢谢。</body>
		<created>2017-12-11 12:47:08</created>
		<closed>2017-12-12 01:38:39</closed>
	</bug>
	<bug>
		<id>2169</id>
		<title>sql parser 解析出错 ， DB2数据库中执行通过  </title>
		<body>select to_char(current date **- 7 day** ,'yyyymmdd') from sysibm.dual 这个SQL语句在DB2 v9.7 执行通过。 经调试，这个SQL语句中 【-7 day】 会引起解析出错（不加的话不会报错）  ，报错信息：   ``` com.alibaba.druid.sql.parser.ParserException: syntax error, expect RPAREN, actual IDENTIFIER pos 37, line 1, column 34, token IDENTIFIER day at com.alibaba.druid.sql.parser.SQLExprParser.accept(SQLExprParser.java:2375) at com.alibaba.druid.sql.parser.SQLExprParser.methodRest(SQLExprParser.java:1080) at com.alibaba.druid.sql.parser.SQLExprParser.parseSelectItem(SQLExprParser.java:2928) at com.alibaba.druid.sql.parser.SQLSelectParser.parseSelectList(SQLSelectParser.java:508) at com.alibaba.druid.sql.dialect.db2.parser.DB2SelectParser.query(DB2SelectParser.java:77) at com.alibaba.druid.sql.parser.SQLSelectParser.select(SQLSelectParser.java:59) at com.alibaba.druid.sql.parser.SQLStatementParser.parseSelect(SQLStatementParser.java:2371) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:147) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:70) at com.alibaba.druid.sql.SQLUtils.format(SQLUtils.java:255) at com.alibaba.druid.sql.SQLUtils.format(SQLUtils.java:241) at parse.db2.SelectParser.main(SelectParser.java:61) Exception in thread "main" com.alibaba.druid.sql.parser.ParserException: syntax error, expect RPAREN, actual IDENTIFIER pos 37, line 1, column 34, token IDENTIFIER day at com.alibaba.druid.sql.parser.SQLExprParser.accept(SQLExprParser.java:2375) at com.alibaba.druid.sql.parser.SQLExprParser.methodRest(SQLExprParser.java:1080) at com.alibaba.druid.sql.parser.SQLExprParser.parseSelectItem(SQLExprParser.java:2928) at com.alibaba.druid.sql.parser.SQLSelectParser.parseSelectList(SQLSelectParser.java:508) at com.alibaba.druid.sql.dialect.db2.parser.DB2SelectParser.query(DB2SelectParser.java:77) at com.alibaba.druid.sql.parser.SQLSelectParser.select(SQLSelectParser.java:59) at com.alibaba.druid.sql.parser.SQLStatementParser.parseSelect(SQLStatementParser.java:2371) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:147) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:70) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:461) at parse.db2.SelectParser.main(SelectParser.java:63) ``` </body>
		<created>2017-12-07 07:55:43</created>
		<closed>2018-02-04 07:25:11</closed>
	</bug>
	<bug>
		<id>2167</id>
		<title>mysql sql解析error，测试从1.1.3至1.1.6都有该问题，1.1.3之前版本正常</title>
		<body>目前项目中使用的是1.0.29的版本，近期打算升级到最新版本1.1.6。 升级之后启动个别应用出现。 异常信息：  [ERROR] 2017-12-07 10:23:18,219 --main-- [org.hibernate.engine.jdbc.spi.SqlExceptionHelper] sql injection violation, syntax error: syntax error, error in :'pe=? and cfgdatasou0_.module_name=?', expect AND, actual AND pos 790, line 1, column 787, token AND : select *(这里字段*代替了) from TABLENAME cfgdatasou0_ where cfgdatasou0_.type=? and cfgdatasou0_.module_name=? and cfgdatasou0_.node_type=? or cfgdatasou0_.type=? and cfgdatasou0_.module_name=? and cfgdatasou0_.node_type=? or cfgdatasou0_.type=? and cfgdatasou0_.module_name=? and cfgdatasou0_.node_type=?   Caused by: com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'pe=? and cfgdatasou0_.module_name=?', expect AND, actual AND pos 790, line 1, column 787, token AND at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:421) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:81) at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:624) at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:578) at com.alibaba.druid.wall.WallFilter.checkInternal(WallFilter.java:785) ... 59 common frames omitted  但是有部分应用启动正常，然后我对比了执行的sql发现在解析select *(这里字段*代替了) from TABLENAME cfgdatasou0_ where cfgdatasou0_.type=? and cfgdatasou0_.module_name=? and cfgdatasou0_.node_type=? or cfgdatasou0_.type=? and cfgdatasou0_.module_name=? and cfgdatasou0_.node_type=? 是正常的，对比发现少了一个or条件or cfgdatasou0_.type=? and cfgdatasou0_.module_name=? and cfgdatasou0_.node_type=?   也就是说当我是where条件为where cfgdatasou0_.type=? and cfgdatasou0_.module_name=? and cfgdatasou0_.node_type=? or cfgdatasou0_.type=? and cfgdatasou0_.module_name=? and cfgdatasou0_.node_type=? or cfgdatasou0_.type=? and cfgdatasou0_.module_name=? and cfgdatasou0_.node_type=?  出错，我试了很多版本，在1.1.3之前的版本是正常的，1.1.3以后的版本都有这个问题，包括最新版本1.1.6。  一路跟了下dubug源码出现问题的在com.alibaba.druid.sql.dialect.mysql.parser.MySqlSelectParser.        parseWhere(queryBlock);这一句，解析两个or条件正常， WHERE cfgdatasou0_.type = ? AND cfgdatasou0_.module_name = ? AND cfgdatasou0_.node_type = ? OR cfgdatasou0_.type = ? AND cfgdatasou0_.module_name = ? AND cfgdatasou0_.node_type = ?，并且**lexer.token=EOF**结束状态是正常的。  异常情况下 (cfgdatasou0_.type = ? AND cfgdatasou0_.module_name = ? AND cfgdatasou0_.node_type = ?) OR (cfgdatasou0_.type = ? AND cfgdatasou0_.module_name = ? AND cfgdatasou0_.node_type = ?) OR cfgdatasou0_.type = ?  成这个样子了？？？？不全。。。并且**lexer.token=AND**   if (parseStatementListDialect(statementList)) 这句返回false，接下来执行了 printError(lexer.token);丢出来了上面的异常。  相同的情况下，我用1.1.3之前版本是正常的。</body>
		<created>2017-12-07 03:14:36</created>
		<closed>2018-02-04 07:11:35</closed>
	</bug>
	<bug>
		<id>2153</id>
		<title>wall 无法支持 PostgreSQL 的索引创建语句</title>
		<body>## 环境 * SpringBoot 1.5.9 * OpenJDK 8 * druid-spring-boot-starter 1.1.6 * PostgreSQL 10.1 * postgresql(驱动) 42.1.4  ## SQL ```sql DROP TABLE IF EXISTS "public"."city"; CREATE TABLE "public"."city" (   "id" varchar(6) COLLATE "default" NOT NULL,   "name" varchar(32) COLLATE "default" NOT NULL ) WITH (OIDS=FALSE); COMMENT ON TABLE "public"."city" IS '城市'; COMMENT ON COLUMN "public"."city"."name" IS '城市名';  CREATE UNIQUE INDEX "test_idx" ON "public"."city" USING btree ("name");  ```  ## 异常内容 ``` java.lang.IllegalStateException: Failed to load ApplicationContext  at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:124) at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:83) at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:189) at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(ServletTestExecutionListener.java:131) at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:230) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:228) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:287) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:289) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:247) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:94) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:191) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name '******' defined in file [******/target/classes/******.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSourceInitializer': Invocation of init method failed; nested exception is org.springframework.jdbc.datasource.init.ScriptStatementFailedException: Failed to execute SQL script statement #5 of URL [file:******/target/test-classes/schema.sql]: CREATE UNIQUE INDEX "test_idx" ON "public"."city" USING btree ("name"); nested exception is java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'ity" USING btree ("name")', expect LPAREN, actual USING pos 55, line 1, column 50, token USING : CREATE UNIQUE INDEX "test_idx" ON "public"."city" USING btree ("name") at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:749) at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1193) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1095) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:543) at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:693) at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:360) at org.springframework.boot.SpringApplication.run(SpringApplication.java:303) at org.springframework.boot.test.context.SpringBootContextLoader.loadContext(SpringBootContextLoader.java:120) at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:98) at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:116) ... 24 more Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSourceInitializer': Invocation of init method failed; nested exception is org.springframework.jdbc.datasource.init.ScriptStatementFailedException: Failed to execute SQL script statement #5 of URL [file:******/target/test-classes/schema.sql]: CREATE UNIQUE INDEX "test_idx" ON "public"."city" USING btree ("name"); nested exception is java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'ity" USING btree ("name")', expect LPAREN, actual USING pos 55, line 1, column 50, token USING : CREATE UNIQUE INDEX "test_idx" ON "public"."city" USING btree ("name") at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:137) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:409) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1620) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:208) at org.springframework.beans.factory.support.DefaultListableBeanFactory.addCandidateEntry(DefaultListableBeanFactory.java:1316) at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1282) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveMultipleBeans(DefaultListableBeanFactory.java:1180) at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1096) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066) at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:835) at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:741) ... 42 more Caused by: org.springframework.jdbc.datasource.init.ScriptStatementFailedException: Failed to execute SQL script statement #5 of URL [file:******/target/test-classes/schema.sql]: CREATE UNIQUE INDEX "test_idx" ON "public"."city" USING btree ("name"); nested exception is java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'ity" USING btree ("name")', expect LPAREN, actual USING pos 55, line 1, column 50, token USING : CREATE UNIQUE INDEX "test_idx" ON "public"."city" USING btree ("name") at org.springframework.jdbc.datasource.init.ScriptUtils.executeSqlScript(ScriptUtils.java:491) at org.springframework.jdbc.datasource.init.ResourceDatabasePopulator.populate(ResourceDatabasePopulator.java:238) at org.springframework.jdbc.datasource.init.DatabasePopulatorUtils.execute(DatabasePopulatorUtils.java:48) at org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer.runScripts(DataSourceInitializer.java:192) at org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer.runSchemaScripts(DataSourceInitializer.java:92) at org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer.init(DataSourceInitializer.java:83) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:366) at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:311) at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:134) ... 58 more Caused by: java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'ity" USING btree ("name")', expect LPAREN, actual USING pos 55, line 1, column 50, token USING : CREATE UNIQUE INDEX "test_idx" ON "public"."city" USING btree ("name") at com.alibaba.druid.wall.WallFilter.checkInternal(WallFilter.java:798) at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:780) at com.alibaba.druid.wall.WallFilter.statement_execute(WallFilter.java:413) at com.alibaba.druid.filter.FilterChainImpl.statement_execute(FilterChainImpl.java:2598) at com.alibaba.druid.filter.FilterAdapter.statement_execute(FilterAdapter.java:2473) at com.alibaba.druid.filter.FilterEventAdapter.statement_execute(FilterEventAdapter.java:188) at com.alibaba.druid.filter.FilterChainImpl.statement_execute(FilterChainImpl.java:2598) at com.alibaba.druid.proxy.jdbc.StatementProxyImpl.execute(StatementProxyImpl.java:147) at com.alibaba.druid.pool.DruidPooledStatement.execute(DruidPooledStatement.java:558) at org.springframework.jdbc.datasource.init.ScriptUtils.executeSqlScript(ScriptUtils.java:470) ... 70 more Caused by: com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'ity" USING btree ("name")', expect LPAREN, actual USING pos 55, line 1, column 50, token USING at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:284) at com.alibaba.druid.sql.parser.SQLParser.accept(SQLParser.java:292) at com.alibaba.druid.sql.parser.SQLStatementParser.parseCreateIndex(SQLStatementParser.java:2366) at com.alibaba.druid.sql.parser.SQLStatementParser.parseCreate(SQLStatementParser.java:2008) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:159) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:81) at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:624) at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:578) at com.alibaba.druid.wall.WallFilter.checkInternal(WallFilter.java:785) ... 79 more ``` </body>
		<created>2017-12-02 13:40:08</created>
		<closed>2018-02-04 06:00:22</closed>
	</bug>
	<bug>
		<id>2151</id>
		<title>SQLExternalRecordFormat未找到</title>
		<body>为什么源码中没有这个类</body>
		<created>2017-12-01 09:30:39</created>
		<closed>2017-12-01 13:08:34</closed>
	</bug>
	<bug>
		<id>2146</id>
		<title>why  XADataSource in druid only support mysql driver 5?</title>
		<body>I use JTA with Atomikos + Druid + mysql connector java 6, but get a error in runtime, the log indicates that druid can not get a XAConnection, but getConnection works well.  I read the source code, in MySqlUtils.class, I found  the method 'createXAConnection' only support mysql driver 5, switch to5, it works.  How do you think? ![y eekikxl y8l8hd_wqnct](https://user-images.githubusercontent.com/11826915/33417677-63d633c8-d5dd-11e7-8ac6-e461220b588e.png) </body>
		<created>2017-11-30 06:47:45</created>
		<closed>2017-12-02 09:31:08</closed>
	</bug>
	<bug>
		<id>2141</id>
		<title>ERRORpos 97, GT state</title>
		<body>2017-11-29 10:46:00,743 ERROR [com.alibaba.druid.filter.stat.StatFilter] - merge sql error, dbType sqlserver, sql : select count(1) From wms.pack_box_material a,wms.pack_box b where a.pb_id=b.pb_id  and b.state&lt; &gt;2 and not exists(  select 1 From wms.box_pack_detail c where c.pm_id=a.pm_id ) and b.box_cid=? com.alibaba.druid.sql.parser.ParserException: ERRORpos 97, GT state   语句没问题  为啥报这个错?</body>
		<created>2017-11-29 03:58:27</created>
		<closed>2018-02-04 06:04:28</closed>
	</bug>
	<bug>
		<id>2129</id>
		<title>wall 无法支持 PostgreSQL 的建表语句</title>
		<body>## 环境 * SpringBoot 1.5.8 * OpenJDK 8 * druid-spring-boot-starter 1.1.5 * PostgreSQL 10.1 * postgresql(驱动) 42.1.4  ## SQL ```sql DROP TABLE IF EXISTS "public"."city"; CREATE TABLE "public"."city" (   "id" varchar(6) COLLATE "default" NOT NULL,   "name" varchar(32) COLLATE "default" NOT NULL ) WITH (OIDS=FALSE); COMMENT ON TABLE "public"."city" IS '城市'; COMMENT ON COLUMN "public"."city"."name" IS '城市名'; ```  ## 异常内容 ``` ERROR [main] o.springframework.test.context.TestContextManager 2017-11-24 09:32:30   ---&gt; Caught exception while allowing TestExecutionListener [org.springframework.test.context.web.ServletTestExecutionListener@769f71a9] to prepare test instance [********@5978ba12] java.lang.IllegalStateException: Failed to load ApplicationContext at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:124) at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:83) at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:189) at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(ServletTestExecutionListener.java:131) at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:230) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:228) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:287) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:289) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:247) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:94) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) at org.junit.runners.ParentRunner.run(ParentRunner.java:363) at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:191) at org.junit.runner.JUnitCore.run(JUnitCore.java:137) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68) at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:47) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70) Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name '********' defined in file [********.class]: Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSourceInitializer': Invocation of init method failed; nested exception is org.springframework.jdbc.datasource.init.ScriptStatementFailedException: Failed to execute SQL script statement #2 of URL [file:********/target/test-classes/schema.sql]: CREATE TABLE "public"."city" ( "id" varchar(6) COLLATE "default" NOT NULL, "name" varchar(32) COLLATE "default" NOT NULL ) WITH (OIDS=FALSE); nested exception is java.sql.SQLException: sql injection violation, syntax error: null : CREATE TABLE "public"."city" ( "id" varchar(6) COLLATE "default" NOT NULL, "name" varchar(32) COLLATE "default" NOT NULL ) WITH (OIDS=FALSE) at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:749) at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1193) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1095) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197) at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761) at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:543) at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:693) at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:360) at org.springframework.boot.SpringApplication.run(SpringApplication.java:303) at org.springframework.boot.test.context.SpringBootContextLoader.loadContext(SpringBootContextLoader.java:120) at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:98) at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:116) ... 24 common frames omitted Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSourceInitializer': Invocation of init method failed; nested exception is org.springframework.jdbc.datasource.init.ScriptStatementFailedException: Failed to execute SQL script statement #2 of URL [file:********/target/test-classes/schema.sql]: CREATE TABLE "public"."city" ( "id" varchar(6) COLLATE "default" NOT NULL, "name" varchar(32) COLLATE "default" NOT NULL ) WITH (OIDS=FALSE); nested exception is java.sql.SQLException: sql injection violation, syntax error: null : CREATE TABLE "public"."city" ( "id" varchar(6) COLLATE "default" NOT NULL, "name" varchar(32) COLLATE "default" NOT NULL ) WITH (OIDS=FALSE) at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:137) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:409) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1620) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:555) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:208) at org.springframework.beans.factory.support.DefaultListableBeanFactory.addCandidateEntry(DefaultListableBeanFactory.java:1316) at org.springframework.beans.factory.support.DefaultListableBeanFactory.findAutowireCandidates(DefaultListableBeanFactory.java:1282) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveMultipleBeans(DefaultListableBeanFactory.java:1180) at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1096) at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066) at org.springframework.beans.factory.support.ConstructorResolver.resolveAutowiredArgument(ConstructorResolver.java:835) at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:741) ... 42 common frames omitted Caused by: org.springframework.jdbc.datasource.init.ScriptStatementFailedException: Failed to execute SQL script statement #2 of URL [file:********/target/test-classes/schema.sql]: CREATE TABLE "public"."city" ( "id" varchar(6) COLLATE "default" NOT NULL, "name" varchar(32) COLLATE "default" NOT NULL ) WITH (OIDS=FALSE); nested exception is java.sql.SQLException: sql injection violation, syntax error: null : CREATE TABLE "public"."city" ( "id" varchar(6) COLLATE "default" NOT NULL, "name" varchar(32) COLLATE "default" NOT NULL ) WITH (OIDS=FALSE) at org.springframework.jdbc.datasource.init.ScriptUtils.executeSqlScript(ScriptUtils.java:491) at org.springframework.jdbc.datasource.init.ResourceDatabasePopulator.populate(ResourceDatabasePopulator.java:238) at org.springframework.jdbc.datasource.init.DatabasePopulatorUtils.execute(DatabasePopulatorUtils.java:48) at org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer.runScripts(DataSourceInitializer.java:192) at org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer.runSchemaScripts(DataSourceInitializer.java:92) at org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer.init(DataSourceInitializer.java:83) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:366) at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:311) at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:134) ... 58 common frames omitted Caused by: java.sql.SQLException: sql injection violation, syntax error: null : CREATE TABLE "public"."city" ( "id" varchar(6) COLLATE "default" NOT NULL, "name" varchar(32) COLLATE "default" NOT NULL ) WITH (OIDS=FALSE) at com.alibaba.druid.wall.WallFilter.checkInternal(WallFilter.java:798) at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:780) at com.alibaba.druid.wall.WallFilter.statement_execute(WallFilter.java:413) at com.alibaba.druid.filter.FilterChainImpl.statement_execute(FilterChainImpl.java:2598) at com.alibaba.druid.filter.FilterAdapter.statement_execute(FilterAdapter.java:2473) at com.alibaba.druid.filter.FilterEventAdapter.statement_execute(FilterEventAdapter.java:188) at com.alibaba.druid.filter.FilterChainImpl.statement_execute(FilterChainImpl.java:2598) at com.alibaba.druid.proxy.jdbc.StatementProxyImpl.execute(StatementProxyImpl.java:147) at com.alibaba.druid.pool.DruidPooledStatement.execute(DruidPooledStatement.java:497) at org.springframework.jdbc.datasource.init.ScriptUtils.executeSqlScript(ScriptUtils.java:470) ... 70 common frames omitted Caused by: com.alibaba.druid.sql.parser.ParserException: null at com.alibaba.druid.sql.parser.SQLExprParser.parseCharTypeRest(SQLExprParser.java:2361) at com.alibaba.druid.sql.parser.SQLExprParser.parseDataType(SQLExprParser.java:2263) at com.alibaba.druid.sql.parser.SQLExprParser.parseDataType(SQLExprParser.java:2227) at com.alibaba.druid.sql.dialect.postgresql.parser.PGExprParser.parseDataType(PGExprParser.java:82) at com.alibaba.druid.sql.parser.SQLExprParser.parseColumn(SQLExprParser.java:2388) at com.alibaba.druid.sql.parser.SQLCreateTableParser.parseCreateTable(SQLCreateTableParser.java:102) at com.alibaba.druid.sql.parser.SQLStatementParser.parseCreate(SQLStatementParser.java:1979) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:159) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:81) at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:622) at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:576) at com.alibaba.druid.wall.WallFilter.checkInternal(WallFilter.java:785) ... 79 common frames omitted ```</body>
		<created>2017-11-24 01:37:04</created>
		<closed>2017-12-01 14:58:03</closed>
	</bug>
	<bug>
		<id>2119</id>
		<title>关于hint的解析</title>
		<body>```sql  select id from a /*+ xxx */  ``` 这样的sql是可以正常提炼出hint的，但   ```sql  select now()  /*+ xxx */  ```  就不能正常提炼出hint了，不确定这算不算bug。  有问题的版本是1.1.5；之前1.1.2版本是正常的。  </body>
		<created>2017-11-20 12:20:39</created>
		<closed>2017-12-01 14:57:53</closed>
	</bug>
	<bug>
		<id>2118</id>
		<title>SQLSERVER 不能使用MERGE语法</title>
		<body>jdbc方式正常，为什么druid会报错呢 mybatis+druid 1.1.5报错。jdbcTemplate+hikariCP没问题，NaviCat运行没问题。 MERGE INTO tb_device_category t1 USING ( select distinct device_category, factory_id from temp_device where device_category is not null ) t2  on (t1.name = t2.device_category and t1.factory_id = t2.factory_id) WHEN NOT MATCHED THEN     INSERT (name, factory_id) values (t2.device_category, t2.factory_id);</body>
		<created>2017-11-20 05:44:53</created>
		<closed>2017-12-01 14:23:42</closed>
	</bug>
	<bug>
		<id>2117</id>
		<title>ListDG类存在main函数 </title>
		<body>public static void main(String[] args) {         Object[] vexs = new Object[]{'A', 'B', 'C', 'D', 'E', 'F', 'G'};         ListDG.Edge[] edges = new ListDG.Edge[]{new ListDG.Edge(vexs[0], vexs[6]), new ListDG.Edge(vexs[1], vexs[0]), new ListDG.Edge(vexs[1], vexs[3]), new ListDG.Edge(vexs[2], vexs[5]), new ListDG.Edge(vexs[2], vexs[6]), new ListDG.Edge(vexs[3], vexs[4]), new ListDG.Edge(vexs[3], vexs[5])};         ListDG pG = new ListDG(Arrays.asList(vexs), Arrays.asList(edges));         pG.print();         pG.topologicalSort();     }</body>
		<created>2017-11-18 14:52:54</created>
		<closed>2017-12-01 14:50:12</closed>
	</bug>
	<bug>
		<id>2115</id>
		<title>mysql set session xxxx语句解析会省略session关键字</title>
		<body>在一般情况下set session xxxx 和set xxxx没有区别，但是如果是在调整事务信息的情况下会有差异    详情见官方文档Scope of Transaction Characteristics： https://dev.mysql.com/doc/refman/5.7/en/set-transaction.html    需要给对应的解析结果增添相应的标识  </body>
		<created>2017-11-17 06:21:19</created>
		<closed>2017-11-17 07:18:26</closed>
	</bug>
	<bug>
		<id>2114</id>
		<title>关于SQLObject对象的clone能否带上attributes？</title>
		<body>在实践过程中涉及到了SQLObject的克隆，但是克隆出来的SQLObject没有带上attribute的信息比如:     SQLVariantRefExpr中的clone方法：             SQLVariantRefExpr var =  new SQLVariantRefExpr(name, global);             var.index = index;             return var; Druid能否将clone的过程中带上attribute的信息。</body>
		<created>2017-11-17 05:50:03</created>
		<closed>2018-02-04 06:25:29</closed>
	</bug>
	<bug>
		<id>2112</id>
		<title>SQL Server (NOLOCK) 关键字不兼容</title>
		<body>java.sql.SQLException: sql injection violation, syntax error: syntax error</body>
		<created>2017-11-15 09:40:42</created>
		<closed>2017-12-01 14:56:03</closed>
	</bug>
	<bug>
		<id>2106</id>
		<title>START TRANSACTION;</title>
		<body>START TRANSACTION;这个SQL通过解析后，生成了SQLStartTransactionStatement，但是toString方法，仅仅输出一个分号</body>
		<created>2017-11-10 06:43:33</created>
		<closed>2017-12-01 14:51:17</closed>
	</bug>
	<bug>
		<id>2105</id>
		<title>sql统计重复</title>
		<body>在批量更新时数据量不一样导致druid认为是两条不同的sql：  如  update table set field=?;update table set field=?; 与 update table set field=?;update table set field=?;update table set field=?;  druid会记录两条这样的信息。。 </body>
		<created>2017-11-10 02:31:19</created>
		<closed>2017-12-01 14:51:09</closed>
	</bug>
	<bug>
		<id>2097</id>
		<title>状态机检测到非法SQL后加入了白名单</title>
		<body>状态机检测到非法SQL后，会把该SQL放进白名单，导致第二次运行该SQL时直接跳过校验。</body>
		<created>2017-11-06 14:52:53</created>
		<closed>2017-12-01 14:23:56</closed>
	</bug>
	<bug>
		<id>2096</id>
		<title>关于db2解析Select语句的from语句的问题</title>
		<body>SQL：select a from (select b from d) 如果使用oracle为数据库方言来解析该语句，则解析出来的from语句为： ( SELECT b FROM d ) 但是如果使用db2为数据库方言来解析，解析出来的from语句则是：(com.alibaba.druid.sql.ast.statement.SQLSelect@bfd7ac73) 希望能够支持像oracle一样将from中的原本的Select语句解析出来。</body>
		<created>2017-11-06 06:40:26</created>
		<closed>2017-12-01 14:50:45</closed>
	</bug>
	<bug>
		<id>2093</id>
		<title>visitor.getConditions()方法获取不到between连接符</title>
		<body> @wenshao   我的 sql 中有between连接符，但是最终的输出结果中却只有一个=的连接符 版本为1.1.2                  String DBTYPE = JdbcConstants.MYSQL;         String sql = "select name from student where id = 4 and flag between 1 and 3";         String format = SQLUtils.format(sql, DBTYPE);         List&lt;SQLStatement&gt; list = SQLUtils.parseStatements(sql, DBTYPE);          for (int i = 0; i &lt; list.size(); i++) {             SQLStatement stmt = list.get(i);             MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();             stmt.accept(visitor);               //获取操作方法名称,依赖于表名称             System.out.println("涉及到的所有表 : " + visitor.getTables());             Map&lt;TableStat.Name, TableStat&gt; table_map = visitor.getTables();             for(Map.Entry&lt;TableStat.Name, TableStat&gt; entry : table_map.entrySet()){                 TableStat.Name name = entry.getKey();                 name.getName();                 //存储表的调度次数，包括select ，update等                 TableStat ts = entry.getValue();              }              //获取字段名称             System.out.println("getParameters: " + visitor.getParameters());             //获取列名             System.out.println("查询的列信息 : " + visitor.getColumns());             Collection&lt;TableStat.Column&gt; cc = visitor.getColumns();             //column 存储了表名，列名，以及列是出现的位置，where，select，groupby ，order             for(TableStat.Column column : cc){              }             System.out.println("conditions : " + visitor.getConditions() );             List&lt;TableStat.Condition&gt; conditions = visitor.getConditions();             System.out.println("----------------------------");             for(TableStat.Condition cond : conditions){                 System.out.println( "column : " + cond.getColumn());                 System.out.println( "operator : " + cond.getOperator());                 System.out.println( "values  : " + cond.getValues());                  System.out.println("----------------------------");             }          }  输出结果：  涉及到的所有表 : {student=Select} getParameters: [] 查询的列信息 : [student.name, student.id, student.flag] conditions : [student.id = 4] ---------------------------- column : student.id operator : = values  : [4] ----------------------------</body>
		<created>2017-11-03 07:43:42</created>
		<closed>2017-12-01 14:23:21</closed>
	</bug>
	<bug>
		<id>2089</id>
		<title>关于merge into解析的几点需求</title>
		<body>SQL： MERGE INTO ( SELECT * FROM KPI_M_CW_INCOME_FACT_BAK WHERE THE_DATE = '{THISMONTH}' AND AREA_LEVEL &lt;= 1 AND TYPE_ID = '2' ) A USING ( SELECT * FROM M_HEALTH_APPRAISE_LOAD WHERE THE_DATE = TRUNC(SYSDATE) AND AREA_LEVEL &lt;= 1 ) B ON (A.AREA_ID = B.AREA_ID AND A.AREA_LEVEL = B.AREA_LEVEL)  WHEN MATCHED THEN UPDATE SET A.SUM_CHRG_YS = ROUND(B.TOTAL_CHARGE * 1.00 / 10000, 2), A.CHARGE = B.THIS_CHARGE;  比如像这样的SQL，在解析时，into的table解析出来是(com.alibaba.druid.sql.ast.statement.SQLSelect@d25062e)，能不能像using一样将原来的Select语句解析出来  还有一个就是A.SUM_CHRG_YS = ROUND(B.TOTAL_CHARGE * 1.00 / 10000, 2)这个updateSetItem我使用getValue方法获取到的是ROUND(com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr@4b0a05e0, 2)这样的形式，能不能将com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr@4b0a05e0原本的内容解析出来，这个问题之前是issue #1970，您close掉了，今天发现还是无法将原本的内容解析出来。</body>
		<created>2017-11-02 07:39:48</created>
		<closed>2017-12-01 13:12:36</closed>
	</bug>
	<bug>
		<id>2082</id>
		<title>Mysql parser 对 Alter table add foreign key报错</title>
		<body>``` ALTER TABLE test_table_normal ADD FOREIGN KEY (stuID) REFERENCES Persons(stuID); ```  ``` com.alibaba.druid.sql.parser.ParserException: error pos 41, line 2, column 5, token FOREIGN  at com.alibaba.druid.sql.parser.SQLExprParser.name(SQLExprParser.java:1320) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlExprParser.parseColumn(MySqlExprParser.java:492) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlterTableAddColumn(MySqlStatementParser.java:3865) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlterTable(MySqlStatementParser.java:3457) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlter(MySqlStatementParser.java:2699) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:189) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:70) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:461) ```</body>
		<created>2017-10-31 10:00:56</created>
		<closed>2018-02-04 07:28:24</closed>
	</bug>
	<bug>
		<id>2080</id>
		<title>format mysql建表语句遇到索引有注释报错</title>
		<body>```sql CREATE TABLE `g_platform_payway` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id',  `platform_code` varchar(45) NOT NULL,  `pay_way` varchar(32) NOT NULL,  PRIMARY KEY (`id`),  UNIQUE `uniq_playform_payway` USING BTREE (`platform_code`, `pay_way`) COMMENT '平台code和支付方式应该唯一' ) ENGINE = InnoDB CHARSET = utf8 COMMENT = '配置表' ``` 如上sql中唯一索引后带有comment...时会格式化出错，格式化代码如下所示： ```java MySqlStatementParser parser = new MySqlStatementParser(sql3); SQLStatement statement = parser.parseStatement(); ``` 报错信息如下所示： ``` Exception in thread "main" com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'TREE COMMENT '平台code和支付方式应该唯一' ) EN',expect RPAREN, actual COMMENT COMMENT at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:239) at com.alibaba.druid.sql.parser.SQLParser.accept(SQLParser.java:247) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlCreateTableParser.parseCrateTable(MySqlCreateTableParser.java:182) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseCreate(MySqlStatementParser.java:341) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:193) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatement(SQLStatementParser.java:2036) ```</body>
		<created>2017-10-31 02:56:11</created>
		<closed>2017-12-01 13:12:12</closed>
	</bug>
	<bug>
		<id>2079</id>
		<title>format DB2建表语句报错</title>
		<body>SQL： CREATE TABLE MK.M_DM_BASE_CHARGE_TMP1  (PROD_ID    BIGINT,   ITEM_ID  SMALLINT,   CHARGE     BIGINT,   PAGES      BIGINT,   DURATION   BIGINT,   BILLING_DURATION BIGINT  ) DATA CAPTURE NONE    IN MK_APP_TEMP    INDEX IN WH_INDEX1    PARTITIONING KEY     (PROD_ID     ) USING HASHING  错误： syntax error, error in :'P   INDEX IN WH_INDEX1   PARTITIO', expect INDEX, actual INDEX pos 216, line 9, column 16, token INDEX</body>
		<created>2017-10-31 01:05:49</created>
		<closed>2017-12-01 13:12:00</closed>
	</bug>
	<bug>
		<id>2065</id>
		<title>不能解析DDL语句中的CHECK 和 FOREIGN KEY </title>
		<body>``` CREATE TABLE IF NOT EXISTS `test_table_normal`(   scoreID INTEGER NOT NULL PRIMARY KEY,   stuID     INTEGER NOT NULL,   KEMUID     INTEGER NOT NULL,   score     FLOAT,   FOREIGN KEY SCORE_ID_FK (stuID) REFERENCES students (stuid),   CONSTRAINT CHK_SCORE_ZIP CHECK (SCORE &gt; 0)   );   ``` 报错： ``` com.alibaba.druid.sql.parser.ParserException: TODO. pos 263, line 7, column 26, token CHECK  at com.alibaba.druid.sql.dialect.mysql.parser.MySqlCreateTableParser.parseConstraint(MySqlCreateTableParser.java:862) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlCreateTableParser.parseCreateTable(MySqlCreateTableParser.java:125) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseCreate(MySqlStatementParser.java:224) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:157) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:68) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:461) ```  ``` ALTER TABLE test_table_normal ADD FOREIGN KEY (stuID) REFERENCES Persons(stuID); ```  报错： ``` com.alibaba.druid.sql.parser.ParserException: error pos 41, line 2, column 5, token FOREIGN  at com.alibaba.druid.sql.parser.SQLExprParser.name(SQLExprParser.java:1210) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlExprParser.parseColumn(MySqlExprParser.java:472) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlterTableAddColumn(MySqlStatementParser.java:2980) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlterTable(MySqlStatementParser.java:2583) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlter(MySqlStatementParser.java:2455) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:187) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:68) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:461) ```</body>
		<created>2017-10-26 08:31:08</created>
		<closed>2017-10-27 15:24:12</closed>
	</bug>
	<bug>
		<id>2063</id>
		<title>postgresql   ANY(ARRAY[n,m,.....]) ParserException</title>
		<body>version : 1.1.4  SELECT COL1 from TABLE where NID = ANY(ARRAY[1,2,3])  error: com.alibaba.druid.sql.parser.ParserException: syntax error, expect RPAREN, actual ARRAY pos 44, line 1, column 40, token ARRAY at com.alibaba.druid.sql.parser.SQLExprParser.accept(SQLExprParser.java:2249) at com.alibaba.druid.sql.parser.SQLExprParser.parseAny(SQLExprParser.java:772) at com.alibaba.druid.sql.parser.SQLExprParser.primary(SQLExprParser.java:682) at com.alibaba.druid.sql.dialect.postgresql.parser.PGExprParser.primary(PGExprParser.java:114) at com.alibaba.druid.sql.parser.SQLExprParser.bitXor(SQLExprParser.java:134) at com.alibaba.druid.sql.parser.SQLExprParser.multiplicative(SQLExprParser.java:214) at com.alibaba.druid.sql.parser.SQLExprParser.additive(SQLExprParser.java:1632) at com.alibaba.druid.sql.parser.SQLExprParser.shift(SQLExprParser.java:1662) at com.alibaba.druid.sql.parser.SQLExprParser.bitAnd(SQLExprParser.java:1509) at com.alibaba.druid.sql.parser.SQLExprParser.bitOr(SQLExprParser.java:1523) at com.alibaba.druid.sql.parser.SQLSelectParser.parseWhere(SQLSelectParser.java:345) at com.alibaba.druid.sql.dialect.postgresql.parser.PGSelectParser.query(PGSelectParser.java:136) at com.alibaba.druid.sql.parser.SQLSelectParser.select(SQLSelectParser.java:58) at com.alibaba.druid.sql.dialect.postgresql.parser.PGSQLStatementParser.parseSelect(PGSQLStatementParser.java:234) at com.alibaba.druid.sql.dialect.postgresql.parser.PGSQLStatementParser.parseSelect(PGSQLStatementParser.java:38) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:145) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:68) at com.druid.TestDruidSqlParser.main(TestDruidSqlParser.java:14)</body>
		<created>2017-10-26 06:41:15</created>
		<closed>2017-10-27 15:24:23</closed>
	</bug>
	<bug>
		<id>2060</id>
		<title>postgresql ON CONFLICT  DO UPDATE 解析失败</title>
		<body>druid 版本号 1.1.4 配置信息 spring.datasource.druid.db-type=postgresql spring.datasource.type=com.alibaba.druid.pool.DruidDataSource spring.datasource.druid.driver-class-name=org.postgresql.Driver  测试数据： db_dev=&gt; create table test(k int PRIMARY KEY,v int); CREATE TABLE db_dev=&gt; insert into test(k,v) values (1,1); INSERT 0 1 db_dev=&gt; insert into test(k,v) values (1,2) ON CONFLICT (k) DO UPDATE SET v = EXCLUDED.v; INSERT 0 1 db_dev=&gt; select * from test;  k | v ---+---  1 | 2 (1 row) 但是 把 insert into test(k,v) values (1,2) ON CONFLICT (k) DO UPDATE SET v = EXCLUDED.v; 这一句放在 代码里会报sql 异常 ### Error updating database.  Cause: java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'1,2) ON CONFLICT (k) DO UPDATE SET ', expect ON, actual ON pos 37, line 1, column 35, token ON : insert into test(k,v) values (1,2) ON CONFLICT (k) DO UPDATE SET v = EXCLUDED.v; ### SQL: insert into test(k,v) values (1,2) ON CONFLICT (k) DO UPDATE SET v = EXCLUDED.v; ### Cause: java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'1,2) ON CONFLICT (k) DO UPDATE SET ', expect ON, actual ON pos 37, line 1, column 35, token ON : insert into test(k,v) values (1,2) ON CONFLICT (k) DO UPDATE SET v = EXCLUDED.v; ; uncategorized SQLException for SQL []; SQL state [null]; error code [0]; sql injection violation, syntax error: syntax error, error in :'1,2) ON CONFLICT (k) DO UPDATE SET ', expect ON, actual ON pos 37, line 1, column 35, token ON : insert into test(k,v) values (1,2) ON CONFLICT (k) DO UPDATE SET v = EXCLUDED.v;; nested exception is java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'1,2) ON CONFLICT (k) DO UPDATE SET ', expect ON, actual ON pos 37, line 1, column 35, token ON : insert into test(k,v) values (1,2) ON CONFLICT (k) DO UPDATE SET v = EXCLUDED.v; at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:84) at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81) at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:81) at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:73) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:446) Caused by: java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'1,2) ON CONFLICT (k) DO UPDATE SET ', expect ON, actual ON pos 37, line 1, column 35, token ON : insert into test(k,v) values (1,2) ON CONFLICT (k) DO UPDATE SET v = EXCLUDED.v; at com.alibaba.druid.wall.WallFilter.checkInternal(WallFilter.java:798) at com.alibaba.druid.wall.WallFilter.connection_prepareStatement(WallFilter.java:251) at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:473) at com.alibaba.druid.filter.FilterAdapter.connection_prepareStatement(FilterAdapter.java:929) at com.alibaba.druid.filter.FilterEventAdapter.connection_prepareStatement(FilterEventAdapter.java:122) Caused by: com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'1,2) ON CONFLICT (k) DO UPDATE SET ', expect ON, actual ON pos 37, line 1, column 35, token ON at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:285) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:395) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:79) at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:622) at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:576)</body>
		<created>2017-10-22 09:02:56</created>
		<closed>2017-10-27 15:24:42</closed>
	</bug>
	<bug>
		<id>2058</id>
		<title>监控页面重定向问题</title>
		<body>1.1.4版本中，直接访问数据源URL：http://127.0.0.1:8080/druid/datasource.html，返回http://127.0.0.1:8080/druid/druid/druid/druid/druid/druid/druid/druid/druid/druid/druid/druid/druid/druid/druid/druid/druid/druid/druid/druid/druid/login.html</body>
		<created>2017-10-21 07:27:09</created>
		<closed>2017-10-27 15:25:00</closed>
	</bug>
	<bug>
		<id>2057</id>
		<title>UPDATE 中有两个INNER JOIN 时报错</title>
		<body>1.1.4版本 UPDATE 中有两个INNER JOIN 时报错，SQL大概如下： UPDATE t1 INNER JOIN t2 ON t1.id = t2.id INNER JOIN t3 cm ON  t3.id2= t1.id2  SET t1.name=..............  错误信息如下： Caused by: java.lang.NullPointerException at com.alibaba.druid.wall.spi.WallVisitorUtils.checkUpdate(WallVisitorUtils.java:849)  看了下代码：   public SQLName getTableName() {        if (tableSource instanceof SQLExprTableSource) {             return ((SQLExprTableSource) tableSource).getName();         }          if (tableSource instanceof SQLJoinTableSource) {             SQLTableSource left = ((SQLJoinTableSource) tableSource).getLeft();             if (left instanceof SQLExprTableSource) {                 return ((SQLExprTableSource) left).getName();             }         }         return null; }  这里的left其实还是SQLJoinTableSource，所以此方法直接return null 导致出现NullPointerException</body>
		<created>2017-10-20 12:42:26</created>
		<closed>2017-10-27 15:25:13</closed>
	</bug>
	<bug>
		<id>2055</id>
		<title>符号‘~’解析有误</title>
		<body>现象：     ‘ ~ (id = 1) ’和‘ ~ id = 1”应该拥有不同的语义，但是通过druid解析的结果相同   原因：     在解析过程中将~之后的内容当作一个表达式来解析，但实际上应该和‘!’的解析逻辑相同</body>
		<created>2017-10-20 10:03:14</created>
		<closed>2017-10-27 15:25:27</closed>
	</bug>
	<bug>
		<id>2053</id>
		<title>SHOW tables IN db_name 解析有误</title>
		<body>在mysql的官网中，show tables 语法如下   SHOW [FULL] TABLES   [{FROM | IN} db_name]   [LIKE 'pattern' | WHERE expr] 但是在解析器中不支持show tables in db_name ......</body>
		<created>2017-10-20 09:46:08</created>
		<closed>2017-10-27 15:25:58</closed>
	</bug>
	<bug>
		<id>2051</id>
		<title>hql 解析报错</title>
		<body>脚本内容： ``` drop table if EXISTS test.test; create table if not EXISTS test.test stored as parquet as select *  from test.test; ``` 程序片段： ```  String dbType = JdbcConstants.HIVE;   List&lt;SQLStatement&gt; stmtList = SQLUtils.parseStatements(sql, dbType); ``` 错误信息： ``` Exception in thread "main" com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'e if EXISTS test.test; create table', expect EXISTS, actual EXISTS pos 21, line 2, column 15, token EXISTS at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:285) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:395) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:68) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:461) at com.sf.open.tools.DruidTest.main(DruidTest.java:38) ``` 版本：  &lt;dependency&gt;             &lt;groupId&gt;com.alibaba&lt;/groupId&gt;             &lt;artifactId&gt;druid&lt;/artifactId&gt;             &lt;version&gt;1.1.4&lt;/version&gt;         &lt;/dependency&gt;</body>
		<created>2017-10-20 06:37:34</created>
		<closed>2017-10-27 15:26:07</closed>
	</bug>
	<bug>
		<id>2046</id>
		<title>Oracle10g 使用Driud连接池后，会时不时出现java.sql.SQLException: connection holder is null错误的疑似BUG</title>
		<body>最近在系统长时间运行后，如果在Oracle后台，KILL了一个Session之后，由于系统还是在频繁使用连接，我把timeBetweenEvictionRunsMillis设置为10秒，但是好像还是不会把这种失效的链接从连接池中清除掉。还是会继续让业务调用，造成经常出现connection holder is null的错误，同时ExceptionSorter好像也没有把这种报错的连接抛弃掉，请问这个是否是druid的BUG？还是说我的配置哪里有问题呢？配置和错误信息如下： 配置如下：  `&lt;Resource` name="jdbc/XXXXX"      auth="Container"      factory="com.alibaba.druid.pool.DruidDataSourceFactory"     type="javax.sql.DataSource"  driverClassName="oracle.jdbc.driver.OracleDriver"  url="jdbc:oracle:thin:@X.X.X.X:1521:orcl"  username="USERNAME"  password="PASSWORD"  initialSize="20" minIdle="0" maxActive="100" maxWait="1000" removeabandoned="false" removeabandonedtimeout="18000" validationQuery="select 1 from dual" testWhileIdle="true" testOnBorrow="false" testOnReturn="false" timeBetweenEvictionRunsMillis="10000" poolPreparedStatements="true" maxOpenPreparedStatements="100" filters="stat,log4j" /&gt;`  错误信息如下： SQL [SELECT CO1,CO2,CO3,CO4,CO5 FROM TABLE1 WHERE KEY1='111' order by CO1]; SQL state [null]; error code [0]; connection holder is null; nested exception is java.sql.SQLException: connection holder is null         at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:83)         at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:80)         at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:80)         at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:406)         at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:455)         at org.springframework.jdbc.core.JdbcTemplate.query(JdbcTemplate.java:463)         at org.springframework.jdbc.core.JdbcTemplate.queryForList(JdbcTemplate.java:494)         ........ Caused by: java.sql.SQLException: ORA-00028: your session has been killed          at oracle.jdbc.driver.DatabaseError.throwSqlException(DatabaseError.java:112)         at oracle.jdbc.driver.T4CTTIoer.processError(T4CTTIoer.java:331)         at oracle.jdbc.driver.T4CTTIoer.processError(T4CTTIoer.java:288)         at oracle.jdbc.driver.T4C8Oall.receive(T4C8Oall.java:745)         at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:216)         at oracle.jdbc.driver.T4CPreparedStatement.executeForRows(T4CPreparedStatement.java:966)         at oracle.jdbc.driver.OracleStatement.executeMaybeDescribe(OracleStatement.java:1062)         at oracle.jdbc.driver.T4CPreparedStatement.executeMaybeDescribe(T4CPreparedStatement.java:850)         at oracle.jdbc.driver.OracleStatement.doExecuteWithTimeout(OracleStatement.java:1134)         at oracle.jdbc.driver.OraclePreparedStatement.executeInternal(OraclePreparedStatement.java:3339)         at oracle.jdbc.driver.OraclePreparedStatement.execute(OraclePreparedStatement.java:3445)         at com.alibaba.druid.filter.FilterChainImpl.preparedStatement_execute(FilterChainImpl.java:3051)         at com.alibaba.druid.filter.FilterEventAdapter.preparedStatement_execute(FilterEventAdapter.java:440)         at com.alibaba.druid.filter.FilterChainImpl.preparedStatement_execute(FilterChainImpl.java:3049)         at com.alibaba.druid.filter.FilterEventAdapter.preparedStatement_execute(FilterEventAdapter.java:440)         at com.alibaba.druid.filter.FilterChainImpl.preparedStatement_execute(FilterChainImpl.java:3049)         at com.alibaba.druid.proxy.jdbc.PreparedStatementProxyImpl.execute(PreparedStatementProxyImpl.java:167)         at com.alibaba.druid.pool.DruidPooledPreparedStatement.execute(DruidPooledPreparedStatement.java:494)       ... 40 more</body>
		<created>2017-10-13 08:36:38</created>
		<closed>2017-10-27 15:26:33</closed>
	</bug>
	<bug>
		<id>2041</id>
		<title>db2解析带有WITH UR的SQL语句时报错</title>
		<body>在解析带有WITH UR的SQL语句时会报syntax error, expect ROLLUP, actual IDENTIFIER, pos 851, line 1, column 849, token IDENTIFIER UR的错误</body>
		<created>2017-10-12 02:08:49</created>
		<closed>2017-10-27 15:26:16</closed>
	</bug>
	<bug>
		<id>2037</id>
		<title>db2 的format问题</title>
		<body>SQL： SELECT LATN_ID,   CASE WHEN BUREAU_KEY = 116 THEN 46 ELSE BUREAU_KEY END BUREAU_KEY,        SUM(COALESCE(ADD_USER_CNT, 0)) ADD_SUM,         0 USER_ACCT,        0 USER_ACCT_LY   FROM MK.M_BROAD_BAND_USER_FACT  WHERE THE_DATE BETWEEN SUBSTR('{THISMONTH}', 1, 4) || '-01-01' AND '{THISMONTH}'  GROUP BY LATN_ID,   CASE WHEN BUREAU_KEY = 116 THEN 46 ELSE BUREAU_KEY END  UNION ALL SELECT LATN_ID,   CASE WHEN BUREAU_KEY = 116 THEN 46 ELSE BUREAU_KEY END BUREAU_KEY,        0 ADD_SUM,        SUM(COALESCE(BILL_USER_CNT, 0)) USER_ACCT,         0 USER_ACCT_LY   FROM MK.M_BROAD_BAND_USER_FACT  WHERE THE_DATE = '{THISMONTH}'  GROUP BY LATN_ID,   CASE WHEN BUREAU_KEY = 116 THEN 46 ELSE BUREAU_KEY END  UNION ALL SELECT LATN_ID,   CASE WHEN BUREAU_KEY = 116 THEN 46 ELSE BUREAU_KEY END BUREAU_KEY,        0 ADD_SUM,        0 USER_ACCT,        SUM(COALESCE(BILL_USER_CNT, 0)) USER_ACCT_LY     FROM MK.M_BROAD_BAND_USER_FACT  WHERE THE_DATE = DATE(SUBSTR('{THISMONTH}', 1, 4) || '-01-01') - 1 MONTHS  GROUP BY LATN_ID,   CASE WHEN BUREAU_KEY = 116 THEN 46 ELSE BUREAU_KEY END； 对其进行format时报syntax error, error in :' - 1 MONTHS GROUP BY LATN_ID,CASE W', expect IDENTIFIER, actual IDENTIFIER pos 924, line 1, column 918, token IDENTIFIER MONTHS错误，解析时可以正常解析。</body>
		<created>2017-10-10 06:35:14</created>
		<closed>2017-10-27 15:26:42</closed>
	</bug>
	<bug>
		<id>2033</id>
		<title>format db2 建表语句出错</title>
		<body>SQL： CREATE TABLE MK.KPI_AREA_SORT_FACT_LATN_ID_MID (   LATN_ID           INTEGER,   BUREAU_KEY        INTEGER,   ADD_SUM           BIGINT,   USER_ACCT         BIGINT,   USER_ACCT_LY      BIGINT,   TYPE_ID           INTEGER )   DATA CAPTURE NONE   IN WH_APP_TEMP   PARTITIONING KEY (LATN_ID,BUREAU_KEY,ADD_SUM  ) USING HASHING;  在对该语句进行format时报语法错误：syntax error, error in :'GER )DATA CAPTURE NONE IN WH_APP_TE', expect IDENTIFIER, actual IDENTIFIER pos 205, line 1, column 202, token IDENTIFIER DATA  但是对该语句进行解析时可以正常解析。</body>
		<created>2017-10-09 01:07:25</created>
		<closed>2017-10-27 15:24:03</closed>
	</bug>
	<bug>
		<id>2028</id>
		<title>不支持 MySQL 建表时存在索引</title>
		<body>我在单元测试的时候用的会重新初始化测试数据库已便保证是测试所需的结构和数据。  然而在建表的时候抛错了，语句如下：  ```sql DROP TABLE IF EXISTS `admin`; CREATE TABLE `admin` (   `id` char(20) NOT NULL,   `username` varchar(16) NOT NULL COMMENT '用户名',   `password` varchar(32) NOT NULL COMMENT '密码',   `permission` varchar(255) NOT NULL DEFAULT '' COMMENT '权限',   PRIMARY KEY (`id`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='管理员'; ``` 错误如下： ```sql Caused by: java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'id`) USING BTREE ) ENGINE=InnoDB DE', expect RPAREN, actual IDENTIFIER pos 224, line 1, column 219, token IDENTIFIER USING : CREATE TABLE `admin` ( `id` char(20) NOT NULL, `username` varchar(16) NOT NULL COMMENT '用户名', `password` varchar(32) NOT NULL COMMENT '密码', `permission` varchar(255) NOT NULL DEFAULT '' COMMENT '权限', PRIMARY KEY (`id`) USING BTREE ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='管理员' at com.alibaba.druid.wall.WallFilter.checkInternal(WallFilter.java:798) at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:780) at com.alibaba.druid.wall.WallFilter.statement_execute(WallFilter.java:413) at com.alibaba.druid.filter.FilterChainImpl.statement_execute(FilterChainImpl.java:2598) at com.alibaba.druid.filter.FilterAdapter.statement_execute(FilterAdapter.java:2473) at com.alibaba.druid.filter.FilterEventAdapter.statement_execute(FilterEventAdapter.java:188) at com.alibaba.druid.filter.FilterChainImpl.statement_execute(FilterChainImpl.java:2598) at com.alibaba.druid.proxy.jdbc.StatementProxyImpl.execute(StatementProxyImpl.java:147) at com.alibaba.druid.pool.DruidPooledStatement.execute(DruidPooledStatement.java:497) at org.springframework.jdbc.datasource.init.ScriptUtils.executeSqlScript(ScriptUtils.java:470) ... 116 more Caused by: com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'id`) USING BTREE ) ENGINE=InnoDB DE', expect RPAREN, actual IDENTIFIER pos 224, line 1, column 219, token IDENTIFIER USING at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:285) at com.alibaba.druid.sql.parser.SQLParser.accept(SQLParser.java:293) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlCreateTableParser.parseCreateTable(MySqlCreateTableParser.java:189) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseCreate(MySqlStatementParser.java:224) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:157) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:79) at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:622) at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:576) at com.alibaba.druid.wall.WallFilter.checkInternal(WallFilter.java:785) ... 125 more ``` Druid 版本： ``` &lt;dependency&gt;     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;     &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;     &lt;version&gt;1.1.4&lt;/version&gt;     &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; ```</body>
		<created>2017-10-04 23:17:16</created>
		<closed>2017-10-07 11:29:03</closed>
	</bug>
	<bug>
		<id>2021</id>
		<title>监控配置BUG</title>
		<body>若项目部署到ROOT,监控路径配置为&lt;url-pattern&gt;/sys/druid/*&lt;/url-pattern&gt;，访问的时候是有问题（404），没有了/sys/路径，访问的路径为：127.0.0.1:8080/druid/login.html,访问 127.0.0.1:8080/sys/druid/login.html没有问题，加上项目上下文也没有问题</body>
		<created>2017-09-29 05:48:22</created>
		<closed>2017-10-03 10:45:48</closed>
	</bug>
	<bug>
		<id>2020</id>
		<title>SpringBoot+Druid请教配置</title>
		<body>如何配置监控地址为"/admin/druid"..</body>
		<created>2017-09-29 04:20:25</created>
		<closed>2017-10-03 10:45:44</closed>
	</bug>
	<bug>
		<id>2015</id>
		<title>SQLUpdateStatement#output 输出where有误，直接调用了Object的toString</title>
		<body>Druid版本1.1.3  输入update语句 ```SQL update t set a=1,b=2 where a &gt; 1 ```  Parse 之后调用`SQLUpdateStatement`的 output语句输出： ```SQL UPDATE t SET a = 1, b = 2 WHERE com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr@ca624a2d ``` 调用输出的时候调用了   `SQLObjectImpl` 的 ```Java public void output(StringBuffer buf) {         buf.append(super.toString());     } ``` 这里直接调用了Object的 toString，导致失败</body>
		<created>2017-09-28 09:41:08</created>
		<closed>2017-10-03 10:48:14</closed>
	</bug>
	<bug>
		<id>2002</id>
		<title>以下pg语句执行通过，但是mergeSql里面报错了</title>
		<body># 1.环境 数据库：PG9.5 ORM： mybatis DRUID:1.1.3 # 2.sql，类似下面这种 ```sql select id,sum(uv[1]) uv1,sum(uv[2]) uv2 from xxxxx where a in                      (                           ?                      )   and ta-&gt;'taAge' ??|                                            '{                               1                          ,                              2                          ,                              3                          }'  group by id ```  # 3.错误输出 ``` 11:09:37.995 ERROR com.alibaba.druid.filter.stat.StatFilter:148 - merge sql error, dbType postgresql, sql : select id,sum(uv[1]) uv1,sum(uv[2]) uv2 from xxxxx where a in                      (                           ?                      )   and ta-&gt;'taAge' ??|                                            '{                               1                          ,                              2                          ,                              3                          }'  group by id  com.alibaba.druid.sql.parser.ParserException: ERROR. pos 516, line 21, column 36, token BAR at com.alibaba.druid.sql.parser.SQLExprParser.primary(SQLExprParser.java:697) at com.alibaba.druid.sql.dialect.postgresql.parser.PGExprParser.primary(PGExprParser.java:122) at com.alibaba.druid.sql.parser.SQLExprParser.bitXorRest(SQLExprParser.java:184) at com.alibaba.druid.sql.parser.SQLExprParser.bitXorRest(SQLExprParser.java:151) at com.alibaba.druid.sql.parser.SQLExprParser.bitXor(SQLExprParser.java:134) at com.alibaba.druid.sql.parser.SQLExprParser.multiplicative(SQLExprParser.java:213) at com.alibaba.druid.sql.parser.SQLExprParser.additive(SQLExprParser.java:1577) at com.alibaba.druid.sql.parser.SQLExprParser.shift(SQLExprParser.java:1607) at com.alibaba.druid.sql.parser.SQLExprParser.bitAnd(SQLExprParser.java:1464) at com.alibaba.druid.sql.parser.SQLExprParser.bitOr(SQLExprParser.java:1478) at com.alibaba.druid.sql.parser.SQLExprParser.equality(SQLExprParser.java:1493) at com.alibaba.druid.sql.parser.SQLExprParser.relational(SQLExprParser.java:1757) at com.alibaba.druid.sql.parser.SQLExprParser.andRest(SQLExprParser.java:1659) at com.alibaba.druid.sql.parser.SQLExprParser.expr(SQLExprParser.java:109) at com.alibaba.druid.sql.parser.SQLSelectParser.expr(SQLSelectParser.java:697) at com.alibaba.druid.sql.parser.SQLSelectParser.parseWhere(SQLSelectParser.java:318) at com.alibaba.druid.sql.dialect.postgresql.parser.PGSelectParser.query(PGSelectParser.java:135) at com.alibaba.druid.sql.parser.SQLSelectParser.select(SQLSelectParser.java:50) at com.alibaba.druid.sql.dialect.postgresql.parser.PGSQLStatementParser.parseSelect(PGSQLStatementParser.java:237) at com.alibaba.druid.sql.dialect.postgresql.parser.PGSQLStatementParser.parseSelect(PGSQLStatementParser.java:41) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:133) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:70) at com.alibaba.druid.sql.visitor.ParameterizedOutputVisitorUtils.parameterize(ParameterizedOutputVisitorUtils.java:42) at com.alibaba.druid.filter.stat.StatFilter.mergeSql(StatFilter.java:146) at com.alibaba.druid.filter.stat.StatFilter.createSqlStat(StatFilter.java:634) at com.alibaba.druid.filter.stat.StatFilter.statementPrepareAfter(StatFilter.java:310) at com.alibaba.druid.filter.FilterEventAdapter.connection_prepareStatement(FilterEventAdapter.java:124) at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:473) at com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl.prepareStatement(ConnectionProxyImpl.java:342) at com.alibaba.druid.pool.DruidPooledConnection.prepareStatement(DruidPooledConnection.java:350) at org.apache.ibatis.executor.statement.PreparedStatementHandler.instantiateStatement(PreparedStatementHandler.java:79) at org.apache.ibatis.executor.statement.BaseStatementHandler.prepare(BaseStatementHandler.java:88) at org.apache.ibatis.executor.statement.RoutingStatementHandler.prepare(RoutingStatementHandler.java:58) at org.apache.ibatis.executor.SimpleExecutor.prepareStatement(SimpleExecutor.java:76) at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:61) at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:303) at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:154) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:102) at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:82) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:120) at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:113) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:386) at com.sun.proxy.$Proxy22.selectList(Unknown Source) at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:205) at ..... ```  </body>
		<created>2017-09-25 03:19:30</created>
		<closed>2017-10-03 10:46:32</closed>
	</bug>
	<bug>
		<id>2001</id>
		<title>关于解析SYSDATE的问题</title>
		<body>在解析SYSDATE这个字段时，只支持解析为com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleSysdateExpr@7a7b0070这种形式吗？这样对解析结果不好进行处理啊，能不能支持直接解析为SYSDATE？</body>
		<created>2017-09-25 01:10:54</created>
		<closed>2017-10-03 11:09:25</closed>
	</bug>
	<bug>
		<id>1994</id>
		<title>SQL Parser在解析insert select语句时获取的字段不全</title>
		<body>SQL： INSERT INTO MKTG_H_EXEC_RESULT_FACT (THE_DATE, AREA_ID, SCENE_ID, MKTG_CNT, MKTG_SUC_CNT , TASK_CNT, TASK_F_CNT, TASK_F_SUC_CNT, CON_CNT, CON_SUC_CNT) SELECT TRUNC(SYSDATE), T1.AREA_ID , RTRIM(TO_CHAR(T2.PID)) , SUM(T1.MKTG_CNT), SUM(T1.MKTG_SUC_CNT) , SUM(T1.TASK_CNT), SUM(T1.TASK_F_CNT) , SUM(T1.TASK_F_SUC_CNT), SUM(T1.CON_CNT) , SUM(T1.CON_SUC_CNT) FROM MKTG_H_EXEC_RESULT_FACT T1, ( SELECT DISTINCT MKTG_PLAN_LVL1_ID AS PID, MKTG_PLAN_LVL4_ID AS SCENE_ID FROM DMN_MKTG_PLAN_TYPE UNION ALL SELECT DISTINCT MKTG_PLAN_LVL2_ID AS PID, MKTG_PLAN_LVL4_ID AS SCENE_ID FROM DMN_MKTG_PLAN_TYPE_TWO WHERE MKTG_PLAN_LVL2_ID &lt;&gt; MKTG_PLAN_LVL4_ID UNION ALL SELECT DISTINCT MKTG_PLAN_LVL3_ID AS PID, MKTG_PLAN_LVL4_ID AS SCENE_ID FROM DMN_MKTG_PLAN_TYPE WHERE MKTG_PLAN_LVL3_ID &lt;&gt; MKTG_PLAN_LVL4_ID ) T2 WHERE T1.THE_DATE = TRUNC(SYSDATE) AND T1.SCENE_ID = T2.SCENE_ID GROUP BY T1.AREA_ID, RTRIM(TO_CHAR(T2.PID)) 解析出来的字段： MKTG_H_EXEC_RESULT_FACT.THE_DATE MKTG_H_EXEC_RESULT_FACT.AREA_ID MKTG_H_EXEC_RESULT_FACT.SCENE_ID MKTG_H_EXEC_RESULT_FACT.MKTG_CNT MKTG_H_EXEC_RESULT_FACT.MKTG_SUC_CNT MKTG_H_EXEC_RESULT_FACT.TASK_CNT MKTG_H_EXEC_RESULT_FACT.TASK_F_CNT MKTG_H_EXEC_RESULT_FACT.TASK_F_SUC_CNT MKTG_H_EXEC_RESULT_FACT.CON_CNT MKTG_H_EXEC_RESULT_FACT.CON_SUC_CNT DMN_MKTG_PLAN_TYPE.MKTG_PLAN_LVL1_ID DMN_MKTG_PLAN_TYPE.MKTG_PLAN_LVL4_ID DMN_MKTG_PLAN_TYPE_TWO.MKTG_PLAN_LVL2_ID DMN_MKTG_PLAN_TYPE_TWO.MKTG_PLAN_LVL4_ID DMN_MKTG_PLAN_TYPE.MKTG_PLAN_LVL3_ID 很明显可以看到，只解析了后面的三个连在一起的select语句，第一个select语句的所有的字段都没有解析出来。 使用的解析方法： `OracleStatementParser parser = new OracleStatementParser(sql);  SQLInsertStatement insertStatement = (SQLInsertStatement) parser.parseInsert();  OracleSchemaStatVisitor visitor = new OracleSchemaStatVisitor();  insertStatement.accept(visitor);  Collection&lt;Column&gt; columns = visitor.getColumns();  for (Column column : columns) { System.out.println(column); }`</body>
		<created>2017-09-21 07:08:47</created>
		<closed>2017-10-03 11:09:56</closed>
	</bug>
	<bug>
		<id>1992</id>
		<title>sql server 序列查询问题</title>
		<body>开启wall filter执行`select next value for orderId`这个语句报错，报错信息如下  ``` Caused by: com.alibaba.druid.sql.parser.ParserException: syntax error, not support option : IDENTIFIER, pos 29, line 1, column 22, token IDENTIFIER OrderId at com.alibaba.druid.sql.dialect.sqlserver.parser.SQLServerSelectParser.select(SQLServerSelectParser.java:93) at com.alibaba.druid.sql.parser.SQLStatementParser.parseSelect(SQLStatementParser.java:2087) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:143) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:93) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:89) at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:620) at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:574) at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:712) ... 160 common frames omitted ``` 请问是因为什么原因</body>
		<created>2017-09-21 02:28:34</created>
		<closed>2017-10-03 10:47:59</closed>
	</bug>
	<bug>
		<id>1985</id>
		<title>1.1.3版本Lexer.scanAlias()方法校验过严</title>
		<body>1.1.3之前的版本能够校验过的sql在1.1.3版本中的Lexer.scanAlias()会抛出com.alibaba.druid.sql.parser.ParserException: unclosed str. pos 66, line 1, column 66, token COMMA异常，具体堆栈如下 com.alibaba.druid.filter.stat.StatFilter.mergeSql(StatFilter.java:148) -- merge sql error, dbType mysql, sql : SELECT totalNumber,  concat("",? , round(memberNumber, 0) , "") AS totalDisplay FROM ( SELECT count(1) AS totalNumber, SUM(memberNumber) AS memberNumber FROM( SELECT mmd.office_id AS departID,st.no AS staffNO,st.name AS staffName,COUNT(mmd.id) memberNumber FROM ms_member_def mmd LEFT JOIN sys_user st ON mmd.salesman_id=st.id AND st.del_flag='0' WHERE mmd.create_date BETWEEN (?) AND DATE_ADD((?),INTERVAL '23:59:59' HOUR_SECOND) AND mmd.del_flag='0' AND ('' IN (?) OR st.no IN (?)) AND ('' IN (?) OR mmd.office_id IN (?)) GROUP BY mmd.office_id,st.no ) gg  )temp com.alibaba.druid.sql.parser.ParserException: unclosed str. pos 66, line 1, column 66, token COMMA at com.alibaba.druid.sql.parser.Lexer.scanAlias(Lexer.java:1042) ~[druid-1.1.3.jar:1.1.3] at com.alibaba.druid.sql.parser.Lexer.nextToken(Lexer.java:586) ~[druid-1.1.3.jar:1.1.3] at com.alibaba.druid.sql.parser.SQLExprParser.exprList(SQLExprParser.java:1118) ~[druid-1.1.3.jar:1.1.3] at com.alibaba.druid.sql.parser.SQLExprParser.methodRest(SQLExprParser.java:964) ~[druid-1.1.3.jar:1.1.3] at com.alibaba.druid.sql.parser.SQLExprParser.parseSelectItem(SQLExprParser.java:2604) ~[druid-1.1.3.jar:1.1.3]</body>
		<created>2017-09-19 03:26:22</created>
		<closed>2017-10-03 10:45:20</closed>
	</bug>
	<bug>
		<id>1982</id>
		<title>无法解析CONCAT</title>
		<body>在1.0.31版本下和1.1.3版本下均不能解析如下语句。 select  ID, AUTHORITY_TYPE from t_authority a where authority_type like CONCAT('%', ?) 报错如下  Caused by: com.alibaba.druid.sql.parser.ParserException: ERROR. pos 209, line 1, column 203, token CONCAT at com.alibaba.druid.sql.parser.SQLExprParser.primary(SQLExprParser.java:697) at com.alibaba.druid.sql.parser.SQLExprParser.bitXor(SQLExprParser.java:133) at com.alibaba.druid.sql.parser.SQLExprParser.multiplicative(SQLExprParser.java:213) at com.alibaba.druid.sql.parser.SQLExprParser.additive(SQLExprParser.java:1577) </body>
		<created>2017-09-18 08:49:58</created>
		<closed>2017-10-03 10:47:33</closed>
	</bug>
	<bug>
		<id>1979</id>
		<title>Caused by: com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'upon OFF',expect IDENTIFIER, actual IDENTIFIER OFF</title>
		<body>SQLServer执行DDL：set identity_insert tb_coupon OFF 报错： java.lang.RuntimeException: java.lang.RuntimeException: java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'upon OFF',expect IDENTIFIER, actual IDENTIFIER OFF : set identity_insert tb_coupon OFF at com.sitv.skyshop.datareceiver.service.SQLServerService$1.doInConnection(SQLServerService.java:68) at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:353) at com.sitv.skyshop.datareceiver.service.SQLServerService.update(SQLServerService.java:49) at com.sitv.skyshop.datareceiver.recevier.DataReceiver.receiv(DataReceiver.java:50) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:133) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:963) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:897) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872) at javax.servlet.http.HttpServlet.service(HttpServlet.java:648) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846) at javax.servlet.http.HttpServlet.service(HttpServlet.java:729) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:230) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165) at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165) at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:105) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165) at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165) at org.springframework.boot.web.support.ErrorPageFilter.doFilter(ErrorPageFilter.java:115) at org.springframework.boot.web.support.ErrorPageFilter.access$000(ErrorPageFilter.java:59) at org.springframework.boot.web.support.ErrorPageFilter$1.doFilterInternal(ErrorPageFilter.java:90) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.springframework.boot.web.support.ErrorPageFilter.doFilter(ErrorPageFilter.java:108) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:192) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:165) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:199) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:108) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:472) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:79) at org.apache.catalina.valves.AbstractAccessLogValve.invoke(AbstractAccessLogValve.java:620) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:349) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:784) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:802) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1452) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Unknown Source) Caused by: java.lang.RuntimeException: java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'upon OFF',expect IDENTIFIER, actual IDENTIFIER OFF : set identity_insert tb_coupon OFF at com.sitv.skyshop.datareceiver.service.SQLServerService.setIdentityInsertStat(SQLServerService.java:122) at com.sitv.skyshop.datareceiver.service.SQLServerService.setIdentityInsertStatOff(SQLServerService.java:101) at com.sitv.skyshop.datareceiver.service.SQLServerService.access$0(SQLServerService.java:100) at com.sitv.skyshop.datareceiver.service.SQLServerService$1.doInConnection(SQLServerService.java:52) ... 68 common frames omitted Caused by: java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'upon OFF',expect IDENTIFIER, actual IDENTIFIER OFF : set identity_insert tb_coupon OFF at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:724) at com.alibaba.druid.wall.WallFilter.connection_prepareStatement(WallFilter.java:252) at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:448) at com.alibaba.druid.filter.FilterAdapter.connection_prepareStatement(FilterAdapter.java:928) at com.alibaba.druid.filter.FilterEventAdapter.connection_prepareStatement(FilterEventAdapter.java:122) at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:448) at com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl.prepareStatement(ConnectionProxyImpl.java:342) at com.alibaba.druid.pool.DruidPooledConnection.prepareStatement(DruidPooledConnection.java:331) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at org.springframework.jdbc.core.JdbcTemplate$CloseSuppressingInvocationHandler.invoke(JdbcTemplate.java:1490) at com.sun.proxy.$Proxy74.prepareStatement(Unknown Source) at com.sitv.skyshop.datareceiver.service.SQLServerService.setIdentityInsertStat(SQLServerService.java:110) ... 71 common frames omitted Caused by: com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'upon OFF',expect IDENTIFIER, actual IDENTIFIER OFF at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:232) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:407) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:145) at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:620) at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:574) at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:711) ... 85 common frames omitted</body>
		<created>2017-09-16 06:41:32</created>
		<closed>2017-10-03 10:47:00</closed>
	</bug>
	<bug>
		<id>1970</id>
		<title>关于merge into 中update语句的字段计算的问题</title>
		<body>在 merge into中update语句中如果有的字段进行了计算，如： WHEN MATCHED THEN UPDATE SET A.SUM_CHRG_YS = ROUND(B.TOTAL_CHARGE * 1.00 / 10000, 2), A.CHARGE = B.THIS_CHARGE; 解析出来的items变成了 [A.SUM_CHRG_YS = ROUND(com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr@4f6fff9f, 2),  A.CHARGE = B.THIS_CHARGE] 想请教一下com.alibaba.druid.sql.ast.expr.SQLBinaryOpExpr@4f6fff9f代表的是什么意思，能不能直接将字段解析出来？ 具体SQL语句如下： MERGE INTO ( SELECT * FROM KPI_M_CW_INCOME_FACT_BAK WHERE THE_DATE = '{THISMONTH}' AND AREA_LEVEL &lt;= 1 AND TYPE_ID = '2' ) A USING ( SELECT * FROM M_HEALTH_APPRAISE_LOAD WHERE THE_DATE = TRUNC(SYSDATE) AND AREA_LEVEL &lt;= 1 ) B ON (A.AREA_ID = B.AREA_ID AND A.AREA_LEVEL = B.AREA_LEVEL)  WHEN MATCHED THEN UPDATE SET A.SUM_CHRG_YS = ROUND(B.TOTAL_CHARGE * 1.00 / 10000, 2), A.CHARGE = B.THIS_CHARGE;</body>
		<created>2017-09-13 08:27:47</created>
		<closed>2017-10-03 11:09:43</closed>
	</bug>
	<bug>
		<id>1969</id>
		<title> No enum constant com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleIntervalType.second</title>
		<body>1.1.2 oracle 11g Oracle10gDialect  sql: select * from cp_data_edit_lock a where a.lock_time &gt; sysdate -  interval '58' second  and datatype_code='ANY'    java.lang.IllegalArgumentException: No enum constant com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleIntervalType.second  at java.lang.Enum.valueOf(Enum.java:236)  at com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleIntervalType.valueOf(OracleIntervalType.java:18)  at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.parseInterval(OracleExprParser.java:892)  at com.alibaba.druid.sql.parser.SQLExprParser.primary(SQLExprParser.java:623)  at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.primary(OracleExprParser.java:457)  at com.alibaba.druid.sql.parser.SQLExprParser.bitXor(SQLExprParser.java:112)  at com.alibaba.druid.sql.parser.SQLExprParser.multiplicative(SQLExprParser.java:192)  at com.alibaba.druid.sql.parser.SQLExprParser.additiveRest(SQLExprParser.java:1470)  at com.alibaba.druid.sql.parser.SQLExprParser.additive(SQLExprParser.java:1453)  at com.alibaba.druid.sql.parser.SQLExprParser.shift(SQLExprParser.java:1480)  at com.alibaba.druid.sql.parser.SQLExprParser.bitAnd(SQLExprParser.java:1341)  at com.alibaba.druid.sql.parser.SQLExprParser.bitOr(SQLExprParser.java:1355)  at com.alibaba.druid.sql.parser.SQLExprParser.relationalRest(SQLExprParser.java:1601)  at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.relationalRest(OracleExprParser.java:957)  at com.alibaba.druid.sql.parser.SQLExprParser.exprRest(SQLExprParser.java:103)  at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.exprRest(OracleExprParser.java:1146)  at com.alibaba.druid.sql.parser.SQLExprParser.expr(SQLExprParser.java:92)  at com.alibaba.druid.sql.parser.SQLSelectParser.expr(SQLSelectParser.java:599)  at com.alibaba.druid.sql.parser.SQLSelectParser.parseWhere(SQLSelectParser.java:260)  at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.query(OracleSelectParser.java:275)  at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.select(OracleSelectParser.java:70)  at com.alibaba.druid.sql.dialect.oracle.parser.OracleStatementParser.parseStatementList(OracleStatementParser.java:94)  at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:78)  at com.alibaba.druid.sql.visitor.ParameterizedOutputVisitorUtils.parameterize(ParameterizedOutputVisitorUtils.java:43)  at com.alibaba.druid.filter.stat.StatFilter.mergeSql(StatFilter.java:146)  at com.alibaba.druid.filter.stat.StatFilter.createSqlStat(StatFilter.java:634)  at com.alibaba.druid.filter.stat.StatFilter.statementPrepareAfter(StatFilter.java:310)  at com.alibaba.druid.filter.FilterEventAdapter.connection_prepareStatement(FilterEventAdapter.java:124)  at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:473)  at com.alibaba.druid.filter.FilterAdapter.connection_prepareStatement(FilterAdapter.java:929)  at com.alibaba.druid.filter.FilterEventAdapter.connection_prepareStatement(FilterEventAdapter.java:122)  at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:473)  at com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl.prepareStatement(ConnectionProxyImpl.java:342)  at com.alibaba.druid.pool.DruidPooledConnection.prepareStatement(DruidPooledConnection.java:350) </body>
		<created>2017-09-13 07:32:11</created>
		<closed>2017-10-03 10:44:47</closed>
	</bug>
	<bug>
		<id>1953</id>
		<title>SQLUtils.toStatementList()解析SQLServer 语句报错</title>
		<body>error: com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'de] GO CREATE TABLE [dbo].[Adode]', expect IDENTIFIER, actual IDENTIFIER pos 133, line 5, column 26, token IDENTIFIER GO  SQLServer: ``` -- ---------------------------- -- Table structure for Adode -- ---------------------------- DROP TABLE [dbo].[Adode] GO CREATE TABLE [dbo].[Adode] ( [Ad_Work_Start_Time] varchar(255) NULL, [Ad_Work_Stop_Time] varchar(255) NULL, [Ad_Wait_Start_Time] varchar(255) NULL, [Ad_Wait_Stop_Time] varchar(255) NULL, [Order_ID] varchar(255) NOT NULL ) ```</body>
		<created>2017-09-06 05:23:01</created>
		<closed>2017-10-03 10:44:33</closed>
	</bug>
	<bug>
		<id>1945</id>
		<title>POSTGRESQL format 错误!</title>
		<body>POSTGRESQL格式化错误，原始SQL是像这样的： `SELECT to_char((CreateDate || ' ' || CAST (HourArgment AS VARCHAR) || ':00:00') :: TIMESTAMP,'YYYY-MM-DD HH24') "intoTime " FROM analyzedata.StatTime AS cs WHERE 1 = 1 AND cs.CreateDate &gt;= to_date( '2017-08-31 00:00:00', 'YYYY-MM-DD HH24:MI:SS' ) AND cs.CreateDate &lt;= to_date( '2017-08-31 23:00:00', 'YYYY-MM-DD HH24:MI:SS' ) GROUP BY to_char(( CreateDate || ' ' || CAST (HourArgment AS VARCHAR) || ':00:00') :: TIMESTAMP, 'YYYY-MM-DD HH24')`  用Druid里面的SQLUtils.format(originalSQL, JdbcConstants.POSTGRESQL)) 格式化输出来是这样的：  `SELECT to_char(CreateDate || ' ' || CAST(HourArgment AS VARCHAR) || ':00:00'::TIMESTAMP, 'YYYY-MM-DD HH24') AS "intoTime " FROM analyzedata.StatTime cs WHERE 1 = 1 AND cs.CreateDate &gt;= to_date('2017-08-31 00:00:00', 'YYYY-MM-DD HH24:MI:SS') AND cs.CreateDate &lt;= to_date('2017-08-31 23:00:00', 'YYYY-MM-DD HH24:MI:SS') GROUP BY to_char(CreateDate || ' ' || CAST(HourArgment AS VARCHAR) || ':00:00'::TIMESTAMP, 'YYYY-MM-DD HH24')` 'to_char' 的两层括号 '(())' 被格式化成了一层'()'.  **Before:** `to_char((CreateDate || ' ' || CAST (HourArgment AS VARCHAR) || ':00:00') :: TIMESTAMP,'YYYY-MM-DD HH24') "intoTime "` **After:** `to_char(CreateDate || ' ' || CAST(HourArgment AS VARCHAR) || ':00:00'::TIMESTAMP, 'YYYY-MM-DD HH24') AS "intoTime "` Druid version: 1.1.2 (Github 最新版源码来下来也是一样的结果) JVM：1.8</body>
		<created>2017-09-03 07:19:40</created>
		<closed>2017-09-04 07:13:42</closed>
	</bug>
	<bug>
		<id>1943</id>
		<title>MySqlOptimizeStatement not allow : optimize table </title>
		<body>通过jdbc执行 ：`optimize table  table1` 时出现以下错误： ``` Caused by: java.sql.SQLException: sql injection violation, class com.alibaba.druid.sql.dialect.mysql.ast.statement.MySqlOptimizeStatement not allow : optimize table table1         at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:728)         at com.alibaba.druid.wall.WallFilter.statement_execute(WallFilter.java:398)         at com.alibaba.druid.filter.FilterChainImpl.statement_execute(FilterChainImpl.java:2487)         at com.alibaba.druid.filter.FilterAdapter.statement_execute(FilterAdapter.java:2451)         at com.alibaba.druid.filter.FilterEventAdapter.statement_execute(FilterEventAdapter.java:188)         at com.alibaba.druid.filter.FilterChainImpl.statement_execute(FilterChainImpl.java:2487)         at com.alibaba.druid.proxy.jdbc.StatementProxyImpl.execute(StatementProxyImpl.java:137)         at com.alibaba.druid.pool.DruidPooledStatement.execute(DruidPooledStatement.java:421) ```  这是WallFilter拦截造成的吗？ 应当如何配置才能执行？</body>
		<created>2017-09-02 06:38:08</created>
		<closed>2017-09-04 10:56:25</closed>
	</bug>
	<bug>
		<id>1941</id>
		<title>H2数据库创建触发器SQL解析异常</title>
		<body>2017-09-01 19:39:22 DEBUG [org.springframework.jdbc.core.JdbcTemplate] org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:417)- Executing SQL statement [create trigger employee_trigger after insert,update,delete on employee for each row call "test.redisson.h2cluster.trigger.ClusterTrigger"] 2017-09-01 19:39:22 DEBUG [org.springframework.jdbc.datasource.DataSourceUtils] org.springframework.jdbc.datasource.DataSourceUtils.doGetConnection(DataSourceUtils.java:110)- Fetching JDBC Connection from DataSource 2017-09-01 19:39:22 ERROR [com.alibaba.druid.filter.stat.StatFilter] com.alibaba.druid.filter.stat.StatFilter.mergeSql(StatFilter.java:148)- merge sql error, dbType h2, sql : **create trigger employee_trigger after insert,update,delete on employee for each row call "test.redisson.h2cluster.trigger.ClusterTrigger"** com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'fter insert,update,delete on employ',expect ON, actual COMMA pos 45, line 1, column 45, token COMMA at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:280) at com.alibaba.druid.sql.parser.SQLParser.accept(SQLParser.java:288) at com.alibaba.druid.sql.parser.SQLStatementParser.parseCreateTrigger(SQLStatementParser.java:1992) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseCreate(MySqlStatementParser.java:348) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:155) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:78) at com.alibaba.druid.sql.visitor.ParameterizedOutputVisitorUtils.parameterize(ParameterizedOutputVisitorUtils.java:43) at com.alibaba.druid.filter.stat.StatFilter.mergeSql(StatFilter.java:146) at com.alibaba.druid.filter.stat.StatFilter.createSqlStat(StatFilter.java:634) at com.alibaba.druid.filter.stat.StatFilter.internalBeforeStatementExecute(StatFilter.java:402) at com.alibaba.druid.filter.stat.StatFilter.statementExecuteBefore(StatFilter.java:350) at com.alibaba.druid.filter.FilterEventAdapter.statement_execute(FilterEventAdapter.java:185) at com.alibaba.druid.filter.FilterChainImpl.statement_execute(FilterChainImpl.java:2598) at com.alibaba.druid.proxy.jdbc.StatementProxyImpl.execute(StatementProxyImpl.java:153) at com.alibaba.druid.pool.DruidPooledStatement.execute(DruidPooledStatement.java:497) at org.springframework.jdbc.core.JdbcTemplate$1ExecuteStatementCallback.doInStatement(JdbcTemplate.java:421) at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:396) at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:428) at test.redisson.h2cluster.H2Manager.initTable(H2Manager.java:64) at test.redisson.h2cluster.H2Manager.&lt;init&gt;(H2Manager.java:52) at test.redisson.h2cluster.H2Manager.&lt;clinit&gt;(H2Manager.java:35) at test.redisson.h2cluster.H2DBService.&lt;init&gt;(H2DBService.java:32) at test.redisson.h2cluster.H2DBService.&lt;clinit&gt;(H2DBService.java:31) at test.redisson.h2cluster.H2ClusterManager.main(H2ClusterManager.java:33)</body>
		<created>2017-09-01 11:54:17</created>
		<closed>2017-10-03 10:44:24</closed>
	</bug>
	<bug>
		<id>1935</id>
		<title>关于sql解析的问题</title>
		<body>1.sql where条件解析出来以后不区分是and连接，还是or连接，对子查询有支持，无法识别 例子：select name from  student where id in (select sd_id from scole where scole &lt; 60 order by scole asc) or id = 2 order by name desc 2.limit 条件不识别 3.having条件合并进where条件中了 代码例子： ``` public static void main(String[] args) {  String DBTYPE = JdbcConstants.MYSQL; //String sql = "select name, course ,scole from student inner join scole on student.id = scole.sd_id where course = '数学' limit 10;"; //sql = "select name,course,sum(scole) as total from student where student.id in (select sd_id from scole where name='aaa') and scole in (1,2,3) group by name HAVING total &lt;60 order by scole desc limit 10 ,2 "; String sql = "select name from  student where id in (select sd_id from scole where scole &lt; 60 order by scole asc) or id = 2 order by name desc"; String format = SQLUtils.format(sql, DBTYPE); //System.out.println("formated sql :  " + format); List&lt;SQLStatement&gt; list = SQLUtils.parseStatements(sql, DBTYPE);  for (int i = 0; i &lt; list.size(); i++) { SQLStatement stmt = list.get(i);             MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();             stmt.accept(visitor);               //获取表名称             System.out.println("当前表 : " + visitor.getCurrentTable());             //获取操作方法名称,依赖于表名称             System.out.println("涉及到的所有表 : " + visitor.getTables());             Map&lt;Name, TableStat&gt; table_map = visitor.getTables();             for(Entry&lt;Name, TableStat&gt; entry : table_map.entrySet()){             Name name = entry.getKey();             name.getName();             //存储表的调度次数，包括select ，update等             TableStat ts = entry.getValue();                          }             //获取字段名称             System.out.println( visitor.getParameters());             //获取列名             System.out.println("查询的列信息 : " + visitor.getColumns());             Collection&lt;Column&gt; cc = visitor.getColumns();             //column 存储了表名，列名，以及列是出现的位置，where，select，groupby ，order             for(Column column : cc){                          }             System.out.println("conditions : " + visitor.getConditions() );             List&lt;Condition&gt; conditions = visitor.getConditions();             System.out.println("----------------------------");             for(Condition cond : conditions){             System.out.println( "column : " + cond.getColumn());             System.out.println( "operator : " + cond.getOperator());             System.out.println( "values  : " + cond.getValues());                          System.out.println("----------------------------");             }             System.out.println("group by : " + visitor.getGroupByColumns() );             System.out.println("order by : " + visitor.getOrderByColumns() );             System.out.println("relations ships  : " + visitor.getRelationships() );             System.out.println("alias map" + visitor.getAliasMap() );             System.out.println("Variants : " + visitor.getVariants()); } } ``` 输出 ``` 当前表 : scole 涉及到的所有表 : {student=Select, scole=Select} [] 查询的列信息 : [student.name, student.id, scole.sd_id, scole.scole, scole.id, scole.name] conditions : [student.id IN, scole.scole &lt; 60, scole.id = 2] ---------------------------- column : student.id operator : IN values  : [] ---------------------------- column : scole.scole operator : &lt; values  : [60] ---------------------------- column : scole.id operator : = values  : [2] ---------------------------- group by : [] order by : [scole.scole, scole.name] relations ships  : [] alias map{student=student, scole=scole, DUAL=null} Variants : {}  ``` 不知道是我理解错误了，还是用法不对</body>
		<created>2017-08-29 06:58:20</created>
		<closed>2017-11-27 09:33:31</closed>
	</bug>
	<bug>
		<id>1931</id>
		<title>SQLASTOutputVisitor存在bug</title>
		<body>    public boolean visit(MergeInsertClause x) {         print0(ucase ? "WHEN NOT MATCHED THEN INSERT" : "when not matched then insert");         if (x.getColumns().size() &gt; 0) {             print(' ');             printAndAccept(x.getColumns(), ", ");         }         print0(ucase ? " VALUES (" : " values (");    这里的insert后面的属性没有用小括号括起来。</body>
		<created>2017-08-26 13:28:36</created>
		<closed>2017-10-03 10:44:12</closed>
	</bug>
	<bug>
		<id>1925</id>
		<title>druid parser在解析oracle语句时，怎么解决oracle关键字做字段别名问题</title>
		<body>比如关键字STORE做字段别名：select (order.STORE - order.LAST_STORE) STORE from order; 报错为： com.alibaba.druid.sql.parser.ParserException: TODO : pos 45, line 1, column 40, token STORE at com.alibaba.druid.sql.dialect.oracle.parser.OracleStatementParser.parseStatementList(OracleStatementParser.java:615) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:78) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:419)</body>
		<created>2017-08-22 08:14:03</created>
		<closed>2017-09-04 07:48:16</closed>
	</bug>
	<bug>
		<id>1923</id>
		<title>oracle的几个ddl语句解析bug</title>
		<body>sql：CREATE INDEX dbobjs_idx ON dbobjs (created) LOCAL  解析错误：syntax error, error in :'ted) LOCAL ',expect LPAREN, actual EOF LOCAL  sql：CREATE INDEX dbobjs_idx ON dbobjs (created) global 解析错误：multi-statement not allowerror (1) : class com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleExprStatement not allow   sql：CREATE SEQUENCE "GJS_ZIXUN"."FINANCE_EXPLAIN_ID_GENERATOR" CACHE 2 解析报错：syntax error: TODO : pos 67, LITERAL_INT CACHE 经过测试：CACHE /ORDER/CYCLE 几个关键字都无法解析  sql：alter index idx_t1 rebuild 解析报错：class com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterIndexStatement not allow  </body>
		<created>2017-08-18 08:40:01</created>
		<closed>2017-09-04 07:47:48</closed>
	</bug>
	<bug>
		<id>1922</id>
		<title>druid 的连接ping功能不支持mysql 的 com.mysql.jdbc.ReplicationDriver</title>
		<body>druid 中 连接检查，优先使用的jdbc 的ping功能，如果不支持，就执行validationQuery检查。 但是ping功能不支持Mysql 的 ReplicationDriver。 `if (realDriverClassName.equals(JdbcConstants.MYSQL_DRIVER) //             || realDriverClassName.equals(JdbcConstants.MYSQL_DRIVER_6)) {             this.validConnectionChecker = new MySqlValidConnectionChecker();         }` 如果mysql服务器在超时情况下关闭了连接，而且使用ReplicationDriver时，执行validationQuery检查，只能检测主库的连接，不能检测从库的连接。就会报异常： com.mysql.jdbc.CommunicationsException: The last packet successfully received from the server was58129 seconds ago.The last packet sent successfully to the server was 58129 seconds ago, which is longer than the server configured value of 'wait_timeout'. You should consider either expiring and / or testing connection validity before use in your application, increasing the server configured values for client timeouts, or using the Connector / J connection property 'autoReconnect = true' to avoid this problem.   最好Ping功能，可以支持ReplicationDriver。</body>
		<created>2017-08-18 07:32:55</created>
		<closed>2017-09-04 07:47:39</closed>
	</bug>
	<bug>
		<id>1910</id>
		<title>oracle解析create index 出现重复表空间字句</title>
		<body>driud版本：1.1.1  create index idx_t12 on t1(id) tablespace users online; 解析后： CREATE INDEX idx_t12 ON t1(id) TABLESPACE users ONLINE TABLESPACE users  最后多了一个TABLESPACE users，如果前面不写tablespace字句，后面也不会有</body>
		<created>2017-08-15 03:52:41</created>
		<closed>2017-09-04 07:46:50</closed>
	</bug>
	<bug>
		<id>1905</id>
		<title>不支持COLLATE='utf8_general_ci'</title>
		<body>版本：1.1.2 String sql = "CREATE TABLE `tb_custom_vip_show_message` (`custom_vip_show_message_seq` INT(11) NOT NULL AUTO_INCREMENT,`show_channel_type` TINYINT(4) NOT NULL COMMENT '通道类型',PRIMARY KEY (`custom_vip_show_message_seq`))COMMENT='自定VIP显示表' COLLATE='utf8_general_ci' ENGINE=InnoDB;"; MySqlStatementParser parser = new MySqlStatementParser(sql, true); List&lt;SQLStatement&gt; list = parser.parseStatementList(); 报错 COLLATE='utf8_general_ci'解析为LITERAL_CHARS，不是IDENTIFIER，抛出异常。</body>
		<created>2017-08-14 05:53:02</created>
		<closed>2017-10-03 05:49:01</closed>
	</bug>
	<bug>
		<id>1899</id>
		<title>设置SelectLimit限制, 无法处理limit ?, ? 这种格式， 该怎么办</title>
		<body> ![image](https://user-images.githubusercontent.com/18274190/29204666-ef5cda08-7eaa-11e7-97e2-a872a4d1a29c.png)  ![image](https://user-images.githubusercontent.com/18274190/29204696-1ddbe716-7eab-11e7-9037-6288c91acc19.png)  Exception in thread "main" java.sql.SQLException: Parameter index out of range (2 &gt; number of parameters, which is 1). at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1075) at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:989) at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:984) at com.mysql.jdbc.SQLError.createSQLException(SQLError.java:929) at com.mysql.jdbc.PreparedStatement.checkBounds(PreparedStatement.java:3711) at com.mysql.jdbc.PreparedStatement.setInternal(PreparedStatement.java:3695) </body>
		<created>2017-08-11 07:42:02</created>
		<closed>2017-10-30 09:50:24</closed>
	</bug>
	<bug>
		<id>1894</id>
		<title>UNION SQL call SQLUtils.format() will return wrong value</title>
		<body>Hi, Here is a bug: Original SQL: select * from ( select seller_name from a where id &lt; 100 UNION  select seller_name from a where id &lt; 100 ) as temp limit 10  After SQLUtils.format(), the output would be: SELECT * FROM ( (SELECT seller_name FROM a WHERE id &lt; 100 UNION SELECT seller_name FROM a WHERE id &lt; 100) ) temp LIMIT 10  There is syntax error after format: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ') ) temp LIMIT 10' at line 9 </body>
		<created>2017-08-10 08:04:10</created>
		<closed>2017-09-04 07:45:53</closed>
	</bug>
	<bug>
		<id>1880</id>
		<title>MSSQL 2012的一些语法解析异常</title>
		<body>SQL监控中，解析OFFSET FETCH语法时失败(类似于  SELECT First Name + ' ' + Last Name FROM Employees ORDER BY First Name OFFSET 10 ROWS FETCH NEXT 5 ROWS ONLY;  这种语句)，是因为现在的版本还没支持到MSSQL 2012吗？</body>
		<created>2017-08-04 01:50:19</created>
		<closed>2017-10-03 11:04:19</closed>
	</bug>
	<bug>
		<id>1868</id>
		<title>oracle alter index 报错</title>
		<body>sql：alter index idx_t1 rebuild 解析报错：class com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleAlterIndexStatement not allow</body>
		<created>2017-07-27 03:07:42</created>
		<closed>2017-09-04 07:45:00</closed>
	</bug>
	<bug>
		<id>1867</id>
		<title>oracle create sequence不支持cache选项</title>
		<body>sql：CREATE SEQUENCE "GJS_ZIXUN"."FINANCE_EXPLAIN_ID_GENERATOR"  CACHE 2 解析报错：syntax error: TODO : pos 67, LITERAL_INT CACHE</body>
		<created>2017-07-27 02:52:14</created>
		<closed>2017-09-04 07:47:57</closed>
	</bug>
	<bug>
		<id>1866</id>
		<title>oracle create index加local或者global关键字报错</title>
		<body>sql：CREATE INDEX dbobjs_idx ON dbobjs (created) LOCAL  解析错误：syntax error, error in :'ted) LOCAL ',expect LPAREN, actual EOF LOCAL  sql：CREATE INDEX dbobjs_idx ON dbobjs (created) global 解析错误：multi-statement not allowerror (1) : class com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleExprStatement not allow</body>
		<created>2017-07-27 02:41:08</created>
		<closed>2017-09-04 07:47:32</closed>
	</bug>
	<bug>
		<id>1854</id>
		<title>druid-spring-boot 升级到1.1.1版本 数据库加密连接时 无法连接数据库</title>
		<body> 以下时配置信息: ![2](https://user-images.githubusercontent.com/21178565/28500966-c0db8be8-7004-11e7-8049-d5856f05a575.png) ![3](https://user-images.githubusercontent.com/21178565/28500973-d6aa69b2-7004-11e7-8a58-e2c432b30d3b.png)  下面时错误信息： ![aq 8s 12 6zfr 9re6d4c c](https://user-images.githubusercontent.com/21178565/28500939-38924150-7004-11e7-8c7d-61f6da2a9ddc.png)  **注：１．１．０版本正常**</body>
		<created>2017-07-23 16:08:49</created>
		<closed>2017-07-23 19:06:36</closed>
	</bug>
	<bug>
		<id>1849</id>
		<title>谓词IN使用函数date_format 解析模版参数为空</title>
		<body>原始SQL: select 1 from a where c1 in (date_format(date_add(curdate(), INTERVAL -7 DAY), '%Y%m%d')) 模版： SELECT ? FROM a WHERE c1 IN (?) 参数: [1,[]]</body>
		<created>2017-07-21 08:01:33</created>
		<closed>2017-07-23 19:07:12</closed>
	</bug>
	<bug>
		<id>1841</id>
		<title>merge sql error dbType postgresql</title>
		<body>{com.alibaba.druid.filter.stat.StatFilter:148}-merge sql error, dbType postgresql,  sql : select gid, kind, mapid, poi_id, telephone, admincode, x, y, zipcode, name, address, street, number,geom from public.v_poi order by public.v_poi.geom    &lt;-&gt;    st_point(?,?) limit 1  developer environment:spring4.2.5.RELEASE mybatis3.3.1 druid1.1.1 redis3.0.5; redis is used for cache; but both result and cache are correct :)</body>
		<created>2017-07-20 07:16:06</created>
		<closed>2017-07-23 19:07:21</closed>
	</bug>
	<bug>
		<id>1831</id>
		<title>复杂sql解析不正确的问题</title>
		<body>我有一个比较复杂一点的sql：  &gt; select sum(hd.paid_amount) from ( SELECT 'fl',cast(a.hosted_ymd as date) as hosted_ymd,a.user_id,'boss1',a.paid_amount,m.user_id,m.create_date,m.pmcode,n.type_name,n.product_name,n.acctype_id,n.acctype_name,n.account_name,n.plan FROM hive.bdc_dwd.dw_mk_copyright_order a left join hive.bdc_dwd.dw_mk_chance b on (a.chance_id=b.chance_id and b.acct_day='03') left join hive.bdc_dwd.dw_lg_stat_user m on (a.user_id =m.user_id and m.acct_day='03') left join hive.bdc_dwd.dw_lg_pmcode n on (m.pmcode=n.id and n.acct_day='03') where a.hosted_ymd between '2016-01-01' and '2017-06-30' and b.chance_type_group=3 and a.acct_day='03' union select 'fl',b.paid_date as hosted_ymd,b.user_id,'boss2',b.paid_amount,m.user_id,m.create_date,m.pmcode,n.type_name,n.product_name,n.acctype_id,n.acctype_name,n.account_name,n.plan from hive.bdc_dwd.dw_fx_chance a left join hive.bdc_dwd.dw_fx_chance_order b on (a.chance_id=b.chance_id and b.acct_day='03') left join hive.bdc_dwd.dw_lg_stat_user m on (a.user_id =m.user_id and m.acct_day='03') left join hive.bdc_dwd.dw_lg_pmcode n on (m.pmcode=n.id and n.acct_day='03') where a.project_id=1 and b.paid_amount&gt;0 and cast(b.paid_date as varchar(10))&gt;='2016-01-01' and cast(b.paid_date as varchar(10))&lt;='2017-06-30' and b.state=1 and a.acct_day='03' )hd  使用Druid Mysql语法解析后得到的结果不正确：  1、别名映射不对，在有union这种情况下，且union两边都有相同别名时，映射会出现覆盖和错乱 ![image](https://user-images.githubusercontent.com/1010797/28203373-12412b2e-68ac-11e7-8827-97175bcf0865.png)  对于a和b两个别名，对于union来说在两个子句下面别名对应了不同的数据表。而aliasMap中只解析出了基中的一部分。  2、因上面别名映射错乱的原因，对于别名无法正确解析到字段上，可能导致字段与数据表的归属出现问题： ![image](https://user-images.githubusercontent.com/1010797/28203514-a576a6d0-68ac-11e7-8a4a-66e940acd998.png)  b.paid_date 实际上是 dw_fx_chance_order表(别名：b）的字段。 而解析引擎解析成另一张表的字段。猜想可能与别名重复和覆盖有关。  这也许是一个bug，温少可以看看。   </body>
		<created>2017-07-14 07:59:01</created>
		<closed>2017-07-23 19:06:57</closed>
	</bug>
	<bug>
		<id>1828</id>
		<title>druid-springboot-starter 1.1.1 still use druid 1.1.0</title>
		<body>Hi  Today I change the druid-springboot-starter from 1.1.0 -&gt; 1.1.0, I find the dependency of druid still 1.1.0. I think this maybe a mistake.  below is the starter pom file content. &lt;properties&gt; &lt;druid.version&gt;1.1.0&lt;/druid.version&gt; &lt;spring-boot.version&gt;1.5.3.RELEASE&lt;/spring-boot.version&gt; &lt;/properties&gt;</body>
		<created>2017-07-13 09:45:21</created>
		<closed>2017-07-23 19:07:28</closed>
	</bug>
	<bug>
		<id>1808</id>
		<title>oracle interval语句解析bug</title>
		<body>druid版本：最新1.1.0 sql： create table month_part (c1 number,c3 date) partition by range(c3) interval(numtoyminterval (1,'month')) (partition part1 values less than (to_date('2010-01-01','YYYY-MM-DD')),  partition part2 values less than (to_date('2010-02-01','YYYY-MM-DD')) )  调用方法： OracleStatementParser parser=new OracleStatementParser(allSql); List&lt;SQLStatement&gt; stmtList=parser.parseStatementList(); for(SQLStatement stmt : stmtList) { System.out.println("druid parse sql is:"+stmt.toString());  }  此时输出的sql结果为： druid parse sql is:CREATE TABLE month_part ( c1 number, c3 date ) PARTITION BY RANGE (c3) INTERVAL numtoyminterval(1, 'month') ( PARTITION part1 VALUES LESS THAN (to_date('2010-01-01', 'YYYY-MM-DD')), PARTITION part2 VALUES LESS THAN (to_date('2010-02-01', 'YYYY-MM-DD')) ); interval后面numtoyminterval两边括号不见了，然后check报错 expect LPAREN, actual IDENTIFIER numtoyminterval  </body>
		<created>2017-07-04 08:31:08</created>
		<closed>2017-07-13 05:17:11</closed>
	</bug>
	<bug>
		<id>1807</id>
		<title>1.1.0中bug 1759没有修复啊</title>
		<body>之前提的partition bug解决，但comment被错误阻止问题在1.1.0中仍然存在，下面sql仍然报错，温少麻烦再看看，难道是我用错了吗？   sql is: COMMENT ON COLUMN "TB_CRM_MATERIAL"."INVALID_TIME" IS '生效时间'  调用方法： OracleStatementParser parser = new OracleStatementParser(sql); SQLStatement statement = parser.parseStatement();// 分号之后多语句忽略 OracleWallProvider provider = new OracleWallProvider(); provider.getConfig().setCommentAllow(true); WallCheckResult result1 = provider.check(sql);  执行报：class com.alibaba.druid.sql.ast.statement.SQLCommentStatement not allow</body>
		<created>2017-07-03 04:01:54</created>
		<closed>2017-07-13 05:17:20</closed>
	</bug>
	<bug>
		<id>1803</id>
		<title>distinct多列的时候查询数量BUG</title>
		<body>https://github.com/alibaba/druid/issues/1715  如果select distinct col1,col2... from tb ，这种情况count还是有问题。 即 queryBlock.getSelectList().size()大于1的情况。  if (option == SQLSetQuantifier.DISTINCT &amp;&amp; queryBlock.getSelectList().size() == 1) { SQLSelectItem firstItem = queryBlock.getSelectList().get(0); SQLAggregateExpr exp = new SQLAggregateExpr("COUNT", SQLAggregateOption.DISTINCT); exp.addArgument(firstItem.getExpr()); firstItem.setExpr(exp); queryBlock.setDistionOption(0);     }</body>
		<created>2017-06-29 03:03:34</created>
		<closed>2017-07-13 05:16:50</closed>
	</bug>
	<bug>
		<id>1798</id>
		<title>Druid解析子查询sql的查询条件的bug</title>
		<body>测试代码          String sql = "select * from t1 where b in (select b from t2) and a = 1";         MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();         MySqlStatementParser parser = new MySqlStatementParser(sql);         SQLStatement statement = parser.parseStatement();         statement.accept(visitor);         System.out.println(visitor.getConditions());  打印出来的查询条件是： [t1.b IN, **t2.a = 1**]  但是正常来说，第二个查询条件应该是t1.a = 1才对  问题版本号：1.0.31</body>
		<created>2017-06-28 07:11:51</created>
		<closed>2017-07-13 05:16:26</closed>
	</bug>
	<bug>
		<id>1796</id>
		<title>Spring boot  autoconfig下能否优化下setMinEvictableIdleTimeMillis与setMaxEvictableIdleTimeMillis顺序问题</title>
		<body>在springboot下的@ConfigurationProperties自动属性注入的时候，由于spring框架自动注入bean属性数据，导致会优先设置setMaxEvictableIdleTimeMillis，此时还未进行 setMinEvictableIdleTimeMillis属性的设置，但是setMinEvictableIdleTimeMillis的默认值会成为setMaxEvictableIdleTimeMillis判断的值。导致检查失败。</body>
		<created>2017-06-27 09:37:03</created>
		<closed>2017-07-13 05:16:32</closed>
	</bug>
	<bug>
		<id>1795</id>
		<title>select Union, actual UNION UNION, 设置了WallFilter的selectUnionCheck为FALSE不生效</title>
		<body>版本1.0.24 执行语句，在sqlserver客户端可以执行，但是通过druid检测报错。语句如下： SELECT TOP 100 * FROM      (SELECT ROW_NUMBER()         OVER (ORDER BY DateUpdated DESC) PAGE_ROW_NUMBER, *     FROM          (SELECT x.*         FROM              (SELECT TOP 2000 a.*             FROM pk_Battle a             WHERE a.RequestUserId = 33460323                     AND a.IsActive = 1                     AND a.BattleType &lt;&gt; 2                     AND a.Status NOT IN (0, 2)                     AND EXISTS                  (SELECT TOP 1 1                 FROM pk_BattleExt                 WHERE BattleId = a.Id                         AND RequestIsViewResults = 0)                 ORDER BY  a.Id DESC                 UNION                 SELECT TOP 1000 a.*                 FROM pk_Battle a                 WHERE a.ResponseUserId = 33460323                         AND a.IsActive = 1                         AND a.BattleType = 1                         AND a.Status NOT IN (0, 2)                         AND EXISTS                      (SELECT TOP 1 1                     FROM pk_BattleExt                     WHERE BattleId = a.Id                             AND ResponseIsViewResults = 0)                     ORDER BY  a.Id DESC) x) AS PAGE_TABLE_ALIAS) AS PAGE_TABLE_ALIAS                 WHERE PAGE_ROW_NUMBER &gt; 0             ORDER BY  PAGE_ROW_NUMBER  报错： Caused by: java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'DESC UNION SELECT TOP 1000 a.* FROM',expect RPAREN, actual UNION UNION : SELECT TOP 100 * FROM (SELECT ROW_NUMBER() OVER (ORDER BY DateUpdated DESC) PAGE_ROW_NUMBER, * FROM (SELECT x.* FROM (SELECT TOP 2000 a.* FROM pk_Battle a WHERE a.RequestUserId = ? AND a.IsActive = 1 AND a.BattleType &lt;&gt; 2 AND a.Status NOT IN (0, 2) AND EXISTS (SELECT TOP 1 1 FROM pk_BattleExt WHERE BattleId = a.Id AND RequestIsViewResults = 0) ORDER BY a.Id DESC UNION SELECT TOP 1000 a.* FROM pk_Battle a WHERE a.ResponseUserId = ? AND a.IsActive = 1 AND a.BattleType = 1 AND a.Status NOT IN (0, 2) AND EXISTS (SELECT TOP 1 1 FROM pk_BattleExt WHERE BattleId = a.Id AND ResponseIsViewResults = 0) ORDER BY a.Id DESC) x) AS PAGE_TABLE_ALIAS) AS PAGE_TABLE_ALIAS WHERE PAGE_ROW_NUMBER &gt; 0 ORDER BY PAGE_ROW_NUMBER </body>
		<created>2017-06-27 05:33:37</created>
		<closed>2017-07-13 05:17:01</closed>
	</bug>
	<bug>
		<id>1789</id>
		<title>postgres expect RPAREN, actual RECURSIVE</title>
		<body>postgres  有RECURSIVE，递归查询，但是貌似druid不支持？</body>
		<created>2017-06-21 10:53:26</created>
		<closed>2017-06-25 13:28:20</closed>
	</bug>
	<bug>
		<id>1775</id>
		<title>set语句支持有误</title>
		<body>```` mysql&gt; set character set utf8, names utf8mb4; Query OK, 0 rows affected (0.00 sec) ````  在druid中代码: ````         String sql = "set character set utf8, names utf8mb4;";         MySqlStatementParser parser = new MySqlStatementParser(sql);         SQLSetStatement set = (SQLSetStatement) parser.parseStatementList().get(0);         String output = SQLUtils.toMySqlString(set);         System.out.println(output); ````  测试报错： ```` com.alibaba.druid.sql.parser.ParserException: syntax error, error in :' set utf8, names utf8mb4;',expect COMMA, actual COMMA utf8  at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:262) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:373) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:84) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:80) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:75)  ```` </body>
		<created>2017-06-09 08:42:10</created>
		<closed>2017-06-25 13:27:23</closed>
	</bug>
	<bug>
		<id>1773</id>
		<title>数据库连接回滚数统计有误?</title>
		<body>StatFilter.java中public void connection_rollback(FilterChain chain, ConnectionProxy connection) throws SQLException重复调用两次dataSourceStat.getConnectionStat().incrementConnectionRollbackCount();？</body>
		<created>2017-06-08 07:33:17</created>
		<closed>2017-06-25 13:27:13</closed>
	</bug>
	<bug>
		<id>1762</id>
		<title>建表语句的注释无法解析出</title>
		<body>使用druid 版本1.0.29  比如我有建表语句 ```sql -- table-name-bean-name:some -- CREATE TABLE `some_table` (   `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键' } ``` 我想通过druid的SQLUtils获取 `table-name-bean-name:some` 注释 目的为了做代码生成(表名对应java bean名称)，但是无法获取该表注释，不知道什么方式可以获取 </body>
		<created>2017-06-01 08:45:43</created>
		<closed>2017-06-25 13:28:37</closed>
	</bug>
	<bug>
		<id>1759</id>
		<title>class com.alibaba.druid.sql.ast.statement.SQLCommentStatement not allow</title>
		<body> druid 版本：1.0.29  sql is: COMMENT ON COLUMN "TB_CRM_MATERIAL"."INVALID_TIME" IS '生效时间'  调用方法： OracleStatementParser parser = new OracleStatementParser(sql); SQLStatement statement = parser.parseStatement();// 分号之后多语句忽略 OracleWallProvider provider = new OracleWallProvider(); provider.getConfig().setCommentAllow(true); WallCheckResult result1 = provider.check(sql);  执行报：class com.alibaba.druid.sql.ast.statement.SQLCommentStatement not allow</body>
		<created>2017-05-25 09:42:29</created>
		<closed>2017-07-13 05:17:54</closed>
	</bug>
	<bug>
		<id>1758</id>
		<title>datasource close之后，createScheduler线程池还在后台创建连接</title>
		<body>druid初始化时传入了一个全局的createScheduler；但是在close时没有处理线程池里schedule出去的task，在datasource close之后，CreateConnectionTask依然会被调度执行，而CreateConnectionTask的run方法里如果创建连接失败会继续schedule任务去创建。                  try {                     physicalConnection = createPhysicalConnection();                 } catch (SQLException e) {                     LOG.error("create connection error, url: " + jdbcUrl, e);                      errorCount++;                                          if (failFast) {                         lock.lock();                         try {                             notEmpty.signalAll();                         } finally {                             lock.unlock();                         }                     }                      if (errorCount &gt; connectionErrorRetryAttempts &amp;&amp; timeBetweenConnectErrorMillis &gt; 0) {                         if (breakAfterAcquireFailure) {                             lock.lock();                             try {                                 createTaskCount--;                             } finally {                                 lock.unlock();                             }                             return;                         }                          this.errorCount = 0; // reset errorCount                         createScheduler.schedule(this, timeBetweenConnectErrorMillis, TimeUnit.MILLISECONDS);                         return;                     }                 }</body>
		<created>2017-05-24 09:36:44</created>
		<closed>2017-06-25 13:28:04</closed>
	</bug>
	<bug>
		<id>1737</id>
		<title>SQLASTOutputVisitor类中参数parameterizedMergeInList=false时，解析出来的问号个数和参数值个数不对应</title>
		<body>visit(SQLInListExpr x)方法目前有一代码段如下： ```  if (parameterizedMergeInList) {                         List&lt;Object&gt; subList = new ArrayList&lt;Object&gt;(x.getTargetList().size());                         for (SQLExpr target : x.getTargetList()) {                             ExportParameterVisitorUtils.exportParameter(subList, target);                         }                         if (subList != null) {                             parameters.add(subList);                         }                     } else {                         for (SQLExpr target : x.getTargetList()) {                             ExportParameterVisitorUtils.exportParameter(this.parameters, target);                         }                     }  ```  当前parameterizedMergeInList默认为false,会导致解析出来的,sql中的问号个数和参数值个数不对应哦！  以下的测试代码 ```   String sql = "select * from test_tab1 where name='name' and id in  ('A','B')";        final StringBuilder out = new StringBuilder();        final ExportParameterVisitor visitor = new OracleExportParameterVisitor(out);        // visitor.setParameterizedMergeInList(true);         SQLStatementParser parser = new OracleStatementParser(sql);         final SQLStatement parseStatement = parser.parseStatement();         parseStatement.accept(visitor);         final List&lt;Object&gt; plist = visitor.getParameters();         sql = out.toString();         System.out.println("src:"+sql);         System.out.println("sql:"+sql+" params:"+plist); ```</body>
		<created>2017-05-15 04:50:34</created>
		<closed>2017-06-25 13:27:48</closed>
	</bug>
	<bug>
		<id>1727</id>
		<title>PG执行SQL语句出错</title>
		<body>sql: ``` WITH sel AS (SELECT        unnest(ARRAY [4275]) AS gdid,        unnest(ARRAY [1])    AS gdnumber) UPDATE goods_detail SET gd_number = gd_number - gdnumber FROM sel WHERE gd_id = gdid; ``` 错误信息  ```  org.springframework.jdbc.UncategorizedSQLException:  ### Error updating database.  Cause: java.sql.SQLException: sql injection violation, syntax error: TODO : WITH sel AS (SELECT                unnest(ARRAY [4275]) AS gdid,                unnest(ARRAY [1])    AS gdnumber) UPDATE goods_detail SET gd_number = gd_number - gdnumber FROM sel WHERE gd_id = gdid; ### SQL: WITH sel AS (SELECT                unnest(ARRAY [4275]) AS gdid,                unnest(ARRAY [1])    AS gdnumber) UPDATE goods_detail SET gd_number = gd_number - gdnumber FROM sel WHERE gd_id = gdid; ### Cause: java.sql.SQLException: sql injection violation, syntax error: TODO : WITH sel AS (SELECT                unnest(ARRAY [4275]) AS gdid,                unnest(ARRAY [1])    AS gdnumber) UPDATE goods_detail SET gd_number = gd_number - gdnumber FROM sel WHERE gd_id = gdid; ; uncategorized SQLException for SQL []; SQL state [null]; error code [0]; sql injection violation, syntax error: TODO : WITH sel AS (SELECT                unnest(ARRAY [4275]) AS gdid,                unnest(ARRAY [1])    AS gdnumber) UPDATE goods_detail SET gd_number = gd_number - gdnumber FROM sel WHERE gd_id = gdid;; nested exception is java.sql.SQLException: sql injection violation, syntax error: TODO : WITH sel AS (SELECT                unnest(ARRAY [4275]) AS gdid,                unnest(ARRAY [1])    AS gdnumber) UPDATE goods_detail SET gd_number = gd_number - gdnumber FROM sel WHERE gd_id = gdid; ```  在 语法解析上面有问题   </body>
		<created>2017-05-10 06:58:34</created>
		<closed>2017-05-14 03:35:04</closed>
	</bug>
	<bug>
		<id>1725</id>
		<title>delete 出现别名，SQLStatement  toString出现错误</title>
		<body>例如： delete from credit_corp_baseinfo o where o.applyid in(24032,23942,23579,23511,23408,23327,23322,23230,23228,23218);  List&lt;SQLStatement&gt; sts = SQLUtils.toStatementList(sql, "oracle"); for(SQLStatement st :sts){ System.err.println(st.toString()); }  结果别名出现2次： DELETE FROM credit_corp_baseinfo   o o    WHERE o.applyid IN (24032, 23942, 23579, 23511, 23408, 23327, 23322, 23230, 23228, 23218)</body>
		<created>2017-05-09 10:32:37</created>
		<closed>2017-05-14 03:35:29</closed>
	</bug>
	<bug>
		<id>1710</id>
		<title>希望PageUtils.hasUnorderedLimit方法能过滤掉嵌套的order by在limit之前的sql</title>
		<body>您好，之前跟您沟通过，希望PageUtils.hasUnorderedLimit能够识别并过滤掉如下种类的sql： select * from (select * from test t order by id desc) z  limit 100  如果order by出现在limit前面，则认为是正常的sql；</body>
		<created>2017-04-27 07:53:17</created>
		<closed>2017-05-14 03:34:56</closed>
	</bug>
	<bug>
		<id>1707</id>
		<title>与Shiro集成时WebStatFilter的finally中未catch异常</title>
		<body>环境: shiro-spring-1.2.3 版本, 使用Redis构建 Shiro 的Web集群。  web.xml 之中对 `WebStatFilter` 指定初始化参数: ```         &lt;init-param&gt;             &lt;param-name&gt;sessionStatEnable&lt;/param-name&gt;             &lt;param-value&gt;true&lt;/param-value&gt;         &lt;/init-param&gt;         &lt;init-param&gt;             &lt;param-name&gt;principalSessionName&lt;/param-name&gt;             &lt;param-value&gt;_loginuser_name&lt;/param-value&gt;         &lt;/init-param&gt; ```   操作描述: 用户登录之后, 执行 logout 时抛出。  影响: 对于(我们的系统来说) redirect 没有影响, 但对于 依赖返回内容的 Ajax 请求, 会报错:   异常位置: `com.alibaba.druid.support.http.WebStatFilter` 类中,  `doFilter` 方法的 finally语句块中, 152行附近, 调用了父类的 `getPrincipal` 方法:  ```             if (sessionStat != null) {                 sessionStat.afterInvoke(error, nanos);                 sessionStat.setPrincipal(getPrincipal(httpRequest));             } ```  原因分析: Shiro 的锅, logout 时删除了Redis中对应的 sessionId 键, 导致 WebStatFilter 在 filter 链之后获取 session 中的值时, session 不为 null, 但调用 `getAttribute()` 方法时,其内部代理抛出异常, 代码如下所示:  &gt; org.apache.shiro.session.mgt.eis.AbstractSessionDAO 类:  ```     public Session readSession(Serializable sessionId) throws UnknownSessionException {         Session s = doReadSession(sessionId);         if (s == null) {             throw new UnknownSessionException("There is no session with id [" + sessionId + "]");         }         return s;     } ```   异常原因堆栈信息为:  ``` Caused by: org.apache.shiro.session.UnknownSessionException: There is no session with id [78dfd3d8-2914-446c-8aba-028c8eeb1f54] at org.apache.shiro.session.mgt.eis.AbstractSessionDAO.readSession(AbstractSessionDAO.java:170) ~[shiro-core-1.2.3.jar:1.2.3] at org.apache.shiro.session.mgt.eis.CachingSessionDAO.readSession(CachingSessionDAO.java:261) ~[shiro-core-1.2.3.jar:1.2.3] at org.apache.shiro.session.mgt.DefaultSessionManager.retrieveSessionFromDataSource(DefaultSessionManager.java:236) ~[shiro-core-1.2.3.jar:1.2.3] at org.apache.shiro.session.mgt.DefaultSessionManager.retrieveSession(DefaultSessionManager.java:222) ~[shiro-core-1.2.3.jar:1.2.3] at org.apache.shiro.session.mgt.AbstractValidatingSessionManager.doGetSession(AbstractValidatingSessionManager.java:118) ~[shiro-core-1.2.3.jar:1.2.3] at org.apache.shiro.session.mgt.AbstractNativeSessionManager.lookupSession(AbstractNativeSessionManager.java:108) ~[shiro-core-1.2.3.jar:1.2.3] at org.apache.shiro.session.mgt.AbstractNativeSessionManager.lookupRequiredSession(AbstractNativeSessionManager.java:112) ~[shiro-core-1.2.3.jar:1.2.3] at org.apache.shiro.session.mgt.AbstractNativeSessionManager.getAttribute(AbstractNativeSessionManager.java:209) ~[shiro-core-1.2.3.jar:1.2.3] at org.apache.shiro.session.mgt.DelegatingSession.getAttribute(DelegatingSession.java:141) ~[shiro-core-1.2.3.jar:1.2.3] at org.apache.shiro.session.ProxiedSession.getAttribute(ProxiedSession.java:121) ~[shiro-core-1.2.3.jar:1.2.3] at org.apache.shiro.web.servlet.ShiroHttpSession.getAttribute(ShiroHttpSession.java:131) ~[shiro-web-1.2.3.jar:1.2.3] ... 38 common frames omitted ``` </body>
		<created>2017-04-26 10:36:38</created>
		<closed>2017-05-14 03:35:21</closed>
	</bug>
	<bug>
		<id>1694</id>
		<title>Slf4jLogFilter日志打印SQL错误的问题</title>
		<body>持久层用是MyBatis，由于特殊情况不能贴日志太打印信息，所以只能描述一下。 mybatis执行的sql语句是 select count(0)  from tb_user  where  (login_name like '%j%' and v_sort between 1 and 10 )  or  (display_name like '%j%' and v_sort between 1 and 10 )  但是日志打印出来是 select count(0) from tb_user  where  login_name like '%j%' and v_sort between 1 and 10   or   display_name like '%j%' and v_sort between 1 and 10  语句中的括号没有了，虽然执行的是正确的语句但是在调试上会造成误导。 请大神看看！日志实现是slf4j </body>
		<created>2017-04-18 14:10:07</created>
		<closed>2017-09-04 07:45:33</closed>
	</bug>
	<bug>
		<id>1678</id>
		<title>注入失败select top 1 (CAST(OriganID AS VARCHAR(20)) + ',' + MobilePhoneUrl)</title>
		<body>com.alibaba.druid.sql.parser.ParserException: not support token:CAST         at com.alibaba.druid.sql.parser.SQLExprParser.methodRest(SQLExprParser.java:834)         at com.alibaba.druid.sql.parser.SQLExprParser.primaryRest(SQLExprParser.java:771)         at com.alibaba.druid.sql.dialect.sqlserver.parser.SQLServerExprParser.primaryRest(SQLServerExprParser.java:74)         at com.alibaba.druid.sql.parser.SQLExprParser.primary(SQLExprParser.java:603)         at com.alibaba.druid.sql.dialect.sqlserver.parser.SQLServerExprParser.primary(SQLServerExprParser.java:62)         at com.alibaba.druid.sql.dialect.sqlserver.parser.SQLServerExprParser.parseTop(SQLServerExprParser.java:128)         at com.alibaba.druid.sql.dialect.sqlserver.parser.SQLServerSelectParser.query(SQLServerSelectParser.java:147)         at com.alibaba.druid.sql.dialect.sqlserver.parser.SQLServerSelectParser.select(SQLServerSelectParser.java:48)         at com.alibaba.druid.sql.parser.SQLStatementParser.parseSelect(SQLStatementParser.java:1831)         at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:114)         at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:79)         at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:620)         at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:574)         at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:712)</body>
		<created>2017-04-10 10:12:27</created>
		<closed>2017-10-03 10:47:10</closed>
	</bug>
	<bug>
		<id>1675</id>
		<title>Error occurs when parse sql "create table tb1(select * from tb2)"</title>
		<body>when use druid to parse the sql "create table tb1(select * from tb2)", exception will be dumped out: com.alibaba.druid.sql.parser.ParserException: error SELECT at com.alibaba.druid.sql.parser.SQLExprParser.name(SQLExprParser.java:1002) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlExprParser.parseColumn(MySqlExprParser.java:541) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlCreateTableParser.parseCrateTable(MySqlCreateTableParser.java:170) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseCreate(MySqlStatementParser.java:352) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:125) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:79) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:74) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:430)</body>
		<created>2017-04-07 03:30:30</created>
		<closed>2017-10-03 10:47:23</closed>
	</bug>
	<bug>
		<id>1667</id>
		<title>解析修改表列名SQL失败</title>
		<body>example： alter table sale_detail change column old_col_name rename to new_col_name;  val parser = OdpsStatementParser(sql) val stmt = parser.parseStatement()  异常信息： ```java com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'name rename to new_col_name;',expect COMMENT, actual IDENTIFIER rename at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:239) at com.alibaba.druid.sql.parser.SQLParser.accept(SQLParser.java:247) at com.alibaba.druid.sql.parser.SQLStatementParser.parseAlter(SQLStatementParser.java:888) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:152) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatement(SQLStatementParser.java:2065) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatement(SQLStatementParser.java:2055) ```</body>
		<created>2017-04-05 04:10:05</created>
		<closed>2017-05-14 03:34:21</closed>
	</bug>
	<bug>
		<id>1663</id>
		<title>like '%'||?||'%' 类型SQL解析错误</title>
		<body>Druid版本：1.0.28、1.0.29、1.0.27都有这个问题  Caused by: java.sql.SQLException: sql injection violation, syntax error: ERROR. token : QUESBAR, pos : 112 : select count(brand0_.bid) as col_0_0_ from qm_brand brand0_ where brand0_.cmid=? and (brand0_.bname like '%'||?||'%') at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:725)         ......  Caused by: com.alibaba.druid.sql.parser.ParserException: ERROR. token : QUESBAR, pos : 112 at com.alibaba.druid.sql.parser.SQLExprParser.primary(SQLExprParser.java:600) at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.primary(OracleExprParser.java:465) at com.alibaba.druid.sql.parser.SQLExprParser.bitXor(SQLExprParser.java:111) at com.alibaba.druid.sql.parser.SQLExprParser.multiplicative(SQLExprParser.java:163) at com.alibaba.druid.sql.parser.SQLExprParser.additiveRest(SQLExprParser.java:1356) at com.alibaba.druid.sql.parser.SQLExprParser.additive(SQLExprParser.java:1344) at com.alibaba.druid.sql.parser.SQLExprParser.shift(SQLExprParser.java:1371) at com.alibaba.druid.sql.parser.SQLExprParser.bitAnd(SQLExprParser.java:1249) at com.alibaba.druid.sql.parser.SQLExprParser.bitOr(SQLExprParser.java:1263) at com.alibaba.druid.sql.parser.SQLExprParser.relationalRest(SQLExprParser.java:1525) at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.relationalRest(OracleExprParser.java:973) at com.alibaba.druid.sql.parser.SQLExprParser.exprRest(SQLExprParser.java:102) at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.exprRest(OracleExprParser.java:1103) at com.alibaba.druid.sql.parser.SQLExprParser.expr(SQLExprParser.java:91) at com.alibaba.druid.sql.parser.SQLExprParser.primary(SQLExprParser.java:208) at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.primary(OracleExprParser.java:465) at com.alibaba.druid.sql.parser.SQLExprParser.bitXor(SQLExprParser.java:111) at com.alibaba.druid.sql.parser.SQLExprParser.multiplicative(SQLExprParser.java:163) at com.alibaba.druid.sql.parser.SQLExprParser.additive(SQLExprParser.java:1343) at com.alibaba.druid.sql.parser.SQLExprParser.shift(SQLExprParser.java:1371) at com.alibaba.druid.sql.parser.SQLExprParser.bitAnd(SQLExprParser.java:1249) at com.alibaba.druid.sql.parser.SQLExprParser.bitOr(SQLExprParser.java:1263) at com.alibaba.druid.sql.parser.SQLExprParser.equality(SQLExprParser.java:1278) at com.alibaba.druid.sql.parser.SQLExprParser.relational(SQLExprParser.java:1450) at com.alibaba.druid.sql.parser.SQLExprParser.andRest(SQLExprParser.java:1408) at com.alibaba.druid.sql.parser.SQLExprParser.exprRest(SQLExprParser.java:104) at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.exprRest(OracleExprParser.java:1103) at com.alibaba.druid.sql.parser.SQLExprParser.expr(SQLExprParser.java:91) at com.alibaba.druid.sql.parser.SQLSelectParser.expr(SQLSelectParser.java:540) at com.alibaba.druid.sql.parser.SQLSelectParser.parseWhere(SQLSelectParser.java:260) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.query(OracleSelectParser.java:274) at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.select(OracleSelectParser.java:81) at com.alibaba.druid.sql.dialect.oracle.parser.OracleStatementParser.parseStatementList(OracleStatementParser.java:131) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:79) at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:620) at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:574) at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:712) ... 104 common frames omitted</body>
		<created>2017-03-29 09:04:34</created>
		<closed>2017-05-14 03:35:39</closed>
	</bug>
	<bug>
		<id>1658</id>
		<title>1.0.29版本在开启WallFilter后，以下Oralce语句无法正常通过</title>
		<body>`SELECT ?||'ABC' FROM DUAL`这条语句在1.0.27上是能通过校验的，但是到了1.0.29上就会报以下异常： ``` com.alibaba.druid.sql.parser.ParserException: ERROR. token : QUESBAR, pos : 10 at com.alibaba.druid.sql.parser.SQLExprParser.primary(SQLExprParser.java:600) ~[druid-1.0.29.jar:1.0.29] at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.primary(OracleExprParser.java:465) ~[druid-1.0.29.jar:1.0.29] at com.alibaba.druid.sql.parser.SQLExprParser.expr(SQLExprParser.java:85) ~[druid-1.0.29.jar:1.0.29] at com.alibaba.druid.sql.parser.SQLExprParser.parseSelectItem(SQLExprParser.java:2166) ~[druid-1.0.29.jar:1.0.29] at com.alibaba.druid.sql.parser.SQLSelectParser.parseSelectList(SQLSelectParser.java:373) ~[druid-1.0.29.jar:1.0.29] at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.query(OracleSelectParser.java:267) ~[druid-1.0.29.jar:1.0.29] at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.select(OracleSelectParser.java:81) ~[druid-1.0.29.jar:1.0.29] at com.alibaba.druid.sql.dialect.oracle.parser.OracleStatementParser.parseStatementList(OracleStatementParser.java:131) ~[druid-1.0.29.jar:1.0.29] at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:79) ~[druid-1.0.29.jar:1.0.29] ``` 我试了一下，加个空格就能通过校验，改为`SELECT ? ||'ABC' FROM DUAL`，避开了QUESBAR(`?|`)。  </body>
		<created>2017-03-28 06:15:31</created>
		<closed>2017-05-14 03:34:48</closed>
	</bug>
	<bug>
		<id>1654</id>
		<title>BTREE is not supported by druid</title>
		<body>when use druid SQLUtils.parseStatements to parse the sql "ALTER TABLE db_manage.zcy_gpcatalog_node_t ADD INDEX `index_code` USING BTREE (`code`);", the exceptions will be dumped out: com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'ode` USING BTREE (`code`);',expect LPAREN, actual IDENTIFIER USING at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:239) at com.alibaba.druid.sql.parser.SQLParser.accept(SQLParser.java:247) at com.alibaba.druid.sql.parser.SQLStatementParser.parseAlterTableAddIndex(SQLStatementParser.java:2120) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlterTable(MySqlStatementParser.java:2355) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseAlter(MySqlStatementParser.java:2316) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:152) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:79) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:74) at com.alibaba.druid.sql.SQLUtils.parseStatements(SQLUtils.java:430)</body>
		<created>2017-03-23 06:47:17</created>
		<closed>2017-05-14 03:34:29</closed>
	</bug>
	<bug>
		<id>1637</id>
		<title>postgresql的nulls last 语法不支持吗?</title>
		<body>Caused by: com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'esc  NULLS LAST ) totalTable ',expect RPAREN, actual IDENTIFIER NULLS  sql没问题,但是程序跑起来会报这个错,求解救</body>
		<created>2017-03-13 09:12:41</created>
		<closed>2017-10-03 08:31:55</closed>
	</bug>
	<bug>
		<id>1612</id>
		<title>关于解析外键：ON DELETE NO ACTION ON UPDATE NO ACTION</title>
		<body>com.alibaba.druid.sql.dialect.mysql.parser.MySqlExprParser类的877行： ` } else if (identifierEquals("ON")) {             lexer.nextToken();             if (identifierEquals("ACTION")) {                 option = Option.NO_ACTION;                 lexer.nextToken();             } else {                 throw new ParserException("syntax error, expect ACTION, actual " + lexer.token() + " "                                           + lexer.stringVal());             }         } else {`  “ON”是不是应该是“NO”啊？ 我跟了下代码，如果是ON的话这个if条件永远也不会成立的。</body>
		<created>2017-02-17 08:38:56</created>
		<closed>2018-02-04 05:59:44</closed>
	</bug>
	<bug>
		<id>1611</id>
		<title>druid +SQLite + limit 前 + order by时 出错</title>
		<body>ERROR: com.alibaba.druid.filter.stat.StatFilter - merge sql error, dbType sqlite, sql : select * from  表名  ORDER BY id DESC limit 0,10 com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'DESC limit 0,10',expect LIMIT, actual LIMIT limit </body>
		<created>2017-02-17 08:06:15</created>
		<closed>2017-10-03 10:45:58</closed>
	</bug>
	<bug>
		<id>1604</id>
		<title>不支持ODPS字段改名语句解析</title>
		<body>alter table table_name change column old_col_name rename to new_col_name; ALTER TABLE table_name CHANGE COLUMN old_col_name new_col_name column_type COMMENT '';</body>
		<created>2017-02-13 11:46:26</created>
		<closed>2017-10-03 10:46:06</closed>
	</bug>
	<bug>
		<id>1592</id>
		<title>PostgreSql中JSON类型，防火墙BUG？</title>
		<body>PostgreSql中使用JSON类型，查询的时候需要对?转义为??，但是会被druid的防火墙拦截掉，求解决方案。 相关操作符参照： https://www.postgresql.org/docs/9.6/static/functions-json.html https://jdbc.postgresql.org/documentation/head/statement.html  例如SQL：SELECT count(1) FROM t_user WHERE property ?? 'name'  相关日志： org.springframework.jdbc.UncategorizedSQLException: PreparedStatementCallback; uncategorized SQLException for SQL [SELECT count(1) FROM t_user WHERE property ?? ?]; SQL state [null]; error code [0]; sql injection violation, syntax error: syntax error, error in :'HERE property ?? ?',expect QUES, actual QUES property : SELECT count(1) FROM t_user WHERE property ?? ?; nested exception is java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'HERE property ?? ?',expect QUES, actual QUES property : SELECT count(1) FROM t_user WHERE property ?? ?   Caused by: java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'HERE property ?? ?',expect QUES, actual QUES property : SELECT count(1) FROM t_user WHERE property ?? ?         at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:724) ~[druid-1.0.24.jar:1.0.24]         at com.alibaba.druid.wall.WallFilter.connection_prepareStatement(WallFilter.java:252) ~[druid-1.0.24.jar:1.0.24]         at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:448) ~[druid-1.0.24.jar:1.0.24]         at com.alibaba.druid.filter.FilterAdapter.connection_prepareStatement(FilterAdapter.java:928) ~[druid-1.0.24.jar:1.0.24]         at com.alibaba.druid.filter.FilterEventAdapter.connection_prepareStatement(FilterEventAdapter.java:122) ~[druid-1.0.24.jar:1.0.24]         at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:448) ~[druid-1.0.24.jar:1.0.24]</body>
		<created>2017-01-24 06:03:53</created>
		<closed>2017-02-05 15:35:09</closed>
	</bug>
	<bug>
		<id>1588</id>
		<title>Eval mod function overflow long type</title>
		<body>SQLEvalVisitorUtils' mod 函数实现中， castToInteger 导致long型overflow，导致计算的结果错误。</body>
		<created>2017-01-20 02:11:35</created>
		<closed>2017-02-05 15:32:44</closed>
	</bug>
	<bug>
		<id>1583</id>
		<title>odps parser 解析alert merge失败</title>
		<body>odps parser 解析alert merge失败: syntax error, error in :'_sdt MERGE SMALLFILES;',expect IDENTIFIER, actual IDENTIFIER MERGE  example: ALTER TABLE secmt_dev.tdl_spark_event_tb_order_create MERGE SMALLFILES;</body>
		<created>2017-01-17 03:49:37</created>
		<closed>2017-01-18 13:39:28</closed>
	</bug>
	<bug>
		<id>1576</id>
		<title>SQLStatementParser 设计或实现上严重问题，会忽略语法错误，且截断sql,导致update和delete无where条件下执行！！！</title>
		<body>以下sql执行时忽略where, "update“替换成"delete"也是相同的问题 且已验证oracle,mysql及db2都存在此问题！！！ ``` String  sql1="update test_tab1 SET name=''abc''  where id='id1'";  final StringBuilder out = new StringBuilder();  SQLStatementParser parser =   new OracleStatementParser(sql1); ExportParameterVisitor visitor = new OracleExportParameterVisitor(out);  //SQLStatementParser parser =   new MySqlStatementParser(sql1); //ExportParameterVisitor visitor = new MySqlExportParameterVisitor(out);  //SQLStatementParser parser =   new DB2StatementParser(sql1); //ExportParameterVisitor visitor = new DB2ExportParameterVisitor(out);  final SQLStatement parseStatement = parser.parseStatement();         parseStatement.accept(visitor);         final List&lt;Object&gt; plist = visitor.getParameters();         Object parameters = plist.toArray();         String sql2 = out.toString();                 if(LOG.isDebugEnabled()){           LOG.debug("sql:{} params:{} {}",sql2,parameters,  parser.isParseCompleteValues());         } ```</body>
		<created>2017-01-09 13:17:23</created>
		<closed>2017-02-05 15:26:04</closed>
	</bug>
	<bug>
		<id>1570</id>
		<title>oracle数据库表和列的注释语句无法执行，被 java.sql.SQLException: sql injection violation</title>
		<body>druid-1.0.26 oracle 10  `throws exception: java.sql.SQLException: sql injection violation, class com.alibaba.druid.sql.ast.statement.SQLCommentStatement not allow : comment on table jswoa1.con_attach is '附件表' java.sql.SQLException: sql injection violation, class com.alibaba.druid.sql.ast.statement.SQLCommentStatement not allow : comment on table jswoa1.con_attach is '附件表' at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:726) at com.alibaba.druid.wall.WallFilter.statement_executeUpdate(WallFilter.java:525) at com.alibaba.druid.filter.FilterChainImpl.statement_executeUpdate(FilterChainImpl.java:2375) at com.alibaba.druid.filter.FilterAdapter.statement_executeUpdate(FilterAdapter.java:2486) at com.alibaba.druid.filter.FilterEventAdapter.statement_executeUpdate(FilterEventAdapter.java:327) at com.alibaba.druid.filter.FilterChainImpl.statement_executeUpdate(FilterChainImpl.java:2375) at com.alibaba.druid.proxy.jdbc.StatementProxyImpl.executeUpdate(StatementProxyImpl.java:225) at com.alibaba.druid.pool.DruidPooledStatement.executeUpdate(DruidPooledStatement.java:164) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at org.jdbcdslog.StatementLoggingHandler.invoke(StatementLoggingHandler.java:27) at com.sun.proxy.$Proxy84.executeUpdate(Unknown Source) at org.hibernate.tool.hbm2ddl.SchemaUpdate.execute(SchemaUpdate.java:252) at org.hibernate.tool.hbm2ddl.SchemaUpdate.execute(SchemaUpdate.java:203) at org.hibernate.internal.SessionFactoryImpl.&lt;init&gt;(SessionFactoryImpl.java:522) at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:1859) at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:1930)`</body>
		<created>2017-01-04 09:42:09</created>
		<closed>2017-02-05 15:30:05</closed>
	</bug>
	<bug>
		<id>1567</id>
		<title>Sql Parser不支持MySql的DATE_ADD函数</title>
		<body>druid:1.0.27 SQL:select DATE_ADD(now(),INTERVAL -1 day); Exception:com.alibaba.druid.sql.parser.ParserException: TODO Please confirm this problem,thx! </body>
		<created>2016-12-30 06:17:09</created>
		<closed>2017-05-14 03:34:38</closed>
	</bug>
	<bug>
		<id>1561</id>
		<title>当合并SQL开启时, 整合flyway报错</title>
		<body>先说下环境: spring, springmvc:4.3.4.RELEASE flyway:4.0.3 druid:1.0.25 数据库: postgresql 9.5版本  spring配置的druid  statFilter如下 &lt;bean id="statFilter" class="com.alibaba.druid.filter.stat.StatFilter" lazy-init="true"&gt; &lt;property name="slowSqlMillis" value="3000" /&gt; &lt;property name="logSlowSql" value="true" /&gt; &lt;property name="mergeSql" value="true" /&gt; &lt;/bean&gt; flyway配置如下 &lt;bean id="flyway" class="org.flywaydb.core.Flyway" init-method="migrate"&gt; &lt;property name="dataSource" ref="writeDataSource" /&gt; &lt;property name="encoding" value="utf-8" /&gt; &lt;property name="locations" value="flyway" /&gt; &lt;property name="sqlMigrationSeparator" value="_" /&gt; &lt;/bean&gt;  合并验证SQL时 主要报错如下  2016-12-26 19:23:29.017 [localhost-startStop-1] INFO [Slf4jLog:44] - Flyway 4.0.3 by Boxfuse 2016-12-26 19:23:29.033 [localhost-startStop-1] INFO [Slf4jLog:44] - Database: jdbc:postgresql://192.168.1.233/latto (PostgreSQL 9.5) 2016-12-26 19:23:29.115 [localhost-startStop-1] DEBUG [Slf4jLog:40] - DDL Transactions Supported: true 2016-12-26 19:23:29.118 [localhost-startStop-1] DEBUG [Slf4jLog:40] - Schema: public 2016-12-26 19:23:29.128 [localhost-startStop-1] DEBUG [Slf4jLog:40] - Spring Jdbc available: true 2016-12-26 19:23:29.130 [localhost-startStop-1] DEBUG [Slf4jLog:40] - Scanning for SQL callbacks ... 2016-12-26 19:23:29.130 [localhost-startStop-1] DEBUG [Slf4jLog:40] - Scanning for classpath resources at 'classpath:flyway' (Prefix: '', Suffix: '.sql') 2016-12-26 19:23:29.130 [localhost-startStop-1] DEBUG [Slf4jLog:40] - Determining location urls for classpath:flyway using ClassLoader WebappClassLoader   context: latto-service   delegate: false ----------&gt; Parent Classloader: java.net.URLClassLoader@1ef7fe8e  ... 2016-12-26 19:23:29.131 [localhost-startStop-1] WARN [Slf4jLog:48] - Unable to resolve location classpath:flyway 2016-12-26 19:23:29.153 [localhost-startStop-1] ERROR [Log4j2Impl:53] - merge sql error, dbType postgresql, sql :  SET search_path = "public","$user", public com.alibaba.druid.sql.parser.ParserException: syntax error, expect EQ, actual COMMA $user at com.alibaba.druid.sql.parser.SQLExprParser.accept(SQLExprParser.java:1657) at com.alibaba.druid.sql.parser.SQLExprParser.parseAssignItem(SQLExprParser.java:1839) at com.alibaba.druid.sql.parser.SQLStatementParser.parseAssignItems(SQLStatementParser.java:1635) at com.alibaba.druid.sql.parser.SQLStatementParser.parseSet(SQLStatementParser.java:1628) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:215) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:147) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:142) at com.alibaba.druid.sql.visitor.ParameterizedOutputVisitorUtils.parameterize(ParameterizedOutputVisitorUtils.java:53) at com.alibaba.druid.filter.stat.StatFilter.mergeSql(StatFilter.java:145) at com.alibaba.druid.filter.stat.StatFilter.createSqlStat(StatFilter.java:630) at com.alibaba.druid.filter.stat.StatFilter.statementPrepareAfter(StatFilter.java:305) at com.alibaba.druid.filter.FilterEventAdapter.connection_prepareStatement(FilterEventAdapter.java:124) at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:448) at com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl.prepareStatement(ConnectionProxyImpl.java:342) at com.alibaba.druid.pool.DruidPooledConnection.prepareStatement(DruidPooledConnection.java:331) at sun.reflect.GeneratedMethodAccessor39.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at net.bull.javamelody.JdbcWrapper$ConnectionInvocationHandler.invoke(JdbcWrapper.java:189) at net.bull.javamelody.JdbcWrapper$DelegatingInvocationHandler.invoke(JdbcWrapper.java:286) at com.sun.proxy.$Proxy108.prepareStatement(Unknown Source) at org.flywaydb.core.internal.dbsupport.JdbcTemplate.prepareStatement(JdbcTemplate.java:290) at org.flywaydb.core.internal.dbsupport.JdbcTemplate.execute(JdbcTemplate.java:218) at org.flywaydb.core.internal.dbsupport.postgresql.PostgreSQLDbSupport.doChangeCurrentSchemaTo(PostgreSQLDbSupport.java:107) at org.flywaydb.core.internal.dbsupport.postgresql.PostgreSQLDbSupport.changeCurrentSchemaTo(PostgreSQLDbSupport.java:92) at org.flywaydb.core.internal.command.DbValidate$1.doInTransaction(DbValidate.java:139) at org.flywaydb.core.internal.util.jdbc.TransactionTemplate.execute(TransactionTemplate.java:72) at org.flywaydb.core.internal.command.DbValidate.validate(DbValidate.java:136) at org.flywaydb.core.Flyway.doValidate(Flyway.java:1002) at org.flywaydb.core.Flyway.access$100(Flyway.java:72) at org.flywaydb.core.Flyway$1.execute(Flyway.java:921) at org.flywaydb.core.Flyway$1.execute(Flyway.java:917) at org.flywaydb.core.Flyway.execute(Flyway.java:1373) at org.flywaydb.core.Flyway.migrate(Flyway.java:917)  关闭合并SQL之后, 这个错误消失 应该是flyway设置用户到public这个schema. 但是druid不支持合并这个语句导致的.</body>
		<created>2016-12-26 11:33:41</created>
		<closed>2017-02-05 15:21:09</closed>
	</bug>
	<bug>
		<id>1556</id>
		<title>Druid+SQLite+LIMIT错误</title>
		<body>使用Druid连接SQLite时,如果使用LIMIT关键字,会出现com.alibaba.druid.sql.parser.ParserException expect IDENTIFIER, actual IDENT...的错误. Druid版本为1.0.27</body>
		<created>2016-12-23 08:57:53</created>
		<closed>2017-02-05 15:32:21</closed>
	</bug>
	<bug>
		<id>1540</id>
		<title>Wrong Word报错信息的maxActieve单词拼写小错误</title>
		<body>异常打印： Caused by: java.lang.IllegalArgumentException: illegal initialSize 50, **maxActieve** 8 at com.alibaba.druid.pool.DruidDataSource.init(DruidDataSource.java:617)</body>
		<created>2016-12-09 16:44:04</created>
		<closed>2017-02-05 15:19:45</closed>
	</bug>
	<bug>
		<id>1526</id>
		<title>druid 对Mysql DIV函数的不支持</title>
		<body>&lt;druid.version&gt;1.0.27&lt;/druid.version&gt; 原sql如下： select COUNT(*) AS count,  DATE_FORMAT(DATE(reg_time), '%Y-%m-%d') AS date,  (HOUR(reg_time) DIV 2) as intervalTime  FROM USER_RECOMMEND_INFO WHERE 1=1  and reg_time &gt;='2016-12-01 00:00:00'  and reg_time &lt;='2016-12-01 23:59:59' group by DATE(reg_time),HOUR(reg_time) DIV 2 异常如下： Caused by: java.sql.SQLException: sql injection violation, syntax error: syntax error, expect RPAREN, actual IDENTIFIER DIV : select COUNT(*) AS count, DATE_FORMAT(DATE(reg_time), '%Y-%m-%d') AS date , (HOUR(reg_time) DIV ?) as intervalTime FROM USER_RECOMMEND_INFO WHERE 1=1 and reg_time &gt;=? and reg_time &lt;=? group by DATE(reg_time),HOUR(reg_time) DIV ? at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:725) at com.alibaba.druid.wall.WallFilter.connection_prepareStatement(WallFilter.java:253) at com.alibaba.druid.filter.FilterChainImpl.connection_prepareStatement(FilterChainImpl.java:448) at com.alibaba.druid.proxy.jdbc.ConnectionProxyImpl.prepareStatement(ConnectionProxyImpl.java:342) at com.alibaba.druid.pool.DruidPooledConnection.prepareStatement(DruidPooledConnection.java:331) at org.springframework.jdbc.core.JdbcTemplate$SimplePreparedStatementCreator.createPreparedStatement(JdbcTemplate.java:1517) at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:623) ... 106 common frames omitted Caused by: com.alibaba.druid.sql.parser.ParserException: syntax error, expect RPAREN, actual IDENTIFIER DIV at com.alibaba.druid.sql.parser.SQLExprParser.accept(SQLExprParser.java:1817) at com.alibaba.druid.sql.parser.SQLExprParser.primary(SQLExprParser.java:213) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlExprParser.primary(MySqlExprParser.java:166) at com.alibaba.druid.sql.parser.SQLExprParser.expr(SQLExprParser.java:94) at com.alibaba.druid.sql.parser.SQLExprParser.parseSelectItem(SQLExprParser.java:2128) at com.alibaba.druid.sql.parser.SQLSelectParser.parseSelectList(SQLSelectParser.java:374) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlSelectParser.query(MySqlSelectParser.java:152) at com.alibaba.druid.sql.parser.SQLSelectParser.select(SQLSelectParser.java:62) at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseSelect(MySqlStatementParser.java:247) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:114) at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:79) at com.alibaba.druid.wall.WallProvider.checkInternal(WallProvider.java:620) at com.alibaba.druid.wall.WallProvider.check(WallProvider.java:574) at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:712) ... 112 common frames omitted</body>
		<created>2016-12-02 08:48:05</created>
		<closed>2017-02-05 15:21:31</closed>
	</bug>
	<bug>
		<id>1507</id>
		<title>[ODPS]SQLSelect类equals方法语义不正确</title>
		<body>equals会认为两个不同的SQLSelect相等  List&lt;SQLStatement&gt; stmtsA = SQLUtils.parseStatements("select * from a", JdbcConstants.ODPS); List&lt;SQLStatement&gt; stmtsB = SQLUtils.parseStatements("select * from b", JdbcConstants.ODPS); SQLSelect selectA = ((SQLSelectStatement) stmtsA.get(0)).getSelect(); SQLSelect selectB = ((SQLSelectStatement) stmtsB.get(0)).getSelect(); boolean eq = selectA.equals(selectB); assertTrue(eq);</body>
		<created>2016-11-23 07:51:15</created>
		<closed>2016-11-26 08:14:50</closed>
	</bug>
	<bug>
		<id>1502</id>
		<title>db2 使用 druid不支持current date、current timestamp </title>
		<body>db2 使用 druid不支持current date、current timestamp ，例如：select current date,current timestamp from dual</body>
		<created>2016-11-23 02:39:37</created>
		<closed>2016-11-26 08:15:01</closed>
	</bug>
	<bug>
		<id>1498</id>
		<title>调用Informix数据库存储过程, 当存储过程抛出异常后, 再次调用此存储过程一直报错</title>
		<body>最近项目中后台使用Informix数据库, 某次测试发现, 当存储过程抛出异常后, 再次调用此存储过程一直报错.  此存储过程参数中有一个String类型参数, 在过程内, 会将此参数转为Int类型.  在反向测试的时候, 故意输入了一些字母, 强制转换int后, 存储过程会抛出异常.   ``` java.sql.SQLException: A character to numeric conversion process failed ```  此时在正向测试, 输入参数正确的情况下, 继续抛出异常: ``` java.sql.SQLException: Invalid cursor received by sqlexec. ``` 此时不论怎么调用此存储过程都会报错. 但调用其他存储过程不会报错.   开始以为是自己代码错误, 排查后不是, 直接使用JDBC连接调用, 一切正常, 使用DBCP数据源测试, 也正常. 不知道到问题出在duird的哪里.  debug: 报错点一直在: DruidPooledPreparedStatement类的227行: ResultSet rs = stmt.executeQuery();  框架使用的是Spirng4.3.2版本  dao层调用大致代码如下: ```java     // 开始是用JDBCTemplate对象, 排查错误的时候, 直接使用dataSource了     @Autowired     @Qualifier("dataSource")     private DataSource dataSource;       /**      * 调用存储过程 获取存储过程返回值,      *      * @param name   存储过程名称      * @param params 存储过程参数      * @param &lt;T&gt;    参数类型泛型      *      * @return 存储过程返回值: 返回值为Map集合, key为行号, 从数字1开始, value是列的Map集合, 其中key为列号, 从数字1开始. value为列对应的值,      * 这里统一封装为String类型.      */     @Override     public &lt;T&gt; Optional&lt;Map&lt;Integer, Map&lt;Integer, String&gt;&gt;&gt; procedure(String name, Collection&lt;T&gt; params) {          if (name == null) return Optional.empty();         if (params == null) return Optional.empty();         final String sql = getSql(name, params.size());         logger.debug(() -&gt; "informix procedure sql : " + sql);          try (Connection conn = this.dataSource.getConnection();              CallableStatement cs = conn.prepareCall(sql)         ) {             Object[] paramsArray = params.toArray();             IntStream.range(0, params.size()).forEach(index -&gt; {                 logger.debug(() -&gt; "Informix procedure sql param: " + (index + 1) + " = " + paramsArray[index]);                 try {                     cs.setObject(index + 1, paramsArray[index]);                 } catch (SQLException e) {                     logger.error(LogUtil.expInfoToString(e));                     throw new RuntimeException(e);                 }             });             // debug时发现此处在调用: DruidPooledPreparedStatement类217行executeQuery方法, 然后一直在此方法的 ResultSet rs = stmt.executeQuery(); 会一直报错.             try (ResultSet rs = cs.executeQuery()) {                 ImmutableMap.Builder&lt;Integer, Map&lt;Integer, String&gt;&gt; builder = ImmutableMap.builder();                 while (rs.next()) {                     ImmutableMap.Builder&lt;Integer, String&gt; columns = ImmutableMap.builder();                     IntStream.range(1, rs.getMetaData().getColumnCount() + 1).forEach(index -&gt; {                         try {                             columns.put(index, Strings.nullToEmpty(rs.getString(index)));                         } catch (SQLException e) {                             logger.error(LogUtil.expInfoToString(e));                             throw new RuntimeException(e);                         }                     });                      builder.put(rs.getRow(), columns.build());                 }                 return Optional.of(builder.build());             } catch (SQLException sqlExp) {                 logger.error(LogUtil.expInfoToString(sqlExp));                 throw new RuntimeException(sqlExp);             }         } catch (SQLException e) {             logger.error(LogUtil.expInfoToString(e));             throw new RuntimeException(e);         }     } ```  </body>
		<created>2016-11-21 02:14:07</created>
		<closed>2016-11-26 08:15:14</closed>
	</bug>
	<bug>
		<id>1496</id>
		<title>[ODPS]不支持PURGE</title>
		<body>DROP TABLE a PURGE ;</body>
		<created>2016-11-18 09:11:29</created>
		<closed>2016-11-26 08:16:06</closed>
	</bug>
	<bug>
		<id>1495</id>
		<title>[ODPS]insert select语句不支持limit</title>
		<body>insert into table a select * from b limit 1</body>
		<created>2016-11-18 09:00:49</created>
		<closed>2016-11-26 08:16:14</closed>
	</bug>
	<bug>
		<id>1493</id>
		<title>[ODPS]解析insert partition后有Hint出错</title>
		<body>insert overwrite table ff partition (c='c',d='d') select /\*+mapjoin(tt)\*/ id,name from tt;</body>
		<created>2016-11-18 08:27:01</created>
		<closed>2016-11-26 08:15:58</closed>
	</bug>
	<bug>
		<id>1492</id>
		<title>[ODPS]解析多列DISTRIBUTE BY错误</title>
		<body>select * from a DISTRIBUTE BY b,c</body>
		<created>2016-11-18 08:08:17</created>
		<closed>2016-11-26 08:15:51</closed>
	</bug>
	<bug>
		<id>1489</id>
		<title>如何让wall过滤器支持BEGIN/END语法</title>
		<body>oracle数据库 我之前 一次插入多条用的是 `begin insert ******; insert ******; end;`   但是 升级到 druid 1.0.26 后 wall 过滤器 不允许 这样 提示 SQLBlockStatement 不允许执行  这个判断是在哪里进行的！？如何设置wall让其放行BEGIN/END;呢！？ </body>
		<created>2016-11-18 03:17:05</created>
		<closed>2016-11-26 08:15:44</closed>
	</bug>
	<bug>
		<id>1488</id>
		<title>分表表名拼接不对</title>
		<body>例子：原始sql是select * from user_0000 where id = 1,解析出来的模板是SELECT * FROM USER WHERE ID = ?,参数是[1],拼接参数结果是SELECT * FROM USER WHERE ID=1,不是原始sql</body>
		<created>2016-11-17 08:55:59</created>
		<closed>2016-11-19 15:35:52</closed>
	</bug>
	<bug>
		<id>1486</id>
		<title>调用存储过程后LogFilter出现空指针异常，问题原因分析并且找到</title>
		<body>存储过程如下： ``` {#{FLAG,mode=OUT,jdbcType=DECIMAL} = call pkg_ly.f_ly                     (#{P_LYDD,mode=IN,jdbcType=CLOB},                     #{P_KHDH,mode=OUT,jdbcType=VARCHAR},                     #{P_ERROR,mode=OUT,jdbcType=VARCHAR})} ``` 出现问题的代码如下： LogFilter类的下面这段代码有问题，请看加粗标记的地方   ``` private void logExecutableSql(StatementProxy statement, String sql) {         if(this.isStatementExecutableSqlLogEnable()) {             int parametersSize = statement.getParametersSize();             if(parametersSize == 0) {                 this.statementLog("{conn-" + statement.getConnectionProxy().getId() + ", " + this.stmtId(statement) + "} executed. \n" + sql);             } else {                 ArrayList parameters = new ArrayList(parametersSize);                 for(int dbType = 0; dbType &lt; parametersSize; ++dbType) {                     JdbcParameter formattedSql = statement.getParameter(dbType);                     **//下面这行报错，formattedSql空指针异常**                     parameters.add(formattedSql.getValue());                 }                 String var7 = statement.getConnectionProxy().getDirectDataSource().getDbType();                 String var8 = SQLUtils.format(sql, var7, parameters);                 this.statementLog("{conn-" + statement.getConnectionProxy().getId() + ", " + this.stmtId(statement) + "} executed. \n" + var8);             }         }     }  ``` 分析： 实际上入参只有1个，但是parametersSize等于2,原因如下： PreparedStatementProxyImpl这个类的setParameter这个方法 ```  void setParameter(int jdbcIndex, JdbcParameter parameter) {         int index = jdbcIndex - 1;         if(jdbcIndex &gt; this.parametersSize) {             this.parametersSize = jdbcIndex;         }          if(this.parametersSize &gt;= this.parameters.length) {             this.parameters = (JdbcParameter[])Arrays.copyOf(this.parameters, this.parametersSize + 16);         }          this.parameters[index] = parameter;         if(this.paramMap != null) {             this.paramMap = null;         }      } ``` 由于入参是在第二个位置，所以jdbcIndex的值为2，最后parameterSize的值就为2，正常情况如果不是存储过程那么jdbcIndex是没有问题的。目前我在重写了logfilter类，解决，但是真正要解决的是在调用这个类的时候PreparedStatementProxyImpl要考虑存储过程的情况</body>
		<created>2016-11-17 03:54:06</created>
		<closed>2016-11-26 08:15:36</closed>
	</bug>
	<bug>
		<id>1484</id>
		<title>对于含有in的sql文本，解析的参数和模板有问题，匹配不上</title>
		<body></body>
		<created>2016-11-16 06:18:52</created>
		<closed>2016-11-26 08:15:23</closed>
	</bug>
	<bug>
		<id>1481</id>
		<title>druid oracle xmltype extract 语法支持存在问题 No enum const class com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleDateTimeUnit."SYS_XML"</title>
		<body> ` select extract("sys_xml",'//base').getClobVal() as "sys_xml" from test_tab `  ``` java.lang.IllegalArgumentException: No enum const class com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleDateTimeUnit."SYS_XML" at java.lang.Enum.valueOf(Enum.java:207) at com.alibaba.druid.sql.dialect.oracle.ast.expr.OracleDateTimeUnit.valueOf(OracleDateTimeUnit.java:18) at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.primary(OracleExprParser.java:335) at com.alibaba.druid.sql.parser.SQLExprParser.expr(SQLExprParser.java:94) at com.alibaba.druid.sql.parser.SQLExprParser.parseSelectItem(SQLExprParser.java:2041) ```</body>
		<created>2016-11-15 04:57:33</created>
		<closed>2016-11-26 07:34:26</closed>
	</bug>
	<bug>
		<id>1476</id>
		<title>【why】version:1.0.26 db:oracle 未自动识别生效的ExceptionSorter</title>
		<body>使用druid1.0.26在数据库oracle单机或rac下，通过webStat看* 连接有效性检查类名 与 * ExceptionSorter类名 为 null。当在应用服务空闲一段时间后使用了不可用连接，请问文少。如何配置生效，我看介绍说是不需要配置的！ ![image](https://cloud.githubusercontent.com/assets/10141773/20085841/c36ea59e-a5a6-11e6-8cfa-d51ab4b0a6ce.png) </body>
		<created>2016-11-08 03:33:15</created>
		<closed>2016-11-26 07:38:37</closed>
	</bug>
	<bug>
		<id>1455</id>
		<title>odps sql parser 解析alter失败</title>
		<body>odps sql parser 解析下面两种类型的alter失败： alter table adl_smeta_column_indi_rule_relation_sdt add columns (rule_level string); ALTER TABLE adl_smeta_indi_rule_relation_sdt CHANGE COLUMN indi_level COMMENT 'xxxx'; </body>
		<created>2016-10-22 08:26:33</created>
		<closed>2016-10-23 17:24:28</closed>
	</bug>
	<bug>
		<id>1430</id>
		<title>postgresql配置druid.stat.mergeSql=true执行update(update语句中存在from)报错</title>
		<body>UPDATE sys_account AS a SET online = 2 FROM auto_handler_online o WHERE a.id = o.account_id AND a.online != 2 com.alibaba.druid.sql.parser.ParserException: syntax error, error in :' = 2 FROM auto_handler_online o WHE',expect FROM, actual FROM FROM 还有也不支持字符串函数 substring('Thomas' from 2 for 3)     </body>
		<created>2016-09-23 07:38:10</created>
		<closed>2016-09-24 16:17:07</closed>
	</bug>
	<bug>
		<id>1420</id>
		<title>mysql create table语句解析错误</title>
		<body>测试过程中发现解析mysql create table命令有个异常，语句如下： create table `test`.`simple_test` (   `col_key` bigint(20) not null auto_increment,   `col1` varchar(45) null,   `col2` tinyint(4) null,   `col3` datetime null,   `col4` timestamp null default current_timestamp on update current_timestamp,   primary key (`col_key`),   unique index `v1_unique` (`col_key` asc)) ,  错误如下： err:com.alibaba.druid.sql.parser.ParserException: syntax error, expect RPAREN, actual ASC asc  好像是不能正确处理“unique index `v1_unique` (`col_key` asc)” 这一段，不知道是否确实是一个bug。  druid版本： 1.0.14， </body>
		<created>2016-09-18 07:39:06</created>
		<closed>2016-09-18 13:40:00</closed>
	</bug>
	<bug>
		<id>1400</id>
		<title>SQLStatementParser不支持oracle的关联删除语法</title>
		<body>DELETE FROM (SELECT \* FROM ABC WHERE ID=6000)  异常如下 com.alibaba.druid.sql.parser.ParserException: error LPAREN     at com.alibaba.druid.sql.parser.SQLExprParser.name(SQLExprParser.java:991)     at com.alibaba.druid.sql.dialect.oracle.parser.OracleExprParser.name(OracleExprParser.java:1004)     at com.alibaba.druid.sql.dialect.oracle.parser.OracleStatementParser.parseDeleteStatement(OracleStatementParser.java:1287)     at com.alibaba.druid.sql.dialect.oracle.parser.OracleStatementParser.parseStatementList(OracleStatementParser.java:176)     at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:147)     at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:142) </body>
		<created>2016-08-31 09:04:23</created>
		<closed>2016-09-11 15:25:20</closed>
	</bug>
	<bug>
		<id>1391</id>
		<title>Sql parser for PostgreSQL 一些问题</title>
		<body>version 1.0.26-SNAPSHOT  目前的sql parser在处理一些pg特有语法时抛出异常 `com.alibaba.druid.sql.parser.ParserException: syntax error...`。  ``` java public class PGSelectTest30 extends PGTest {      String[] pgSQLs = new String[]{             /**              * Chapter 12. Full Text Search              * tsvector @@ tsquery              * tsquery @@ tsvector              * text @@ tsquery              * text @@ text             */             "SELECT 'a fat cat sat on a mat'::tsvector @@ 'cat &amp; rat'::tsquery",             /**              * 9.7. Pattern Matching: ilike             */             "select * from dual where name ilike '%mi%'",             /**              * 9.7.2. SIMILAR TO Regular Expressions             */             "select 'abc' SIMILAR TO '%(b|d)%'",             /**              * 9.7.3. POSIX Regular Expressions             */             "select 'thomas' ~ '.*thomas.*'",             "select 'thomas' ~* '.*Thomas.*'",             "select 'thomas' !~ '.*Thomas.*'",             "select 'thomas' !~* '.*vadim.*'",             /**              * 9.9. Date/Time Functions and Operators             */             "select date '2001-09-28' + integer '7'",             /**              * array operators              *             */             "select '{1,2,3}'::int[] &amp;&amp; '{1,2,3}'::int[]",             "select '{1,2,3}'::int[] @&gt; '{1,2,3}'::int[]",             "select '{1,2,3}'::int[] @&lt; '{1,2,3}'::int[]",             /**              * others              * polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'              * circle '((0,0),1)' &lt;-&gt; circle '((5,0),1)'              * ltree &lt;@ ltree              * ltree ~ lquery              * ltree ? lquery[]              * ltree[] ?@&gt; ltree              * .....             */     };      public void test_0() throws Exception {         for (String sql : pgSQLs) {             PGSQLStatementParser parser = new PGSQLStatementParser(sql);             List&lt;SQLStatement&gt; statementList = parser.parseStatementList();             SQLStatement stmt = statementList.get(0);             Assert.assertNotNull(stmt);         }     } } ``` </body>
		<created>2016-08-27 10:05:30</created>
		<closed>2016-09-19 07:58:57</closed>
	</bug>
	<bug>
		<id>1380</id>
		<title>开启防火墙的情况下 SHOW FULL TABLES WHERE Table_type != 'VIEW'  会被拒绝</title>
		<body>com.alibaba.druid.sql.ast.statement.SQLShowTablesStatement not allow   跟踪代码进入  com.alibaba.druid.wall.spi.WallVisitorUtils 类，关于下面的方法 public static void preVisitCheck(WallVisitor visitor, SQLObject x) {   ... } 没有SQLShowTablesStatement 的判断，也没有开关， 直接进入了 else 逻辑     } else {             allow = config.isNoneBaseStatementAllow();             errorCode = ErrorCode.NONE_BASE_STATEMENT_NOT_ALLOW;             denyMessage = x.getClass() + " not allow";    }  造成 com.alibaba.druid.sql.ast.statement.SQLShowTablesStatement not allow  </body>
		<created>2016-08-22 03:37:41</created>
		<closed>2016-08-22 15:51:40</closed>
	</bug>
	<bug>
		<id>1367</id>
		<title>druid解析关键字有问题</title>
		<body>SET @@session.autocommit = ON; 解析报com.alibaba.parser.ParserException: ERROR. token : ON,pos : 29 </body>
		<created>2016-08-11 11:46:33</created>
		<closed>2016-08-21 23:10:23</closed>
	</bug>
	<bug>
		<id>1364</id>
		<title>怎么对commons-lang产生了依赖？</title>
		<body>java.lang.NoClassDefFoundError: org/apache/commons/lang/math/NumberUtils     com.alibaba.druid.sql.parser.Lexer.decimalValue(Lexer.java:1288)  &lt;dependency&gt;     &lt;groupId&gt;commons-lang&lt;/groupId&gt;     &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;     &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; </body>
		<created>2016-08-10 08:35:03</created>
		<closed>2016-08-21 23:13:12</closed>
	</bug>
	<bug>
		<id>1362</id>
		<title>SQL解析失败</title>
		<body>insert into order (id, name) values (?, ?)   com.alibaba.druid.sql.parser.ParserException: error ORDER     at com.alibaba.druid.sql.parser.SQLExprParser.name(SQLExprParser.java:991)     at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseInsert(MySqlStatementParser.java:1978)     at com.alibaba.druid.sql.dialect.mysql.parser.MySqlStatementParser.parseInsert(MySqlStatementParser.java:1)     at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:198)     at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:147)     at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:142)     at com.alibaba.druid.sql.parser.SQLTableNameTest.test_merge_2(SQLTableNameTest.java:69)     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)     at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)     at java.lang.reflect.Method.invoke(Unknown Source)     at junit.framework.TestCase.runTest(TestCase.java:176)     at junit.framework.TestCase.runBare(TestCase.java:141)     at junit.framework.TestResult$1.protect(TestResult.java:122)     at junit.framework.TestResult.runProtected(TestResult.java:142)     at junit.framework.TestResult.run(TestResult.java:125)     at junit.framework.TestCase.run(TestCase.java:129)     at junit.framework.TestSuite.runTest(TestSuite.java:252)     at junit.framework.TestSuite.run(TestSuite.java:247)     at org.junit.internal.runners.JUnit38ClassRunner.run(JUnit38ClassRunner.java:86)     at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:50)     at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:675)     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)     at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192) </body>
		<created>2016-08-09 08:12:48</created>
		<closed>2016-08-10 08:26:39</closed>
	</bug>
	<bug>
		<id>1359</id>
		<title>注释解析错误</title>
		<body>Version：  1.0.20 SQL： truncate table city_list-- test  无法将-- test 正确解析为注释，一定要在“--”前增加一个空格才可以正确解析为注释。 </body>
		<created>2016-08-08 02:35:24</created>
		<closed>2016-08-10 08:26:03</closed>
	</bug>
	<bug>
		<id>1351</id>
		<title>使用mysql-connector-java 6.0.3的时候，数据源建立失败</title>
		<body>``` &lt;dependency&gt;     &lt;groupId&gt;mysql&lt;/groupId&gt;     &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;     &lt;version&gt;6.0.3&lt;/version&gt; &lt;/dependency&gt; ```  使用这个驱动的时候，数据源建立失败  如果使用  ``` &lt;dependency&gt;             &lt;groupId&gt;mysql&lt;/groupId&gt;             &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;             &lt;version&gt;5.1.39&lt;/version&gt;         &lt;/dependency&gt; ```  这个驱动就可以 </body>
		<created>2016-08-01 05:54:51</created>
		<closed>2016-08-07 09:30:56</closed>
	</bug>
	<bug>
		<id>1314</id>
		<title>貌似 不支持create database link语句?</title>
		<body>java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :'d by "xxx" using '(DESCRIPTION = (A',expect IDENTIFIER, actual LITERAL_ALIAS xxx: create database link db_link connect to "xxx" identified by "xxx" using '(DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521))) (CONNECT_DATA = (SERVICE_NAME = orcl)))'     at com.alibaba.druid.wall.WallFilter.check(WallFilter.java:724) ~[druid-1.0.20.jar:1.0.20] </body>
		<created>2016-06-29 09:50:07</created>
		<closed>2016-07-09 11:01:19</closed>
	</bug>
	<bug>
		<id>1307</id>
		<title>SchemaStatVisitor无法解析cast函数条件</title>
		<body>String dbType = JdbcConstants.MYSQL; String sql = "select t.a,t.b from t where cast(replace(t.statdate, '-','') as decimal) &gt;=20160626 "; List&lt;SQLStatement&gt; stmtList = SQLUtils.parseStatements(sql, dbType); SQLStatement stmt = stmtList.get(0); SchemaStatVisitor ssv = SQLUtils.createSchemaStatVisitor(dbType); stmt.accept(ssv); List&lt;Condition&gt; conditions = ssv.getConditions(); //这里conditions 无元素 </body>
		<created>2016-06-24 01:51:35</created>
		<closed>2016-06-25 16:13:06</closed>
	</bug>
	<bug>
		<id>1306</id>
		<title>SqlServer 2008 DDL parser errror</title>
		<body>druid 1.0.20 sqljdbc41 4.2.6420.100 SqlServer 2008 Express with default config  When I enabled the wall filter , it blocked the two ddl statemnets below.  When I disabled the wall filter and enabled the stat filter only, the two statements were executed, but it also has parser exception logs.  sql injection violation, syntax error:  syntax error, expect LPAREN, actual NOT not :   ``` sql create table leave_jpa ( id bigint identity not null,  apply_time datetime2,  start_time datetime2,  user_id varchar(255),  primary key (id) ) ```  sql injection violation, syntax error:  syntax error, error in :'uble precision,  LONG_ numeric(19,0',expect RPAREN, actual IDENTIFIER precision :   ``` sql create table ACT_RU_VARIABLE ( ID_ nvarchar(64) not null, DOUBLE_ double precision, LONG_ numeric(19,0), TEXT_ nvarchar(4000), primary key (ID_) ) ``` </body>
		<created>2016-06-23 01:29:24</created>
		<closed>2016-07-10 04:51:51</closed>
	</bug>
	<bug>
		<id>1304</id>
		<title>MySqlValidConnectionChecker validationQueryTimeout单位不一致</title>
		<body>validationQueryTimeout单位是秒。 但当MySqlValidConnectionChecker中使用MySQLConnection.pingInternal(boolean checkForClosedConnection, int timeoutMillis)进行连接验证时，单位应该是毫秒，需*1000 </body>
		<created>2016-06-22 02:50:37</created>
		<closed>2016-06-25 14:09:47</closed>
	</bug>
	<bug>
		<id>1303</id>
		<title>MySQL语法解析错误</title>
		<body>druid版本：1.0.20 mysql版本：5.5.54 示例语句：select \* from test1 where name like 'A%' limit 10  union select \* from test1 where name like 'B%' limit 20 解析为：(SELECT \* FROM test1 WHERE name LIKE 'A%' LIMIT 10) UNION (SELECT \* FROM test1 WHERE name LIKE 'B%' LIMIT 20) 示例语句数据库执行效果：(SELECT \* FROM test1 WHERE name LIKE 'A%' LIMIT 10) UNION (SELECT \* FROM test1 WHERE name LIKE 'B%') LIMIT 20 </body>
		<created>2016-06-21 07:51:19</created>
		<closed>2017-10-03 10:44:02</closed>
	</bug>
	<bug>
		<id>1294</id>
		<title>ODPS解析将close识别为关键字</title>
		<body>例如 `select name as close from abc;` 解析出错 </body>
		<created>2016-06-16 04:56:56</created>
		<closed>2016-06-25 14:10:12</closed>
	</bug>
	<bug>
		<id>1291</id>
		<title>ODPS解析不支持反斜杠转义字符</title>
		<body>例如 `select '\'' from abc;` 不能解析 </body>
		<created>2016-06-16 04:52:58</created>
		<closed>2016-06-25 15:55:13</closed>
	</bug>
	<bug>
		<id>1290</id>
		<title>ODPS解析true/false被识别成普通标识符</title>
		<body>例如 `select true from abc;` `true`被解析成了`SQLIdentifierExpr` </body>
		<created>2016-06-16 04:52:09</created>
		<closed>2016-06-25 08:27:22</closed>
	</bug>
	<bug>
		<id>1285</id>
		<title>com.alibaba.druid.sql.parser.ParserException: Error : CROSS</title>
		<body>com.alibaba.druid.sql.parser.ParserException: Error : CROSS     at com.alibaba.druid.sql.parser.SQLParser.as(SQLParser.java:171)     at com.alibaba.druid.sql.parser.SQLExprParser.parseSelectItem(SQLExprParser.java:1901)     at com.alibaba.druid.sql.parser.SQLSelectParser.parseSelectList(SQLSelectParser.java:359)     at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.query(OracleSelectParser.java:264)     at com.alibaba.druid.sql.dialect.oracle.parser.OracleSelectParser.select(OracleSelectParser.java:85)     at com.alibaba.druid.sql.dialect.oracle.parser.OracleStatementParser.parseStatementList(OracleStatementParser.java:164) 当使用下述语句 select name as cross from crossing where id=86 时，解析出错，原因：as关键字后的名字为cross，解析cross时出错 </body>
		<created>2016-06-12 11:41:29</created>
		<closed>2016-06-25 14:09:01</closed>
	</bug>
	<bug>
		<id>1270</id>
		<title>druid不能解析以full为别名的sql</title>
		<body>druid不支持select full full from t1的语句 其中full为一个列名,第二个full为别名 但是mysql db是可以接受这条sql而不报错的 </body>
		<created>2016-06-02 07:13:25</created>
		<closed>2017-05-14 03:33:54</closed>
	</bug>
	<bug>
		<id>927</id>
		<title>wall filter拦截h2的sequence语句解析出错</title>
		<body>&lt;property name="filters" value="wall,stat" /&gt;  使用默认的拦截器  h2db的jdbc版本         &lt;dependency&gt;             &lt;groupId&gt;com.h2database&lt;/groupId&gt;             &lt;artifactId&gt;h2&lt;/artifactId&gt;             &lt;version&gt;1.3.176&lt;/version&gt;             &lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt;         &lt;/dependency&gt;  ORM使用Hibernate 4.3.7  实体类主键的配置     @Id     @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "Id2SeqGenerator")     @SequenceGenerator(name = "Id2SeqGenerator",                        sequenceName = "SEQ_T_QUESTION__ID",                        initialValue = 1,                        allocationSize = 1)     @Column(name = "ID", unique = true, nullable = false, precision = 10, scale = 0)     public Long getId() {         return this.id;     }  hibernate生成的sql语句 call next value for SEQ_T_SURVEY__ID  druid的violationMessage如下： syntax error: syntax error, error in :'next value for SEQ_T_SURVEY__ID',expect IDENTIFIER, actual IDENTIFIER value </body>
		<created>2015-08-01 09:18:03</created>
		<closed>2018-07-03 08:14:05</closed>
	</bug>
	<bug>
		<id>832</id>
		<title>format error - com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'like "%"?"%" OR v.video_desc like "',expect QUES, actual QUES %</title>
		<body>这个错误发生在 通过sql监控 查看sql详细信息的时候。 后端的sql主要是mybatis的like：  ```     &lt;if test="keyword != null"&gt;         and v.video_title like "%"#{keyword}"%" OR v.video_desc like "%"#{keyword}"%"     &lt;/if&gt; ```  后端报错信息如下：  ``` com.alibaba.druid.sql.parser.ParserException: syntax error, error in :'like "%"?"%" OR v.video_desc like "',expect QUES, actual QUES %     at com.alibaba.druid.sql.parser.SQLParser.printError(SQLParser.java:210)     at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:307)     at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:112)     at com.alibaba.druid.sql.parser.SQLStatementParser.parseStatementList(SQLStatementParser.java:107)     at com.alibaba.druid.sql.SQLUtils.toStatementList(SQLUtils.java:173)     at com.alibaba.druid.sql.SQLUtils.format(SQLUtils.java:186)     at com.alibaba.druid.sql.SQLUtils.format(SQLUtils.java:181)     at com.alibaba.druid.stat.DruidStatService.getSqlStat(DruidStatService.java:310)     at com.alibaba.druid.stat.DruidStatService.service(DruidStatService.java:136)     at com.alibaba.druid.support.http.StatViewServlet.process(StatViewServlet.java:162)     at com.alibaba.druid.support.http.ResourceServlet.service(ResourceServlet.java:248) ``` </body>
		<created>2015-05-20 03:34:52</created>
		<closed>2018-03-11 14:45:20</closed>
	</bug>
</bugs>
