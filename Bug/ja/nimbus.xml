<?xml version="1.0" encoding="ISO-8859-1"?>

<bug>
	<id>602</id>
	<title>KuberneteseScheduleExecutorServiceで、outputをJSONに変換する際に、例外が発生する場合がある</title>
	<body>Caused by: java.lang.IllegalStateException: Not a string        io.kubernetes.client.custom.IntOrString.getStrValue(IntOrString.java:36)        sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)        sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)        sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)        java.lang.reflect.Method.invoke(Method.java:498)        jp.ossc.nimbus.beans.SimpleProperty$IntrospectSimpleProperty.getProperty(SimpleProperty.java:1732)        jp.ossc.nimbus.util.converter.BeanJSONConverter.appendValue(BeanJSONConverter.java:1334)        jp.ossc.nimbus.util.converter.BeanJSONConverter.appendValue(BeanJSONConverter.java:1362)        jp.ossc.nimbus.util.converter.BeanJSONConverter.appendValue(BeanJSONConverter.java:1362)        jp.ossc.nimbus.util.converter.BeanJSONConverter.appendValue(BeanJSONConverter.java:1362)        jp.ossc.nimbus.util.converter.BeanJSONConverter.appendArray(BeanJSONConverter.java:1430)        jp.ossc.nimbus.util.converter.BeanJSONConverter.appendValue(BeanJSONConverter.java:1139)        jp.ossc.nimbus.util.converter.BeanJSONConverter.appendValue(BeanJSONConverter.java:1362)        jp.ossc.nimbus.util.converter.BeanJSONConverter.appendValue(BeanJSONConverter.java:1362)        jp.ossc.nimbus.util.converter.BeanJSONConverter.appendArray(BeanJSONConverter.java:1430)        jp.ossc.nimbus.util.converter.BeanJSONConverter.appendValue(BeanJSONConverter.java:1139)        jp.ossc.nimbus.util.converter.BeanJSONConverter.appendValue(BeanJSONConverter.java:1362)        jp.ossc.nimbus.util.converter.BeanJSONConverter.toJSON(BeanJSONConverter.java:1025)        jp.ossc.nimbus.util.converter.BeanJSONConverter.convertToByteArray(BeanJSONConverter.java:994)        jp.ossc.nimbus.util.converter.BufferedStreamConverter.convertToByteArrayWithBuffer(BufferedStreamConverter.java:95)        jp.ossc.nimbus.util.converter.BufferedStreamConverter.convertToStream(BufferedStreamConverter.java:68)        jp.ossc.nimbus.util.converter.BeanJSONConverter.convert(BeanJSONConverter.java:968)        jp.ossc.nimbus.util.converter.CustomConverter.convert(CustomConverter.java:367)        jp.ossc.nimbus.service.scheduler2.AbstractScheduleExecutorService$ConvertMapping.convert(AbstractScheduleExecutorService.java:858)        jp.ossc.nimbus.service.scheduler2.AbstractScheduleExecutorService.convertOutput(AbstractScheduleExecutorService.java:681)        jp.ossc.nimbus.service.scheduler2.AbstractScheduleExecutorService.execute(AbstractScheduleExecutorService.java:364)        jp.ossc.nimbus.service.scheduler2.AbstractSchedulerService.dispatchSchedule(AbstractSchedulerService.java:512)        jp.ossc.nimbus.service.scheduler2.DefaultSchedulerService$ScheduleDispatcher.handleDequeuedObject(DefaultSchedulerService.java:211)        jp.ossc.nimbus.service.queue.QueueHandlerContainerService.handleDequeuedObject(QueueHandlerContainerService.java:574)        jp.ossc.nimbus.service.queue.QueueHandlerContainerService$QueueReceiver.consume(QueueHandlerContainerService.java:719)        jp.ossc.nimbus.daemon.Daemon.run(Daemon.java:509)        java.lang.Thread.run(Thread.java:748)</body>
	<created>2020-05-28 08:30:02</created>
	<closed>2020-05-28 09:29:34</closed>
</bug>
<bug>
	<id>599</id>
	<title>SCPClientImplでクロスプラットフォームでのSCPが出来ない</title>
	<body>Windows環境VMからLinux環境へのSCPを行うとエラーが発生する。</body>
	<created>2020-05-25 03:04:07</created>
	<closed>2020-05-25 03:17:49</closed>
</bug>
<bug>
	<id>595</id>
	<title>DistributedSharedContextで、接続が切断されて復帰すると、rehashが行われない</title>
	<body></body>
	<created>2020-05-20 10:04:00</created>
	<closed>2020-05-20 10:10:52</closed>
</bug>
<bug>
	<id>591</id>
	<title>SharedContextで、通信が途絶したことで、unlockしたはずのロックが残ってしまう場合がある</title>
	<body>ロックは、基本的に一過性のため、長時間ロックされているロックは、障害によるものと判断して、強制開放する仕組みが欲しい。</body>
	<created>2020-05-20 01:34:42</created>
	<closed>2020-05-20 04:06:58</closed>
</bug>
<bug>
	<id>584</id>
	<title>ClientConnetionを再利用すると、一部前の状態が残っている</title>
	<body></body>
	<created>2020-05-12 01:53:26</created>
	<closed>2020-05-12 03:43:53</closed>
</bug>
<bug>
	<id>582</id>
	<title>ClusterServiceが、FullGCにより、連鎖的に死んでしまった</title>
	<body>ClusterServiceを使っていて、クラスタメンバの1台がFullGCを起こした。FullGCが、長時間続いたため、そのサーバ上のClusterServiceは、隣のサーバ上のClusterServiceからのハートビートが（ハートビート間隔 * ハートビートリトライ回数）以上届いていないと検知して、隣のサーバ上のClusterServiceが死んだと、全員に通知。しかし、死んだとされてしまった、サーバ上のClusterServiceは生きており、クラスタのメンバから除外されてしまった事で、自分の隣のサーバ上のClusterServiceからのハートビートが来なくなり、（ハートビート間隔 * ハートビートリトライ回数）の時間後に、隣のサーバ上のClusterServiceが死んだと、全員に通知。これが繰り返される事で、生きてるはずのClusterServiceが、次々にクラスタメンバから除外される現象が発生した。また、生きているのに除外されてしまった、ClusterServiceが、スプリットブレインを起こし、元のクラスタ構成に復帰するまでに、混乱が発生した。</body>
	<created>2020-05-10 03:12:30</created>
	<closed>2020-05-10 05:18:18</closed>
</bug>
<bug>
	<id>560</id>
	<title>FileOperateActionServiceのLSでファイルが正しく取得できない</title>
	<body></body>
	<created>2020-03-16 09:09:52</created>
	<closed>2020-03-16 09:13:51</closed>
</bug>
<bug>
	<id>557</id>
	<title>SharedQueueのget処理で無限ループが発生することがある</title>
	<body>SharedQueueのget処理で、ローカルでのQueueのサイズが1以上でlockFirtst処理でkeyが取得できない場合無限ループとなってしまう。リモートとローカルでQueueのサイズに不整合が発生した場合に起きる。</body>
	<created>2020-03-16 03:54:18</created>
	<closed>2020-05-25 03:32:45</closed>
</bug>
<bug>
	<id>555</id>
	<title>TestRunnerでHtmlBeanFlowCoverageRepoterが出力できない</title>
	<body></body>
	<created>2020-03-13 01:24:41</created>
	<closed>2020-03-19 05:37:02</closed>
</bug>
<bug>
	<id>552</id>
	<title>KubernetesClusterServiceが、EKS上だとクラスタメンバを正しく認識できない</title>
	<body>あとから追加されたPodを認識できていない。</body>
	<created>2020-03-11 10:10:47</created>
	<closed>2020-03-11 10:31:28</closed>
</bug>
<bug>
	<id>551</id>
	<title>TestRunnerでサービス定義の記載がおかしい際にログが出力される前にプロセスが終了してしまう。</title>
	<body></body>
	<created>2020-03-11 04:12:30</created>
	<closed>2020-03-12 12:15:09</closed>
</bug>
<bug>
	<id>549</id>
	<title>BeanFlowInvokerServerServiceで、ThreadContextを適切に初期化するようにしてほしい</title>
	<body>BeanFlowInvokerServerServiceでは、リモートのThreadContext上のデータを引き継いで、ローカルのThreadContextに反映させる機能があるが、そのThreadContextの初期化が適切に行われていないため、メモリリークや、前回呼び出し時のデータが残る可能性がある。</body>
	<created>2020-03-04 03:44:40</created>
	<closed>2020-03-04 04:12:49</closed>
</bug>
<bug>
	<id>547</id>
	<title>サービス定義で、環境変数が参照できない</title>
	<body></body>
	<created>2020-03-03 02:16:07</created>
	<closed>2020-03-03 02:30:04</closed>
</bug>
<bug>
	<id>537</id>
	<title>ClusterConnectionFactoryServiceが、ClusterService以外のClusterインタフェース実装クラスを許容しない</title>
	<body></body>
	<created>2020-02-27 05:48:15</created>
	<closed>2020-02-27 05:52:43</closed>
</bug>
<bug>
	<id>531</id>
	<title>NimbusExternalizerServiceで、Vectorを直列化できない</title>
	<body></body>
	<created>2020-02-19 10:22:23</created>
	<closed>2020-02-19 10:25:11</closed>
</bug>
<bug>
	<id>520</id>
	<title>CSVCompareEvaluateActionServiceで比較が正しく出来ないことがある</title>
	<body></body>
	<created>2020-02-03 11:16:08</created>
	<closed>2020-02-03 11:20:05</closed>
</bug>
<bug>
	<id>515</id>
	<title>RecordクラスでreplaceRecordSchemaでエラーが発生することがある。</title>
	<body></body>
	<created>2020-01-30 08:51:47</created>
	<closed>2020-01-30 09:44:39</closed>
</bug>
<bug>
	<id>514</id>
	<title>AWSLogsWriterServiceで、作成済みのストリームに追記できない</title>
	<body></body>
	<created>2020-01-30 04:34:47</created>
	<closed>2020-01-30 09:04:22</closed>
</bug>
<bug>
	<id>506</id>
	<title>AuthenticateInterceptorServiceでSessionにAuthenticatedInfoのauthenticatedInfoにnullを設定する事がある</title>
	<body></body>
	<created>2020-01-16 07:35:47</created>
	<closed>2020-01-16 07:38:57</closed>
</bug>
<bug>
	<id>504</id>
	<title>CodeMasterNotifyActionServiceのstartService時のチェックがおかしい</title>
	<body>serverConnectionFactoryの必須チェックは不要</body>
	<created>2019-12-30 04:52:13</created>
	<closed>2019-12-30 05:02:16</closed>
</bug>
<bug>
	<id>492</id>
	<title>RequestConnectionFactoryServiceでrequestを送信する相手が存在しない場合に無限待ちすることがある</title>
	<body></body>
	<created>2019-12-12 08:32:02</created>
	<closed>2019-12-13 08:24:37</closed>
</bug>
<bug>
	<id>488</id>
	<title>DefaultPropertySchemaで、制約式にValidatorのサービス名を指定すると、入力変換のConverterとして使われてしまう</title>
	<body></body>
	<created>2019-12-06 07:34:52</created>
	<closed>2019-12-06 07:37:46</closed>
</bug>
<bug>
	<id>483</id>
	<title>BeanExchangeCovnerterのsetPartPropertyMapping()で同じ入力プロパティに対して、複数の出力プロパティを設定すると正しく動作しない</title>
	<body></body>
	<created>2019-12-04 04:54:25</created>
	<closed>2019-12-04 05:30:13</closed>
</bug>
<bug>
	<id>463</id>
	<title>BeanExchangeConverterで、インデクサを使った、展開機能を使うと、ArrayIndexOutOfBoundsExceptionが発生した。</title>
	<body>setPartIndexedPropertyMapping()で、fromとtoに有効な値を設定して、convert()したら、ArrayIndexOutOfBoundsExceptionが発生しました。</body>
	<created>2019-11-07 02:03:38</created>
	<closed>2019-11-07 02:06:13</closed>
</bug>
<bug>
	<id>455</id>
	<title>DefaultPersistentManagerServiceのloadで、配列のClassを指定すると、無限ループになる</title>
	<body></body>
	<created>2019-10-30 02:44:46</created>
	<closed>2019-10-30 02:46:42</closed>
</bug>
<bug>
	<id>441</id>
	<title>テストFWのSwing画面でサービス定義ロード時にエラーが発生してもコンソールに出力されないことがある。</title>
	<body></body>
	<created>2019-10-17 11:47:17</created>
	<closed>2019-10-17 11:52:46</closed>
</bug>
<bug>
	<id>436</id>
	<title>NestedRecordQueryおよびNestedRecordListQueryの、propertyNamesの指定の有無に関わらず、全量のスキーマ情報が出力される</title>
	<body></body>
	<created>2019-10-11 09:37:48</created>
	<closed>2019-10-11 10:00:49</closed>
</bug>
<bug>
	<id>432</id>
	<title>QueryDataSetのNestedRecordListQueryを指定すると、例外が発生した。</title>
	<body></body>
	<created>2019-10-11 01:35:55</created>
	<closed>2019-10-11 03:33:39</closed>
</bug>
<bug>
	<id>430</id>
	<title>QueryDataSetが直列化できない</title>
	<body>QueryDataSetを非直列化しようとすると、内部クラスが引数なしのコンストラクタがないため、非直列化できずに例外が発生する。</body>
	<created>2019-10-10 01:35:11</created>
	<closed>2019-10-10 05:24:26</closed>
</bug>
<bug>
	<id>426</id>
	<title>QueryDataSetでexecuteQuery()した後で、RecordにsetProperty()すると、例外が発生する</title>
	<body></body>
	<created>2019-10-04 08:31:07</created>
	<closed>2019-10-04 08:51:07</closed>
</bug>
<bug>
	<id>423</id>
	<title>テストフレームワークでテストケースが終了する前にスタブが終了してしまう</title>
	<body></body>
	<created>2019-09-24 08:54:01</created>
	<closed>2019-09-24 09:01:14</closed>
</bug>
<bug>
	<id>419</id>
	<title>テストフレームワークでエラーが発生した場合にメッセージが画面に表示されないことがある</title>
	<body></body>
	<created>2019-09-04 07:37:30</created>
	<closed>2019-09-04 07:47:38</closed>
</bug>
<bug>
	<id>415</id>
	<title>同じ設定の異なるCipherCryptServiceで、暗号化/復号化すると例外が発生</title>
	<body>```javaException in thread "main" java.lang.RuntimeException: javax.crypto.BadPaddingException: Given final block not properly padded        at jdk.nashorn.internal.runtime.ScriptRuntime.apply(ScriptRuntime.java:397)        at jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:449)        at jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:406)        at jdk.nashorn.api.scripting.NashornScriptEngine.evalImpl(NashornScriptEngine.java:402)        at jdk.nashorn.api.scripting.NashornScriptEngine.eval(NashornScriptEngine.java:155)        at javax.script.AbstractScriptEngine.eval(AbstractScriptEngine.java:233)        at jp.ossc.nimbus.service.interpreter.ScriptEngineInterpreterService.evaluate(ScriptEngineInterpreterService.java:235)        at jp.ossc.nimbus.service.crypt.CipherCryptService.main(CipherCryptService.java:3230)Caused by: javax.crypto.BadPaddingException: Given final block not properly padded        at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:991)        at com.sun.crypto.provider.CipherCore.doFinal(CipherCore.java:847)        at com.sun.crypto.provider.DESCipher.engineDoFinal(DESCipher.java:314)        at javax.crypto.Cipher.doFinal(Cipher.java:2047)        at jp.ossc.nimbus.service.crypt.CipherCryptService.doDecodeInternal(CipherCryptService.java:2351)        at jp.ossc.nimbus.service.crypt.CipherCryptService.doDecodeInternal(CipherCryptService.java:2312)        at jp.ossc.nimbus.service.crypt.CipherCryptService.doDecodeBytes(CipherCryptService.java:2264)        at jp.ossc.nimbus.service.crypt.CipherCryptService.doDecodeBytes(CipherCryptService.java:2256)        at jp.ossc.nimbus.service.crypt.CipherCryptService.doDecode(CipherCryptService.java:2244)        at jdk.nashorn.internal.scripts.Script$\^eval\_.:program(&lt;eval&gt;:1)        at jdk.nashorn.internal.runtime.ScriptFunctionData.invoke(ScriptFunctionData.java:637)        at jdk.nashorn.internal.runtime.ScriptFunction.invoke(ScriptFunction.java:494)        at jdk.nashorn.internal.runtime.ScriptRuntime.apply(ScriptRuntime.java:393)        ... 7 more`''</body>
	<created>2019-08-29 09:32:57</created>
	<closed>2019-08-29 09:42:09</closed>
</bug>
<bug>
	<id>400</id>
	<title>DefaultQuerySearchManagerServiceで検索条件にnullを渡した場合にエラーが発生する</title>
	<body></body>
	<created>2019-08-07 09:47:46</created>
	<closed>2019-08-07 09:52:01</closed>
</bug>
<bug>
	<id>390</id>
	<title>RequestConnectionFactoryServiceで、RequestMessageListenerを登録しないと、応答が受け取れない</title>
	<body>RequestConnectionFactoryServiceで、RequestMessageListenerを登録せずに、request()を呼び出すとタイムアウトが発生して、応答が返ってこない。</body>
	<created>2019-08-02 03:23:22</created>
	<closed>2019-08-02 03:32:52</closed>
</bug>
<bug>
	<id>370</id>
	<title>SharedContextServiceでクライアントモードで、サーバの持っているインデックスを使った検索を行うと例外が発生する</title>
	<body>SharedContextServiceでクライアントモードで、サーバの持っているインデックスを使った検索を行うと、以下の例外が発生する。jp.ossc.nimbus.service.publish.MessageException: java.io.InvalidClassException: jp.ossc.nimbus.service.context.SharedContextService$SearchEvent; no valid constructor        jp.ossc.nimbus.service.publish.tcp.MessageImpl.getObject(MessageImpl.java:154)        jp.ossc.nimbus.service.publish.RequestConnectionFactoryService$MessageListenerWrapper.onMessage(RequestConnectionFactoryService.java:822)        jp.ossc.nimbus.service.publish.MessageReceiverService$Subject.onMessage(MessageReceiverService.java:660)        jp.ossc.nimbus.service.publish.MessageReceiverService.handleMessage(MessageReceiverService.java:563)        jp.ossc.nimbus.service.publish.MessageReceiverService.onMessage(MessageReceiverService.java:551)        jp.ossc.nimbus.service.publish.ClusterClientConnectionImpl.onMessage(ClusterClientConnectionImpl.java:531)        jp.ossc.nimbus.service.publish.tcp.ClientConnectionImpl.consume(ClientConnectionImpl.java:946)        jp.ossc.nimbus.daemon.Daemon.run(Daemon.java:505)        java.lang.Thread.run(Thread.java:748)</body>
	<created>2019-07-11 03:42:27</created>
	<closed>2019-07-11 03:45:12</closed>
</bug>
<bug>
	<id>367</id>
	<title>SharedCotextServiceのonUpdate処理でindexの更新処理が実行されていない</title>
	<body>onUpdateの中でローカルに保持しているindex情報に対して受信した更新情報でindex情報を最新かしていない。したがって、更新する可能性のあるプロパティに対してindexを設定している場合は、更新した内容がindexに反映されない。</body>
	<created>2019-06-27 09:43:15</created>
	<closed>2019-07-09 10:54:12</closed>
</bug>
<bug>
	<id>366</id>
	<title>SharedContextのupdateとonUpdateが並列で処理された場合にindexManagerのreplace処理で例外が発生する場合がある</title>
	<body>SharedContextのupdateとonUpdateが同時並行で実行された場合に発生する。onUpdateで更新する場合にローカルデータを一度削除するが、その影響でupdateの中で呼ばれるindexManager.replaceメソッドに渡すoldValueがタイミングによってnullとなりNullPointerExceptionが発生してしまう。</body>
	<created>2019-06-27 09:39:50</created>
	<closed>2019-07-09 10:56:09</closed>
</bug>
<bug>
	<id>356</id>
	<title>BeanFlowRestServerServiceを使って、パラメータをデータセットに適用できない</title>
	<body>BeanFlowRestServerServiceを使って、リクエストパラメータを、requestタグで指定したデータセットに、設定しようとすると、Headerに対する設定はできるが、RecordListに対する設定ができない。</body>
	<created>2019-06-18 03:17:13</created>
	<closed>2019-06-18 04:05:29</closed>
</bug>
<bug>
	<id>339</id>
	<title>BeanTableViewを絞り込まずにnimp(view)を呼び出すとNullPointerExceptionが発生する</title>
	<body>BeanTableViewを絞り込まずにnimp(view)を呼び出すとNullPointerExceptionが発生する</body>
	<created>2019-06-11 08:39:22</created>
	<closed>2019-06-11 08:53:29</closed>
</bug>
<bug>
	<id>327</id>
	<title>サービスのテンプレートを使ったときに、同じテンプレートを適用したサービスが複数存在すると、正しく動かない</title>
	<body>```xml&lt;manager&gt;    &lt;service code="..."                   name="A"                   instance="template"&gt;        &lt;constructor&gt;            &lt;argument&gt;hoge&lt;/argument&gt;        &lt;/constructor&gt;    &lt;/service&gt;    &lt;service name="A1"                   template="#A"/&gt;    &lt;service name="A2"                   template="#A"/&gt;&lt;/manager&gt;````と定義すると、A2のコンストラクタの引数が２つに増えてしまう。</body>
	<created>2019-06-04 08:05:13</created>
	<closed>2019-06-04 08:15:54</closed>
</bug>
<bug>
	<id>309</id>
	<title>BeanExchangeConverterで変換エラーが発生する</title>
	<body></body>
	<created>2019-04-18 06:15:22</created>
	<closed>2019-04-18 06:53:43</closed>
</bug>
<bug>
	<id>296</id>
	<title>SharedContextのlockを並列分散でラッシュすると、タイムアウトが発生する場合がある</title>
	<body></body>
	<created>2019-04-08 06:06:20</created>
	<closed>2019-05-13 04:10:07</closed>
</bug>
<bug>
	<id>287</id>
	<title>SharedContextServiceに、ClientCacheMapのみを設定し、クライアントモードからサーバモードに変わると、ClientCacheMapが有効になってしまう。</title>
	<body></body>
	<created>2019-03-15 09:44:22</created>
	<closed>2019-03-15 09:51:59</closed>
</bug>
<bug>
	<id>281</id>
	<title>SerializableExternalizerServiceで、writeExternal(Object, OutputStream)を呼ぶと、OutputStreamが閉じられてしまう。</title>
	<body></body>
	<created>2019-03-12 12:18:34</created>
	<closed>2019-03-12 12:20:17</closed>
</bug>
<bug>
	<id>272</id>
	<title>BeanFlowを実行するとreload()が必ず呼び出されてしまう</title>
	<body>午前中に起動したサーバで、午後にBeanFlowのreload()を明示的に呼び出すと、それ以降でBeanFlowを実行するたびに、内部でreload()が呼び出され、性能が劣化する。</body>
	<created>2019-03-06 07:55:47</created>
	<closed>2019-03-06 08:01:28</closed>
</bug>
<bug>
	<id>270</id>
	<title>SharedContextに、サーバキャッシュを設定している場合に更新と参照を同時に行うと、正しく更新されない場合がある</title>
	<body>SharedContextに、ファイルに退避するあふれ制御を行うサーバキャッシュを設定している場合に、複数のスレッドで、更新処理と参照処理を同時に行うと、更新した後なのに、更新前の状態のデータが参照される場合がある。</body>
	<created>2019-02-28 09:21:23</created>
	<closed>2019-03-07 07:40:39</closed>
</bug>
<bug>
	<id>268</id>
	<title>StoreCacheOverflowActionServiceを使って、あふれ制御が行われた時に、キャッシュを参照するとnullになることがある</title>
	<body>CacheMapにあふれ制御をつけて、あふれ動作に、StoreCacheOverflowActionServiceを設定している場合で、あふれが発生した瞬間に、あふれたkeyをget()しようとすると、nullが取得されてしまう場合がある。</body>
	<created>2019-02-28 04:34:05</created>
	<closed>2019-02-28 04:37:53</closed>
</bug>
<bug>
	<id>252</id>
	<title>DefaultQueueServiceで、MaxThresholdSizeを指定すると、pushで無限待ちになる場合がある。</title>
	<body>push()の内部処理のpushMonitor.initAndWaitMonitor();で起こされるタイミングを逸すると、無限待ちになっている</body>
	<created>2019-02-08 05:05:58</created>
	<closed>2019-09-18 01:26:05</closed>
</bug>
<bug>
	<id>243</id>
	<title>ConnectionFactoryServiceのdisabledClient()で、宛先アドレス指定で無効化しても、あとから接続した送信先が無効化されない</title>
	<body>jp.ossc.nimbus.service.publish.udp.ConnectionFactoryService及び、jp.ossc.nimbus.service.publish.tcp.ConnectionFactoryServiceのdisabledClient()で、宛先アドレス指定で無効化しても、あとから接続した送信先が無効化されない。意図しない再接続が行われた場合など、disabledClient()したあとに、接続される場合もあるので、あとから接続したクライアントにも、無効化が適用されるようにしてほしい。</body>
	<created>2019-01-18 02:10:52</created>
	<closed>2019-01-18 02:35:50</closed>
</bug>
<bug>
	<id>241</id>
	<title>ClusterClientConnectionFactoryServiceで、joinしていないClusterServiceを使うとNullPointerExceptionが発生する</title>
	<body>ClusterClientConnectionFactoryServiceを使って、ClinetConnectionにconnectしたときに、ClusterServiceがjoinされていない状態だと、NullPointerExceptionが発生した。FlexibleConnectがtrueならば、例外が発生しないのが正しいのでは？</body>
	<created>2019-01-15 05:22:31</created>
	<closed>2019-01-15 05:24:42</closed>
</bug>
<bug>
	<id>226</id>
	<title>MBeanWatcherServiceのPeriodのCount属性が正しく機能しない。</title>
	<body>MBeanWatcherServiceのPeriodのCount属性に、値を指定しても、その回数以上のデータが取得されている。</body>
	<created>2018-12-28 02:26:48</created>
	<closed>2018-12-28 02:32:48</closed>
</bug>
<bug>
	<id>217</id>
	<title>DailyRollingFileAppenderWriterServiceで、日付以下のローリングができない</title>
	<body>DailyRollingFileAppenderWriterServiceを使って、DatePattern属性に、"yyyyMMddHHmm"のように分単位の指定をしても、日付単位でしかローリングできない。</body>
	<created>2018-12-19 10:47:14</created>
	<closed>2018-12-19 10:51:18</closed>
</bug>
<bug>
	<id>216</id>
	<title>ClientBeanFlowInvokerFactoryServiceを使ってBeanFlowを複数リモート呼び出しして、同期待ちすると、エラーを吐かずに待ち続ける場合がある</title>
	<body>ClientBeanFlowInvokerFactoryServiceとBeanFlowInvokerServerServiceを用いて、非同期で複数ホストでのBeanflow呼び出しをし、待合せると待ち続けるという現象が起きた。```xml    &lt;flow name="/CallServerBeanFlow"&gt;        &lt;for index="i" begin="0" end="10"&gt;            &lt;callflow name="test/ServerBeanFlow" factory="WebServer.Servlet#ServerBeanFlowInvokerFactory" stepname="responseDS"  asynch="true" reply="true"&gt;                &lt;argument&gt;&lt;var&gt;i&lt;/var&gt;&lt;/argument&gt;            &lt;/callflow&gt;        &lt;/for&gt;                &lt;!-- 待合せ --&gt;        &lt;for index="i" begin="0" end="10"&gt;            &lt;reply name="ReplyedCallSync" stepname="responseDS"/&gt;        &lt;/for&gt;                &lt;return&gt;&lt;step-ref&gt;responseDS[0]&lt;/step-ref&gt;&lt;/return&gt;    &lt;/flow&gt;```ClientBeanFlowInvokerFactoryService$BeanFlowAsynchInvokeCallbackImpl.replyがrmiのno such object例外を吐いていることが分かった。この例外はBeanFlowAsynchContext.setOutputが握りつぶしている。この例外が発生した場合にログを出力用に修正してほしい。</body>
	<created>2018-12-19 09:51:07</created>
	<closed>2019-02-12 06:43:53</closed>
</bug>
<bug>
	<id>214</id>
	<title>テストフレームワークのTestRunnerでfinallyのアクションが実行されない</title>
	<body>BeforeやActionのアクションでエラーが発生した場合に、AfterとFinallyのアクションが実行されない。</body>
	<created>2018-12-18 01:39:51</created>
	<closed>2018-12-18 02:26:19</closed>
</bug>
<bug>
	<id>212</id>
	<title>テストFWで同じアクションIDが存在する場合の考慮漏れ</title>
	<body>テストFWで同じアクションIDが存在する場合に正常に動作しない</body>
	<created>2018-12-14 02:31:01</created>
	<closed>2018-12-14 05:28:16</closed>
</bug>
<bug>
	<id>206</id>
	<title>テストFWのHttpRequestActionServiceでレスポンスボディが無い場合にエラーになる</title>
	<body>レスポンスからInputStreamが取得できない場合を考慮する必要がある</body>
	<created>2018-12-11 01:45:41</created>
	<closed>2018-12-11 03:19:32</closed>
</bug>
<bug>
	<id>202</id>
	<title>DitributedSharedContextのReash処理で失敗するパターンがある</title>
	<body>DistirbutedSharedContextで他サーバが停止した場合にrehashが実行されるが、rehashが実行する契機としては、クラスタでのメンバー変更とConnectionのSocketエラーがある。ConnectionのSocketエラーでrehashを実行された場合に既にcloseしたConnectionを使用するパターンがあり(Clusterで検知した場合はcloseしたConnectionは捨てられる)、reshashが失敗する。</body>
	<created>2018-12-05 03:50:40</created>
	<closed>2018-12-27 05:28:57</closed>
</bug>
<bug>
	<id>197</id>
	<title>Rehashが有効な複数台構成の分散共有コンテキストで1台停止した場合、他のサーバでStackOverflowが発生する。</title>
	<body>複数台でRehashが有効な分散共有コンテキストを構成している。障害で1台が停止した場合、停止したサーバで使用していたSerConnectionの内部クラスであるClientImplでSocketExceptionが発生する。発生した場合はClientImplのcloseメソッドが実行されるが、その中の処理でDistributedSharedContextService.onRemoveSubject→DistributedSharedContextService.rehash→ServerConnectionImpl.request→ServerConnectionImpl$ClientImpl.send→ServerConnectionImpl$ClientImpl.writeBuffer(この時にSockerException発生)→ServerConnectionImpl$ClientImpl.close→DistributedSharedContextService.onRemoveSubject...の順番で処理が実行され、無限ループとなってStackOverFlowが発生しているように見える。</body>
	<created>2018-12-04 06:40:44</created>
	<closed>2018-12-05 01:26:00</closed>
</bug>
<bug>
	<id>189</id>
	<title>constructor要素の直下にifdef要素を指定しても、有効にならない。</title>
	<body>以下のように、記述したが、想定通りに動作しなかった。```xml        &lt;manager-property name="Template.Service.BeanControl.Interceptor.JOURNAL_INTERCEPTOR_SERVICE_NAME"&gt;#JournalInterceptor&lt;/manager-property&gt;        &lt;manager-property name="Template.Service.BeanControl.Interceptor.METRICS_INTERCEPTOR_SERVICE_NAME"&gt;#BeanFlowMetricsInterceptor&lt;/manager-property&gt;        &lt;manager-property name="Template.Service.BeanControl.Interceptor.EXCEPTION_HANDLING_INTERCEPTOR_SERVICE_NAME"&gt;#BeanFlowExceptionHandlingInterceptor&lt;/manager-property&gt;        &lt;service name="BeanFlowInterceptorChainList"                 code="jp.ossc.nimbus.service.aop.DefaultInterceptorChainListService"                 instance="template"&gt;            &lt;attribute name="InterceptorServiceNames"&gt;                &lt;object code="jp.ossc.nimbus.core.ServiceName[]"&gt;                    &lt;constructor&gt;&lt;ifdef name="Template.Service.BeanControl.Interceptor.JOURNAL_INTERCEPTOR_SERVICE_NAME"&gt;                        &lt;argument type="jp.ossc.nimbus.core.ServiceName"&gt;${Template.Service.BeanControl.Interceptor.JOURNAL_INTERCEPTOR_SERVICE_NAME}&lt;/argument&gt;&lt;/ifdef&gt;&lt;ifdef name="Template.Service.BeanControl.Interceptor.METRICS_INTERCEPTOR_SERVICE_NAME"&gt;                        &lt;argument type="jp.ossc.nimbus.core.ServiceName"&gt;${Template.Service.BeanControl.Interceptor.METRICS_INTERCEPTOR_SERVICE_NAME}&lt;/argument&gt;&lt;/ifdef&gt;&lt;ifdef name="Template.Service.BeanControl.Interceptor.EXCEPTION_HANDLING_INTERCEPTOR_SERVICE_NAME"&gt;                        &lt;argument type="jp.ossc.nimbus.core.ServiceName"&gt;${Template.Service.BeanControl.Interceptor.EXCEPTION_HANDLING_INTERCEPTOR_SERVICE_NAME}&lt;/argument&gt;&lt;/ifdef&gt;                    &lt;/constructor&gt;                &lt;/object&gt;            &lt;/attribute&gt;&lt;ifdef name="Template.Service.BeanControl.Interceptor.JOURNAL_INTERCEPTOR_SERVICE_NAME"&gt;            &lt;depends&gt;${Template.Service.BeanControl.Interceptor.JOURNAL_INTERCEPTOR_SERVICE_NAME}&lt;/depends&gt;&lt;/ifdef&gt;&lt;ifdef name="Template.Service.BeanControl.Interceptor.METRICS_INTERCEPTOR_SERVICE_NAME"&gt;            &lt;depends&gt;${Template.Service.BeanControl.Interceptor.METRICS_INTERCEPTOR_SERVICE_NAME}&lt;/depends&gt;&lt;/ifdef&gt;&lt;ifdef name="Template.Service.BeanControl.Interceptor.EXCEPTION_HANDLING_INTERCEPTOR_SERVICE_NAME"&gt;            &lt;depends&gt;${Template.Service.BeanControl.Interceptor.EXCEPTION_HANDLING_INTERCEPTOR_SERVICE_NAME}&lt;/depends&gt;&lt;/ifdef&gt;        &lt;/service&gt;```</body>
	<created>2018-11-26 06:07:36</created>
	<closed>2018-11-26 07:18:10</closed>
</bug>
<bug>
	<id>179</id>
	<title>TcpKeepAliveCheckerServiceのsetRequestBytes(byte[])で設定したバイトが使用されていない</title>
	<body>類似で、WebSocketKeepAliveCheckerServiceも。</body>
	<created>2018-11-14 05:59:01</created>
	<closed>2018-11-15 01:06:49</closed>
</bug>
<bug>
	<id>177</id>
	<title>サーバコネクションのisStartReceiveの不正について</title>
	<body>株アプリでRRと価格アラートの間に通信の問題が発生した。現象は通信グループの仲間として認識できているにも関わらず、SharedContextのサーバ側のisStartReceiveはfalseになっていた。再現方法は今段階は不明。</body>
	<created>2018-11-13 06:11:17</created>
	<closed>2018-11-14 04:01:12</closed>
</bug>
<bug>
	<id>175</id>
	<title>DistributedSharedContextServiceのtimeoutが正しく動作しない</title>
	<body>DistributedSharedContextServiceのtimeoutが、指定した時間でタイムアウトしない。</body>
	<created>2018-11-13 04:48:39</created>
	<closed>2018-11-13 06:14:48</closed>
</bug>
<bug>
	<id>171</id>
	<title>Beanflowにて@inputDef(input name).属性名@でアクセスできない</title>
	<body>Beanflowにて@inputDef(input name).属性名@でアクセスできない。＠input name.属性名＠ではできる。</body>
	<created>2018-11-09 01:05:42</created>
	<closed>2018-11-09 02:42:32</closed>
</bug>
<bug>
	<id>169</id>
	<title>JavaDBでDatabaseScheduleManagerServiceが正しく動作しない</title>
	<body></body>
	<created>2018-11-08 02:05:13</created>
	<closed>2018-11-08 11:43:08</closed>
</bug>
<bug>
	<id>167</id>
	<title>DatabaseScheduleManagerServiceで、SCHEDULE_TABLEのROWVERSIONの型をINTEGERにすると、例外が発生する</title>
	<body>DatabaseScheduleManagerServiceを使っていて、SCHEDULE_TABLEのROWVERSIONの列の型をINTEGERにすると、以下の例外が発生して、スケジュールが作成できない。     [java] Caused by: java.sql.SQLSyntaxErrorException: Columns of type 'INTEGER' cannot hold values of type 'CHAR'.     [java]     org.apache.derby.impl.jdbc.SQLExceptionFactory.getSQLException(Unknown Source)     [java]     org.apache.derby.impl.jdbc.Util.generateCsSQLException(Unknown Source)     [java]     org.apache.derby.impl.jdbc.TransactionResourceImpl.wrapInSQLException(Unknown Source)     [java]     org.apache.derby.impl.jdbc.TransactionResourceImpl.handleException(Unknown Source)     [java]     org.apache.derby.impl.jdbc.EmbedConnection.handleException(Unknown Source)     [java]     org.apache.derby.impl.jdbc.ConnectionChild.handleException(Unknown Source)     [java]     org.apache.derby.impl.jdbc.EmbedPreparedStatement.&lt;init&gt;(Unknown Source)     [java]     org.apache.derby.impl.jdbc.EmbedPreparedStatement42.&lt;init&gt;(Unknown Source)     [java]     org.apache.derby.jdbc.Driver42.newEmbedPreparedStatement(Unknown Source)     [java]     org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)     [java]     org.apache.derby.impl.jdbc.EmbedConnection.prepareStatement(Unknown Source)     [java]     jp.ossc.nimbus.service.scheduler2.DatabaseScheduleManagerService.makeSchedule(DatabaseScheduleManagerService.java:631) </body>
	<created>2018-11-07 05:08:57</created>
	<closed>2018-11-07 11:45:28</closed>
</bug>
<bug>
	<id>161</id>
	<title>beanflow 実行時に if文 test属性部分の評価で NoSuchPropertyException が発生する。</title>
	<body>下記 beanflow 実行時に if文 test属性部分の評価で NoSuchPropertyException が発生する。```&lt;if test="@CheckAyumi[0].COUNT@ != '0'"&gt; ：：&lt;/if&gt;※CheckAyumi は、Result=[{COUNT=0}]Exception=Exception occuers :jp.ossc.nimbus.beans.NoSuchPropertyException: No such property. class=class jp.ossc.nimbus.service.beancontrol.BeanFlowInvokerAccessImpl2$StepContext, property=CheckAyumi[0]jp.ossc.nimbus.beans.IndexedProperty.getIndexedObjectProperty(IndexedProperty.java:1439)jp.ossc.nimbus.beans.IndexedProperty.getProperty(IndexedProperty.java:503)jp.ossc.nimbus.service.beancontrol.BeanFlowInvokerAccessImpl2$Test.evaluate(BeanFlowInvokerAccessImpl2.java:6507)jp.ossc.nimbus.service.beancontrol.BeanFlowInvokerAccessImpl2$IfMetaData.isMatch(BeanFlowInvokerAccessImpl2.java:5361)jp.ossc.nimbus.service.beancontrol.BeanFlowInvokerAccessImpl2$IfMetaData.invokeStep(BeanFlowInvokerAccessImpl2.java:5375)```使用バージョン ： nimbus-20181029.112313.jar</body>
	<created>2018-10-31 07:12:38</created>
	<closed>2018-10-31 07:57:04</closed>
</bug>
<bug>
	<id>159</id>
	<title>SharedContextサービス起動時にClusterMemberの数とServerConnectionが認識しているClientの数が合わずに起動しない</title>
	<body></body>
	<created>2018-10-29 02:41:38</created>
	<closed>2018-10-31 07:04:04</closed>
</bug>
<bug>
	<id>152</id>
	<title>multicastでの配信で、クラスタ化したコネクションを複数生成すると、メッセージを重複して受信してしまう</title>
	<body>jp.ossc.nimbus.service.publish.udp.ConnectionFactoryServiceをマルチキャストで送受信するように設定したうえで、jp.ossc.nimbus.service.publish.ClusterConnectionFactoryServiceにクラスタ化する。それを受信側のサーバで、jp.ossc.nimbus.service.publish.ClusterClientConnectionFactoryServiceを使って、ClientConnectionを複数つなぐと、各Connectionに同じIDが振られてしまい、メッセージを重複して受信してしまう。</body>
	<created>2018-10-02 06:28:28</created>
	<closed>2018-10-02 07:00:36</closed>
</bug>
<bug>
	<id>148</id>
	<title>MessageReceiverServiceの同期化による性能ネック問題</title>
	<body>MessageReceiverServiceで、サブジェクトの登録/削除と、メッセージのリサイクルが同期化されていて性能ネックになる。</body>
	<created>2018-09-21 09:25:37</created>
	<closed>2018-09-28 04:27:55</closed>
</bug>
<bug>
	<id>140</id>
	<title>Input-defの属性を@@でアクセスできるようにして欲しい</title>
	<body>現在、&lt;test&gt;でInput-defの属性を@@でアクセスできない。</body>
	<created>2018-08-02 03:30:24</created>
	<closed>2018-08-07 01:36:41</closed>
</bug>
<bug>
	<id>129</id>
	<title>DefaultPersistantManagerでNumber型カラムのNull値扱いについて</title>
	<body>下記の条件で、DefaultPersistentManagerServiceを使ってDBカラムをRecordListのカラムに変換する際に、nullの値が0に変換される事象が発生します。・DBカラムがNUMBER型、値はnull・RecordListのカラムはint型DBカラムがNUMBER型でnullの値の場合に、nullが返却されなくなりました。以前のNimbusバージョン(1.2.0)ではnullを返却できました。アプリ側では、nullと0を分けて扱っております。</body>
	<created>2018-07-11 08:04:07</created>
	<closed>2018-07-11 08:34:09</closed>
</bug>
<bug>
	<id>128</id>
	<title>ClusterServiceのメインハートビートのタイムアウトの計算について</title>
	<body>HeartBeatResponseTimeoutが考慮されていなさそうです。```java            if(isMain){                sendMessage(MESSAGE_ID_MAIN_HELLO_REQ);                synchronized(clientMembers){                    clients = clientMembers.size() == 0 ? null : (GlobalUID[])clientMembers.values().toArray(new GlobalUID[clientMembers.size()]);                    if(clients != null){                        for(int i = 0; i &lt; clients.length; i++){                            if(lastSendTime - (heartBeatInterval * heartBeatRetryCount) &gt; clients[i].lastHeartBeatTime){                                clientMembers.remove(clients[i]);                                getLogger().write(MSG_ID_MESSAGE_CLIENT_REMOVE, new Object[]{getServiceNameObject(), clients[i]});                            }                        }                    }                }```</body>
	<created>2018-07-11 07:59:55</created>
	<closed>2018-07-11 08:26:36</closed>
</bug>
<bug>
	<id>124</id>
	<title>DeflateHttpServletResponseWrapperのdeflateLengthがコンストラクタで設定されないバグ</title>
	<body>DeflateHttpServletResponseWrapperのdeflateLengthがコンストラクタで設定されてないので、設定されるようになおしてください。</body>
	<created>2018-07-05 07:36:16</created>
	<closed>2018-07-12 04:08:37</closed>
</bug>
<bug>
	<id>117</id>
	<title>BeanFlowのCompilerでTest用Interpreter以外が指定できない</title>
	<body>BeanFlowのCompilerでTest用Interpreter以外も指定できるようにしてほしい。</body>
	<created>2018-06-27 08:41:11</created>
	<closed>2018-06-27 09:56:39</closed>
</bug>
<bug>
	<id>113</id>
	<title>BeanFlowのCompilerで、transaction属性を指定したflowのコンパイルができない</title>
	<body>以下のような例外が発生します。Caused by: javax.naming.NoInitialContextException: Need to specify class name in environment or system property, or as an applet parameter, or in an application resource file:  java.naming.factory.initial        javax.naming.spi.NamingManager.getInitialContext(NamingManager.java:662)        javax.naming.InitialContext.getDefaultInitCtx(InitialContext.java:313)        javax.naming.InitialContext.getURLOrDefaultInitCtx(InitialContext.java:350)        javax.naming.InitialContext.lookup(InitialContext.java:417)        jp.ossc.nimbus.service.transaction.JndiTransactionManagerFactoryService.getTransactionManager(JndiTransactionManagerFactoryService.java:96)        jp.ossc.nimbus.service.beancontrol.BeanFlowInvokerAccessImpl2.fillInstance(BeanFlowInvokerAccessImpl2.java:434)        jp.ossc.nimbus.service.beancontrol.DefaultBeanFlowInvokerFactoryService.loadXMLDefinition(DefaultBeanFlowInvokerFactoryService.java:981)        jp.ossc.nimbus.service.beancontrol.DefaultBeanFlowInvokerFactoryService.reload(DefaultBeanFlowInvokerFactoryService.java:1224)        jp.ossc.nimbus.service.beancontrol.DefaultBeanFlowInvokerFactoryService.startService(DefaultBeanFlowInvokerFactoryService.java:699)        jp.ossc.nimbus.core.ServiceBase.start(ServiceBase.java:569)        jp.ossc.nimbus.service.beancontrol.Compiler.compile(Compiler.java:150)        jp.ossc.nimbus.service.beancontrol.Compiler.main(Compiler.java:346)        sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)        sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)        sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)        java.lang.reflect.Method.invoke(Method.java:498)        org.apache.tools.ant.taskdefs.ExecuteJava.run(ExecuteJava.java:217)        org.apache.tools.ant.taskdefs.ExecuteJava.execute(ExecuteJava.java:152)        org.apache.tools.ant.taskdefs.Java.run(Java.java:771)        org.apache.tools.ant.taskdefs.Java.executeJava(Java.java:221)        org.apache.tools.ant.taskdefs.Java.executeJava(Java.java:135)        org.apache.tools.ant.taskdefs.Java.execute(Java.java:108)        org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)        sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)        sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)        sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)        java.lang.reflect.Method.invoke(Method.java:498)        org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)        org.apache.tools.ant.Task.perform(Task.java:348)        org.apache.tools.ant.taskdefs.Sequential.execute(Sequential.java:68)        sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)        sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)        sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)        java.lang.reflect.Method.invoke(Method.java:498)        org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)        org.apache.tools.ant.Task.perform(Task.java:348)        net.sf.antcontrib.logic.IfTask.execute(Unknown Source)        sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)        sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)        sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)        java.lang.reflect.Method.invoke(Method.java:498)        org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)        org.apache.tools.ant.TaskAdapter.execute(TaskAdapter.java:154)        org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)        sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)        sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)        sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)        java.lang.reflect.Method.invoke(Method.java:498)        org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)        org.apache.tools.ant.Task.perform(Task.java:348)        org.apache.tools.ant.Target.execute(Target.java:390)        org.apache.tools.ant.Target.performTasks(Target.java:411)        org.apache.tools.ant.Project.executeSortedTargets(Project.java:1397)        org.apache.tools.ant.Project.executeTarget(Project.java:1366)        org.apache.maven.plugin.antrun.AntRunMojo.execute(AntRunMojo.java:265)        org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134)        org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:208)        org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:154)        org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:146)        org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:117)        org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:81)        org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51)        org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128)        org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:309)        org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:194)        org.apache.maven.DefaultMaven.execute(DefaultMaven.java:107)        org.apache.maven.cli.MavenCli.execute(MavenCli.java:955)        org.apache.maven.cli.MavenCli.doMain(MavenCli.java:290)        org.apache.maven.cli.MavenCli.main(MavenCli.java:194)        sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)        sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)        sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)        java.lang.reflect.Method.invoke(Method.java:498)        org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289)        org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229)        org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415)        org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)</body>
	<created>2018-06-27 03:57:48</created>
	<closed>2018-06-27 04:10:29</closed>
</bug>
<bug>
	<id>100</id>
	<title>テストリソースのみをリソースとしてコピーできない不具合を修正した。</title>
	<body>@m-takata 修正したのでマージお願いします。</body>
	<created>2018-05-24 02:13:49</created>
	<closed>2018-05-24 05:39:19</closed>
</bug>
<bug>
	<id>98</id>
	<title>GitTestResourceManagerServiceでチェックアウト時の不具合</title>
	<body>GitTestResourceManagerServiceでチェックアウトするときに、テストリソースのみをリソースとしてコピーできない。</body>
	<created>2018-05-23 10:09:38</created>
	<closed>2018-05-24 06:05:45</closed>
</bug>
<bug>
	<id>84</id>
	<title>DataSetServletRequestParameterConverterのMultipart処理が実行されない。</title>
	<body>DataSetServletRequestParameterConverterのconvertメソッドの以下は&amp;&amp;が正しいですか？contentType != null があるので、multipart処理に入らないです。L355if(contentType != null || (!contentType.toLowerCase().startsWith(MULTIPART))){            paramMap = request.getParameterMap();        }else{</body>
	<created>2018-05-14 03:52:18</created>
	<closed>2018-05-19 02:33:26</closed>
</bug>
<bug>
	<id>43</id>
	<title>Nimbusコンソール上でコネクションが表示されない</title>
	<body>同じConnectionFactoryを使って複数のConnectionを作ったときに、1番最初か1番最後かの1つのConnectionしかNimbus-Consoleに表示されない。</body>
	<created>2018-04-06 06:16:32</created>
	<closed>2018-04-06 09:58:24</closed>
</bug>
<bug>
	<id>42</id>
	<title>Java7ソートアルゴリズム仕様変更に伴いエラーが発生する場合がある</title>
	<body>「Comparison method violates its general contract!」のエラーが発生する場合がある。調べたところ、「Java6ではこのエラーは出なかったが、Java7へバージョンアップした際にソートアルゴリズムが変わりこのエラーが出るようになる」とのこと。JBOSS起動時のオプションで1.6相当のソートアルゴリズムを使用するオプションに変更することで対策をとっているが、根本的な対策はあるか？以下、エラーログです。```--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------2018-03-11 11:35:00,982 INFO [STDOUT] 2018/03/11 11:35:00,UNKNOWN,FRAMEWORK_ERROR,[TPS_00002]Topic publish error. Retry out.java.lang.IllegalArgumentException: Comparison method violates its general contract! java.util.ComparableTimSort.mergeHi(ComparableTimSort.java:835) java.util.ComparableTimSort.mergeAt(ComparableTimSort.java:453) java.util.ComparableTimSort.mergeCollapse(ComparableTimSort.java:376) java.util.ComparableTimSort.sort(ComparableTimSort.java:182) java.util.ComparableTimSort.sort(ComparableTimSort.java:146) java.util.Arrays.sort(Arrays.java:472) java.util.Collections.sort(Collections.java:155) jp.ossc.nimbus.service.publish.DistributedServerConnectionImpl.selectConnection(DistributedServerConnectionImpl.java:71) jp.ossc.nimbus.service.publish.DistributedServerConnectionImpl.send(DistributedServerConnectionImpl.java:80) jp.co.nri.its.feed.service.publisher.ServerConnectionPublisherService.publish(ServerConnectionPublisherService.java:85) jp.co.nri.its.feed.service.publisher.CulledPublisherService$Checker.consume(CulledPublisherService.java:147) jp.ossc.nimbus.daemon.Daemon.run(Daemon.java:505) java.lang.Thread.run(Thread.java:745)--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------```</body>
	<created>2018-04-06 05:56:18</created>
	<closed>2018-04-06 09:31:59</closed>
</bug>
<bug>
	<id>30</id>
	<title>NimbusExternalizerServiceでClassオブジェクトを非直列化できない</title>
	<body>以下のように実行すると、例外が発生する。```bsh % import jp.ossc.nimbus.service.io.*;bsh % NimbusExternalizerService ext = new NimbusExternalizerService();bsh % ext.create();bsh % ext.start();bsh % import java.io.*;bsh % ByteArrayOutputStream baos = new ByteArrayOutputStream();bsh % ext.writeExternal(String.class, baos);bsh % ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());bsh % print(ext.readExternal(bais));java.lang.IllegalAccessError: java.lang.Class        at sun.reflect.GeneratedSerializationConstructorAccessor4.newInstance(Unknown Source)        at java.lang.reflect.Constructor.newInstance(Constructor.java:423)        at jp.ossc.nimbus.service.io.NimbusExternalizerService$MetaClass.newInstance(NimbusExternalizerService.java:1081)        at jp.ossc.nimbus.service.io.NimbusExternalizerService$NimbusObjectInputStream.readObjectOverride(NimbusExternalizerService.java:522)        at java.io.ObjectInputStream.readObject(ObjectInputStream.java:421)        at jp.ossc.nimbus.service.io.SerializableExternalizerService.readInternal(SerializableExternalizerService.java:490)        at jp.ossc.nimbus.service.io.SerializableExternalizerService.readExternal(SerializableExternalizerService.java:428)        at jp.ossc.nimbus.service.io.SerializableExternalizerService.readExternal(SerializableExternalizerService.java:404)        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)        at java.lang.reflect.Method.invoke(Method.java:498)        at bsh.Reflect.invokeMethod(Unknown Source)        at bsh.Reflect.invokeObjectMethod(Unknown Source)        at bsh.Name.invokeMethod(Unknown Source)        at bsh.BSHMethodInvocation.eval(Unknown Source)        at bsh.BSHPrimaryExpression.eval(Unknown Source)        at bsh.BSHPrimaryExpression.eval(Unknown Source)        at bsh.BSHArguments.getArguments(Unknown Source)        at bsh.BSHMethodInvocation.eval(Unknown Source)        at bsh.BSHPrimaryExpression.eval(Unknown Source)        at bsh.BSHPrimaryExpression.eval(Unknown Source)        at bsh.Interpreter.run(Unknown Source)        at bsh.Interpreter.main(Unknown Source)```</body>
	<created>2018-03-02 06:56:32</created>
	<closed>2018-03-05 07:49:59</closed>
</bug>
<bug>
	<id>26</id>
	<title>DistributedSharedContextServiceのsave()中に、SharedContextServletの画面操作が固まる</title>
	<body>DistributedSharedContextServiceのメソッドが、thisに対してsynchronizedなメソッドが多いため、ロックされてしまっている。</body>
	<created>2018-02-28 00:57:03</created>
	<closed>2018-02-28 01:55:36</closed>
</bug>
<bug>
	<id>23</id>
	<title>作成したjarを参照して、mvnコマンドからコンパイルを行うと、nimbusのjarに含まれるソースコンがコンパイル対象となってしまう</title>
	<body></body>
	<created>2018-02-22 12:10:01</created>
	<closed>2018-02-23 01:52:10</closed>
</bug>
<bug>
	<id>22</id>
	<title>javadoc生成時にエラーが発生する</title>
	<body>Java8でのJavadoc生成でエラーが発生する。</body>
	<created>2018-02-22 12:08:05</created>
	<closed>2018-02-23 01:52:01</closed>
</bug>
<bug>
	<id>18</id>
	<title>AuthenticateInterceptorServiceでThreadContextに認証情報が設定されないことがある</title>
	<body>Sessionが破棄されるタイミングと処理が動くタイミングによって、発生する可能性がある。</body>
	<created>2018-02-20 09:47:07</created>
	<closed>2018-02-21 01:08:56</closed>
</bug>
<bug>
	<id>16</id>
	<title>すべてのソースがコンパイル対象となる</title>
	<body>一部のソース修正し、コンパイルする際に、すべてのソースが再コンパイル対象となる</body>
	<created>2018-02-19 10:28:02</created>
	<closed>2018-02-20 06:45:39</closed>
</bug>
<bug>
	<id>13</id>
	<title>NimbusExternalizerServiceで、java.sql.Timestampが正しく直列化できない</title>
	<body>NimbusExternalizerServiceで、java.sql.Timestampを直列化して、非直列化すると、時刻が異なる時刻になってしまう。</body>
	<created>2018-02-15 04:39:07</created>
	<closed>2018-02-20 01:43:10</closed>
</bug>
<bug>
	<id>8</id>
	<title>BeanFlowのifの下のwhileでbreakすると、whileの後のステップ毎breakされてしまう</title>
	<body>```&lt;if&gt;    &lt;while&gt;         &lt;if&gt;             &lt;break/&gt;    ←ここでbreakすると         &lt;/if&gt;    &lt;/while&gt;    &lt;step&gt;   ←このステップが実行されない    &lt;/step&gt;&lt;if&gt;```</body>
	<created>2018-02-08 11:44:03</created>
	<closed>2018-02-08 11:59:14</closed>
</bug>
<bug>
	<id>2</id>
	<title>ShredContextServletの画面が崩れる</title>
	<body>keyset画面のRemoveボタンのカラムが崩れる</body>
	<created>2018-02-08 07:02:00</created>
	<closed>2018-02-08 07:38:25</closed>
</bug>
